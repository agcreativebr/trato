"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tiptap";
exports.ids = ["vendor-chunks/@tiptap"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tiptap/core/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandManager: () => (/* binding */ CommandManager),\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Extendable: () => (/* binding */ Extendable),\n/* harmony export */   Extension: () => (/* binding */ Extension),\n/* harmony export */   Fragment: () => (/* binding */ Fragment6),\n/* harmony export */   InputRule: () => (/* binding */ InputRule),\n/* harmony export */   MappablePosition: () => (/* binding */ MappablePosition),\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   MarkView: () => (/* binding */ MarkView),\n/* harmony export */   Node: () => (/* binding */ Node3),\n/* harmony export */   NodePos: () => (/* binding */ NodePos),\n/* harmony export */   NodeView: () => (/* binding */ NodeView),\n/* harmony export */   PasteRule: () => (/* binding */ PasteRule),\n/* harmony export */   ResizableNodeView: () => (/* binding */ ResizableNodeView),\n/* harmony export */   ResizableNodeview: () => (/* binding */ ResizableNodeview),\n/* harmony export */   Tracker: () => (/* binding */ Tracker),\n/* harmony export */   callOrReturn: () => (/* binding */ callOrReturn),\n/* harmony export */   canInsertNode: () => (/* binding */ canInsertNode),\n/* harmony export */   combineTransactionSteps: () => (/* binding */ combineTransactionSteps),\n/* harmony export */   commands: () => (/* binding */ commands_exports),\n/* harmony export */   createAtomBlockMarkdownSpec: () => (/* binding */ createAtomBlockMarkdownSpec),\n/* harmony export */   createBlockMarkdownSpec: () => (/* binding */ createBlockMarkdownSpec),\n/* harmony export */   createChainableState: () => (/* binding */ createChainableState),\n/* harmony export */   createDocument: () => (/* binding */ createDocument),\n/* harmony export */   createElement: () => (/* binding */ h),\n/* harmony export */   createInlineMarkdownSpec: () => (/* binding */ createInlineMarkdownSpec),\n/* harmony export */   createMappablePosition: () => (/* binding */ createMappablePosition),\n/* harmony export */   createNodeFromContent: () => (/* binding */ createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* binding */ createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* binding */ defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* binding */ deleteProps),\n/* harmony export */   elementFromString: () => (/* binding */ elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* binding */ escapeForRegEx),\n/* harmony export */   extensions: () => (/* binding */ extensions_exports),\n/* harmony export */   findChildren: () => (/* binding */ findChildren),\n/* harmony export */   findChildrenInRange: () => (/* binding */ findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* binding */ findDuplicates),\n/* harmony export */   findParentNode: () => (/* binding */ findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* binding */ findParentNodeClosestToPos),\n/* harmony export */   flattenExtensions: () => (/* binding */ flattenExtensions),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   generateHTML: () => (/* binding */ generateHTML),\n/* harmony export */   generateJSON: () => (/* binding */ generateJSON),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getAttributes: () => (/* binding */ getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* binding */ getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* binding */ getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* binding */ getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* binding */ getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* binding */ getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* binding */ getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* binding */ getMarkRange),\n/* harmony export */   getMarkType: () => (/* binding */ getMarkType),\n/* harmony export */   getMarksBetween: () => (/* binding */ getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* binding */ getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* binding */ getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* binding */ getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* binding */ getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* binding */ getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* binding */ getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* binding */ getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* binding */ getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* binding */ getSplittedAttributes),\n/* harmony export */   getText: () => (/* binding */ getText),\n/* harmony export */   getTextBetween: () => (/* binding */ getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* binding */ getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* binding */ getTextSerializersFromSchema),\n/* harmony export */   getUpdatedPosition: () => (/* binding */ getUpdatedPosition),\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* binding */ injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* binding */ inputRulesPlugin),\n/* harmony export */   isActive: () => (/* binding */ isActive),\n/* harmony export */   isAndroid: () => (/* binding */ isAndroid),\n/* harmony export */   isAtEndOfNode: () => (/* binding */ isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* binding */ isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* binding */ isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* binding */ isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isList: () => (/* binding */ isList),\n/* harmony export */   isMacOS: () => (/* binding */ isMacOS),\n/* harmony export */   isMarkActive: () => (/* binding */ isMarkActive),\n/* harmony export */   isNodeActive: () => (/* binding */ isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* binding */ isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* binding */ isNodeSelection),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRegExp: () => (/* binding */ isRegExp),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isTextSelection: () => (/* binding */ isTextSelection),\n/* harmony export */   isiOS: () => (/* binding */ isiOS),\n/* harmony export */   markInputRule: () => (/* binding */ markInputRule),\n/* harmony export */   markPasteRule: () => (/* binding */ markPasteRule),\n/* harmony export */   markdown: () => (/* binding */ markdown_exports),\n/* harmony export */   mergeAttributes: () => (/* binding */ mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* binding */ mergeDeep),\n/* harmony export */   minMax: () => (/* binding */ minMax),\n/* harmony export */   nodeInputRule: () => (/* binding */ nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* binding */ nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* binding */ objectIncludes),\n/* harmony export */   parseAttributes: () => (/* binding */ parseAttributes),\n/* harmony export */   parseIndentedBlocks: () => (/* binding */ parseIndentedBlocks),\n/* harmony export */   pasteRulesPlugin: () => (/* binding */ pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* binding */ posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* binding */ removeDuplicates),\n/* harmony export */   renderNestedMarkdownContent: () => (/* binding */ renderNestedMarkdownContent),\n/* harmony export */   resolveExtensions: () => (/* binding */ resolveExtensions),\n/* harmony export */   resolveFocusPosition: () => (/* binding */ resolveFocusPosition),\n/* harmony export */   rewriteUnknownContent: () => (/* binding */ rewriteUnknownContent),\n/* harmony export */   selectionToInsertionEnd: () => (/* binding */ selectionToInsertionEnd),\n/* harmony export */   serializeAttributes: () => (/* binding */ serializeAttributes),\n/* harmony export */   sortExtensions: () => (/* binding */ sortExtensions),\n/* harmony export */   splitExtensions: () => (/* binding */ splitExtensions),\n/* harmony export */   textInputRule: () => (/* binding */ textInputRule),\n/* harmony export */   textPasteRule: () => (/* binding */ textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* binding */ textblockTypeInputRule),\n/* harmony export */   updateMarkViewAttributes: () => (/* binding */ updateMarkViewAttributes),\n/* harmony export */   wrappingInputRule: () => (/* binding */ wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/transform */ \"(ssr)/./node_modules/@tiptap/pm/dist/transform/index.js\");\n/* harmony import */ var _tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/commands */ \"(ssr)/./node_modules/@tiptap/pm/dist/commands/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/model */ \"(ssr)/./node_modules/@tiptap/pm/dist/model/index.js\");\n/* harmony import */ var _tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/schema-list */ \"(ssr)/./node_modules/@tiptap/pm/dist/schema-list/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/dist/view/index.js\");\n/* harmony import */ var _tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/pm/keymap */ \"(ssr)/./node_modules/@tiptap/pm/dist/keymap/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/helpers/createChainableState.ts\nfunction createChainableState(config) {\n  const { state, transaction } = config;\n  let { selection } = transaction;\n  let { doc } = transaction;\n  let { storedMarks } = transaction;\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks;\n    },\n    get selection() {\n      return selection;\n    },\n    get doc() {\n      return doc;\n    },\n    get tr() {\n      selection = transaction.selection;\n      doc = transaction.doc;\n      storedMarks = transaction.storedMarks;\n      return transaction;\n    }\n  };\n}\n\n// src/CommandManager.ts\nvar CommandManager = class {\n  constructor(props) {\n    this.editor = props.editor;\n    this.rawCommands = this.editor.extensionManager.commands;\n    this.customState = props.state;\n  }\n  get hasCustomState() {\n    return !!this.customState;\n  }\n  get state() {\n    return this.customState || this.editor.state;\n  }\n  get commands() {\n    const { rawCommands, editor, state } = this;\n    const { view } = editor;\n    const { tr } = state;\n    const props = this.buildProps(tr);\n    return Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command2]) => {\n        const method = (...args) => {\n          const callback = command2(...args)(props);\n          if (!tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n            view.dispatch(tr);\n          }\n          return callback;\n        };\n        return [name, method];\n      })\n    );\n  }\n  get chain() {\n    return () => this.createChain();\n  }\n  get can() {\n    return () => this.createCan();\n  }\n  createChain(startTr, shouldDispatch = true) {\n    const { rawCommands, editor, state } = this;\n    const { view } = editor;\n    const callbacks = [];\n    const hasStartTransaction = !!startTr;\n    const tr = startTr || state.tr;\n    const run3 = () => {\n      if (!hasStartTransaction && shouldDispatch && !tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n        view.dispatch(tr);\n      }\n      return callbacks.every((callback) => callback === true);\n    };\n    const chain = {\n      ...Object.fromEntries(\n        Object.entries(rawCommands).map(([name, command2]) => {\n          const chainedCommand = (...args) => {\n            const props = this.buildProps(tr, shouldDispatch);\n            const callback = command2(...args)(props);\n            callbacks.push(callback);\n            return chain;\n          };\n          return [name, chainedCommand];\n        })\n      ),\n      run: run3\n    };\n    return chain;\n  }\n  createCan(startTr) {\n    const { rawCommands, state } = this;\n    const dispatch = false;\n    const tr = startTr || state.tr;\n    const props = this.buildProps(tr, dispatch);\n    const formattedCommands = Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command2]) => {\n        return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];\n      })\n    );\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch)\n    };\n  }\n  buildProps(tr, shouldDispatch = true) {\n    const { rawCommands, editor, state } = this;\n    const { view } = editor;\n    const props = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr\n      }),\n      dispatch: shouldDispatch ? () => void 0 : void 0,\n      chain: () => this.createChain(tr, shouldDispatch),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(\n          Object.entries(rawCommands).map(([name, command2]) => {\n            return [name, (...args) => command2(...args)(props)];\n          })\n        );\n      }\n    };\n    return props;\n  }\n};\n\n// src/commands/index.ts\nvar commands_exports = {};\n__export(commands_exports, {\n  blur: () => blur,\n  clearContent: () => clearContent,\n  clearNodes: () => clearNodes,\n  command: () => command,\n  createParagraphNear: () => createParagraphNear,\n  cut: () => cut,\n  deleteCurrentNode: () => deleteCurrentNode,\n  deleteNode: () => deleteNode,\n  deleteRange: () => deleteRange,\n  deleteSelection: () => deleteSelection,\n  enter: () => enter,\n  exitCode: () => exitCode,\n  extendMarkRange: () => extendMarkRange,\n  first: () => first,\n  focus: () => focus,\n  forEach: () => forEach,\n  insertContent: () => insertContent,\n  insertContentAt: () => insertContentAt,\n  joinBackward: () => joinBackward,\n  joinDown: () => joinDown,\n  joinForward: () => joinForward,\n  joinItemBackward: () => joinItemBackward,\n  joinItemForward: () => joinItemForward,\n  joinTextblockBackward: () => joinTextblockBackward,\n  joinTextblockForward: () => joinTextblockForward,\n  joinUp: () => joinUp,\n  keyboardShortcut: () => keyboardShortcut,\n  lift: () => lift,\n  liftEmptyBlock: () => liftEmptyBlock,\n  liftListItem: () => liftListItem,\n  newlineInCode: () => newlineInCode,\n  resetAttributes: () => resetAttributes,\n  scrollIntoView: () => scrollIntoView,\n  selectAll: () => selectAll,\n  selectNodeBackward: () => selectNodeBackward,\n  selectNodeForward: () => selectNodeForward,\n  selectParentNode: () => selectParentNode,\n  selectTextblockEnd: () => selectTextblockEnd,\n  selectTextblockStart: () => selectTextblockStart,\n  setContent: () => setContent,\n  setMark: () => setMark,\n  setMeta: () => setMeta,\n  setNode: () => setNode,\n  setNodeSelection: () => setNodeSelection,\n  setTextDirection: () => setTextDirection,\n  setTextSelection: () => setTextSelection,\n  sinkListItem: () => sinkListItem,\n  splitBlock: () => splitBlock,\n  splitListItem: () => splitListItem,\n  toggleList: () => toggleList,\n  toggleMark: () => toggleMark,\n  toggleNode: () => toggleNode,\n  toggleWrap: () => toggleWrap,\n  undoInputRule: () => undoInputRule,\n  unsetAllMarks: () => unsetAllMarks,\n  unsetMark: () => unsetMark,\n  unsetTextDirection: () => unsetTextDirection,\n  updateAttributes: () => updateAttributes,\n  wrapIn: () => wrapIn,\n  wrapInList: () => wrapInList\n});\n\n// src/commands/blur.ts\nvar blur = () => ({ editor, view }) => {\n  requestAnimationFrame(() => {\n    var _a;\n    if (!editor.isDestroyed) {\n      ;\n      view.dom.blur();\n      (_a = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a.removeAllRanges();\n    }\n  });\n  return true;\n};\n\n// src/commands/clearContent.ts\nvar clearContent = (emitUpdate = true) => ({ commands }) => {\n  return commands.setContent(\"\", { emitUpdate });\n};\n\n// src/commands/clearNodes.ts\n\nvar clearNodes = () => ({ state, tr, dispatch }) => {\n  const { selection } = tr;\n  const { ranges } = selection;\n  if (!dispatch) {\n    return true;\n  }\n  ranges.forEach(({ $from, $to }) => {\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return;\n      }\n      const { doc, mapping } = tr;\n      const $mappedFrom = doc.resolve(mapping.map(pos));\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n      const nodeRange = $mappedFrom.blockRange($mappedTo);\n      if (!nodeRange) {\n        return;\n      }\n      const targetLiftDepth = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(nodeRange);\n      if (node.type.isTextblock) {\n        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n        tr.setNodeMarkup(nodeRange.start, defaultType);\n      }\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth);\n      }\n    });\n  });\n  return true;\n};\n\n// src/commands/command.ts\nvar command = (fn) => (props) => {\n  return fn(props);\n};\n\n// src/commands/createParagraphNear.ts\n\nvar createParagraphNear = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.createParagraphNear)(state, dispatch);\n};\n\n// src/commands/cut.ts\n\nvar cut = (originRange, targetPos) => ({ editor, tr }) => {\n  const { state } = editor;\n  const contentSlice = state.doc.slice(originRange.from, originRange.to);\n  tr.deleteRange(originRange.from, originRange.to);\n  const newPos = tr.mapping.map(targetPos);\n  tr.insert(newPos, contentSlice.content);\n  tr.setSelection(new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection(tr.doc.resolve(Math.max(newPos - 1, 0))));\n  return true;\n};\n\n// src/commands/deleteCurrentNode.ts\nvar deleteCurrentNode = () => ({ tr, dispatch }) => {\n  const { selection } = tr;\n  const currentNode = selection.$anchor.node();\n  if (currentNode.content.size > 0) {\n    return false;\n  }\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === currentNode.type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n// src/helpers/getNodeType.ts\nfunction getNodeType(nameOrType, schema) {\n  if (typeof nameOrType === \"string\") {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.nodes[nameOrType];\n  }\n  return nameOrType;\n}\n\n// src/commands/deleteNode.ts\nvar deleteNode = (typeOrName) => ({ tr, state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n// src/commands/deleteRange.ts\nvar deleteRange = (range) => ({ tr, dispatch }) => {\n  const { from, to } = range;\n  if (dispatch) {\n    tr.delete(from, to);\n  }\n  return true;\n};\n\n// src/commands/deleteSelection.ts\n\nvar deleteSelection = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.deleteSelection)(state, dispatch);\n};\n\n// src/commands/enter.ts\nvar enter = () => ({ commands }) => {\n  return commands.keyboardShortcut(\"Enter\");\n};\n\n// src/commands/exitCode.ts\n\nvar exitCode = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.exitCode)(state, dispatch);\n};\n\n// src/commands/extendMarkRange.ts\n\n\n// src/utilities/isRegExp.ts\nfunction isRegExp(value) {\n  return Object.prototype.toString.call(value) === \"[object RegExp]\";\n}\n\n// src/utilities/objectIncludes.ts\nfunction objectIncludes(object1, object2, options = { strict: true }) {\n  const keys = Object.keys(object2);\n  if (!keys.length) {\n    return true;\n  }\n  return keys.every((key) => {\n    if (options.strict) {\n      return object2[key] === object1[key];\n    }\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key]);\n    }\n    return object2[key] === object1[key];\n  });\n}\n\n// src/helpers/getMarkRange.ts\nfunction findMarkInSet(marks, type, attributes = {}) {\n  return marks.find((item) => {\n    return item.type === type && objectIncludes(\n      // Only check equality for the attributes that are provided\n      Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),\n      attributes\n    );\n  });\n}\nfunction isMarkInSet(marks, type, attributes = {}) {\n  return !!findMarkInSet(marks, type, attributes);\n}\nfunction getMarkRange($pos, type, attributes) {\n  var _a;\n  if (!$pos || !type) {\n    return;\n  }\n  let start = $pos.parent.childAfter($pos.parentOffset);\n  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {\n    start = $pos.parent.childBefore($pos.parentOffset);\n  }\n  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {\n    return;\n  }\n  attributes = attributes || ((_a = start.node.marks[0]) == null ? void 0 : _a.attrs);\n  const mark = findMarkInSet([...start.node.marks], type, attributes);\n  if (!mark) {\n    return;\n  }\n  let startIndex = start.index;\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\n\n// src/helpers/getMarkType.ts\nfunction getMarkType(nameOrType, schema) {\n  if (typeof nameOrType === \"string\") {\n    if (!schema.marks[nameOrType]) {\n      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.marks[nameOrType];\n  }\n  return nameOrType;\n}\n\n// src/commands/extendMarkRange.ts\nvar extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const type = getMarkType(typeOrName, state.schema);\n  const { doc, selection } = tr;\n  const { $from, from, to } = selection;\n  if (dispatch) {\n    const range = getMarkRange($from, type, attributes);\n    if (range && range.from <= from && range.to >= to) {\n      const newSelection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(doc, range.from, range.to);\n      tr.setSelection(newSelection);\n    }\n  }\n  return true;\n};\n\n// src/commands/first.ts\nvar first = (commands) => (props) => {\n  const items = typeof commands === \"function\" ? commands(props) : commands;\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// src/helpers/isTextSelection.ts\n\nfunction isTextSelection(value) {\n  return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection;\n}\n\n// src/helpers/resolveFocusPosition.ts\n\n\n// src/utilities/minMax.ts\nfunction minMax(value = 0, min = 0, max = 0) {\n  return Math.min(Math.max(value, min), max);\n}\n\n// src/helpers/resolveFocusPosition.ts\nfunction resolveFocusPosition(doc, position = null) {\n  if (!position) {\n    return null;\n  }\n  const selectionAtStart = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atStart(doc);\n  const selectionAtEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atEnd(doc);\n  if (position === \"start\" || position === true) {\n    return selectionAtStart;\n  }\n  if (position === \"end\") {\n    return selectionAtEnd;\n  }\n  const minPos = selectionAtStart.from;\n  const maxPos = selectionAtEnd.to;\n  if (position === \"all\") {\n    return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n  }\n  return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\n\n// src/utilities/isAndroid.ts\nfunction isAndroid() {\n  return navigator.platform === \"Android\" || /android/i.test(navigator.userAgent);\n}\n\n// src/utilities/isiOS.ts\nfunction isiOS() {\n  return [\"iPad Simulator\", \"iPhone Simulator\", \"iPod Simulator\", \"iPad\", \"iPhone\", \"iPod\"].includes(navigator.platform) || // iPad on iOS 13 detection\n  navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document;\n}\n\n// src/commands/focus.ts\nvar focus = (position = null, options = {}) => ({ editor, view, tr, dispatch }) => {\n  options = {\n    scrollIntoView: true,\n    ...options\n  };\n  const delayedFocus = () => {\n    if (isiOS() || isAndroid()) {\n      ;\n      view.dom.focus();\n    }\n    requestAnimationFrame(() => {\n      if (!editor.isDestroyed) {\n        view.focus();\n        if (options == null ? void 0 : options.scrollIntoView) {\n          editor.commands.scrollIntoView();\n        }\n      }\n    });\n  };\n  if (view.hasFocus() && position === null || position === false) {\n    return true;\n  }\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    delayedFocus();\n    return true;\n  }\n  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n  const isSameSelection = editor.state.selection.eq(selection);\n  if (dispatch) {\n    if (!isSameSelection) {\n      tr.setSelection(selection);\n    }\n    if (isSameSelection && tr.storedMarks) {\n      tr.setStoredMarks(tr.storedMarks);\n    }\n    delayedFocus();\n  }\n  return true;\n};\n\n// src/commands/forEach.ts\nvar forEach = (items, fn) => (props) => {\n  return items.every((item, index) => fn(item, { ...props, index }));\n};\n\n// src/commands/insertContent.ts\nvar insertContent = (value, options) => ({ tr, commands }) => {\n  return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);\n};\n\n// src/commands/insertContentAt.ts\n\n\n// src/helpers/createNodeFromContent.ts\n\n\n// src/utilities/elementFromString.ts\nvar removeWhitespaces = (node) => {\n  const children = node.childNodes;\n  for (let i = children.length - 1; i >= 0; i -= 1) {\n    const child = children[i];\n    if (child.nodeType === 3 && child.nodeValue && /^(\\n\\s\\s|\\n)$/.test(child.nodeValue)) {\n      node.removeChild(child);\n    } else if (child.nodeType === 1) {\n      removeWhitespaces(child);\n    }\n  }\n  return node;\n};\nfunction elementFromString(value) {\n  if (typeof window === \"undefined\") {\n    throw new Error(\"[tiptap error]: there is no window object available, so this function cannot be used\");\n  }\n  const wrappedValue = `<body>${value}</body>`;\n  const html = new window.DOMParser().parseFromString(wrappedValue, \"text/html\").body;\n  return removeWhitespaces(html);\n}\n\n// src/helpers/createNodeFromContent.ts\nfunction createNodeFromContent(content, schema, options) {\n  if (content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node || content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment) {\n    return content;\n  }\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options\n  };\n  const isJSONContent = typeof content === \"object\" && content !== null;\n  const isTextContent = typeof content === \"string\";\n  if (isJSONContent) {\n    try {\n      const isArrayContent = Array.isArray(content) && content.length > 0;\n      if (isArrayContent) {\n        return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));\n      }\n      const node = schema.nodeFromJSON(content);\n      if (options.errorOnInvalidContent) {\n        node.check();\n      }\n      return node;\n    } catch (error) {\n      if (options.errorOnInvalidContent) {\n        throw new Error(\"[tiptap error]: Invalid JSON content\", { cause: error });\n      }\n      console.warn(\"[tiptap warn]: Invalid content.\", \"Passed value:\", content, \"Error:\", error);\n      return createNodeFromContent(\"\", schema, options);\n    }\n  }\n  if (isTextContent) {\n    if (options.errorOnInvalidContent) {\n      let hasInvalidContent = false;\n      let invalidContent = \"\";\n      const contentCheckSchema = new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n        topNode: schema.spec.topNode,\n        marks: schema.spec.marks,\n        // Prosemirror's schemas are executed such that: the last to execute, matches last\n        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle\n        nodes: schema.spec.nodes.append({\n          __tiptap__private__unknown__catch__all__node: {\n            content: \"inline*\",\n            group: \"block\",\n            parseDOM: [\n              {\n                tag: \"*\",\n                getAttrs: (e) => {\n                  hasInvalidContent = true;\n                  invalidContent = typeof e === \"string\" ? e : e.outerHTML;\n                  return null;\n                }\n              }\n            ]\n          }\n        })\n      });\n      if (options.slice) {\n        _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);\n      } else {\n        _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);\n      }\n      if (options.errorOnInvalidContent && hasInvalidContent) {\n        throw new Error(\"[tiptap error]: Invalid HTML content\", {\n          cause: new Error(`Invalid element found: ${invalidContent}`)\n        });\n      }\n    }\n    const parser = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema);\n    if (options.slice) {\n      return parser.parseSlice(elementFromString(content), options.parseOptions).content;\n    }\n    return parser.parse(elementFromString(content), options.parseOptions);\n  }\n  return createNodeFromContent(\"\", schema, options);\n}\n\n// src/helpers/selectionToInsertionEnd.ts\n\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  const last = tr.steps.length - 1;\n  if (last < startLen) {\n    return;\n  }\n  const step = tr.steps[last];\n  if (!(step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep || step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep)) {\n    return;\n  }\n  const map = tr.mapping.maps[last];\n  let end = 0;\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo;\n    }\n  });\n  tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.near(tr.doc.resolve(end), bias));\n}\n\n// src/commands/insertContentAt.ts\nvar isFragment = (nodeOrFragment) => {\n  return !(\"type\" in nodeOrFragment);\n};\nvar insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {\n  var _a;\n  if (dispatch) {\n    options = {\n      parseOptions: editor.options.parseOptions,\n      updateSelection: true,\n      applyInputRules: false,\n      applyPasteRules: false,\n      ...options\n    };\n    let content;\n    const emitContentError = (error) => {\n      editor.emit(\"contentError\", {\n        editor,\n        error,\n        disableCollaboration: () => {\n          if (\"collaboration\" in editor.storage && typeof editor.storage.collaboration === \"object\" && editor.storage.collaboration) {\n            ;\n            editor.storage.collaboration.isDisabled = true;\n          }\n        }\n      });\n    };\n    const parseOptions = {\n      preserveWhitespace: \"full\",\n      ...options.parseOptions\n    };\n    if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {\n      try {\n        createNodeFromContent(value, editor.schema, {\n          parseOptions,\n          errorOnInvalidContent: true\n        });\n      } catch (e) {\n        emitContentError(e);\n      }\n    }\n    try {\n      content = createNodeFromContent(value, editor.schema, {\n        parseOptions,\n        errorOnInvalidContent: (_a = options.errorOnInvalidContent) != null ? _a : editor.options.enableContentCheck\n      });\n    } catch (e) {\n      emitContentError(e);\n      return false;\n    }\n    let { from, to } = typeof position === \"number\" ? { from: position, to: position } : { from: position.from, to: position.to };\n    let isOnlyTextContent = true;\n    let isOnlyBlockContent = true;\n    const nodes = isFragment(content) ? content : [content];\n    nodes.forEach((node) => {\n      node.check();\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n    });\n    if (from === to && isOnlyBlockContent) {\n      const { parent } = tr.doc.resolve(from);\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n      if (isEmptyTextBlock) {\n        from -= 1;\n        to += 1;\n      }\n    }\n    let newContent;\n    if (isOnlyTextContent) {\n      if (Array.isArray(value)) {\n        newContent = value.map((v) => v.text || \"\").join(\"\");\n      } else if (value instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment) {\n        let text = \"\";\n        value.forEach((node) => {\n          if (node.text) {\n            text += node.text;\n          }\n        });\n        newContent = text;\n      } else if (typeof value === \"object\" && !!value && !!value.text) {\n        newContent = value.text;\n      } else {\n        newContent = value;\n      }\n      tr.insertText(newContent, from, to);\n    } else {\n      newContent = content;\n      const $from = tr.doc.resolve(from);\n      const $fromNode = $from.node();\n      const fromSelectionAtStart = $from.parentOffset === 0;\n      const isTextSelection2 = $fromNode.isText || $fromNode.isTextblock;\n      const hasContent = $fromNode.content.size > 0;\n      if (fromSelectionAtStart && isTextSelection2 && hasContent) {\n        from = Math.max(0, from - 1);\n      }\n      tr.replaceWith(from, to, newContent);\n    }\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n    }\n    if (options.applyInputRules) {\n      tr.setMeta(\"applyInputRules\", { from, text: newContent });\n    }\n    if (options.applyPasteRules) {\n      tr.setMeta(\"applyPasteRules\", { from, text: newContent });\n    }\n  }\n  return true;\n};\n\n// src/commands/join.ts\n\nvar joinUp = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinUp)(state, dispatch);\n};\nvar joinDown = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinDown)(state, dispatch);\n};\nvar joinBackward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinBackward)(state, dispatch);\n};\nvar joinForward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinForward)(state, dispatch);\n};\n\n// src/commands/joinItemBackward.ts\n\nvar joinItemBackward = () => ({ state, dispatch, tr }) => {\n  try {\n    const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, state.selection.$from.pos, -1);\n    if (point === null || point === void 0) {\n      return false;\n    }\n    tr.join(point, 2);\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n// src/commands/joinItemForward.ts\n\nvar joinItemForward = () => ({ state, dispatch, tr }) => {\n  try {\n    const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, state.selection.$from.pos, 1);\n    if (point === null || point === void 0) {\n      return false;\n    }\n    tr.join(point, 2);\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n// src/commands/joinTextblockBackward.ts\n\nvar joinTextblockBackward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinTextblockBackward)(state, dispatch);\n};\n\n// src/commands/joinTextblockForward.ts\n\nvar joinTextblockForward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinTextblockForward)(state, dispatch);\n};\n\n// src/utilities/isMacOS.ts\nfunction isMacOS() {\n  return typeof navigator !== \"undefined\" ? /Mac/.test(navigator.platform) : false;\n}\n\n// src/commands/keyboardShortcut.ts\nfunction normalizeKeyName(name) {\n  const parts = name.split(/-(?!$)/);\n  let result = parts[parts.length - 1];\n  if (result === \"Space\") {\n    result = \" \";\n  }\n  let alt;\n  let ctrl;\n  let shift;\n  let meta;\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`);\n    }\n  }\n  if (alt) {\n    result = `Alt-${result}`;\n  }\n  if (ctrl) {\n    result = `Ctrl-${result}`;\n  }\n  if (meta) {\n    result = `Meta-${result}`;\n  }\n  if (shift) {\n    result = `Shift-${result}`;\n  }\n  return result;\n}\nvar keyboardShortcut = (name) => ({ editor, view, tr, dispatch }) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/);\n  const key = keys.find((item) => ![\"Alt\", \"Ctrl\", \"Meta\", \"Shift\"].includes(item));\n  const event = new KeyboardEvent(\"keydown\", {\n    key: key === \"Space\" ? \" \" : key,\n    altKey: keys.includes(\"Alt\"),\n    ctrlKey: keys.includes(\"Ctrl\"),\n    metaKey: keys.includes(\"Meta\"),\n    shiftKey: keys.includes(\"Shift\"),\n    bubbles: true,\n    cancelable: true\n  });\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp(\"handleKeyDown\", (f) => f(view, event));\n  });\n  capturedTransaction == null ? void 0 : capturedTransaction.steps.forEach((step) => {\n    const newStep = step.map(tr.mapping);\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep);\n    }\n  });\n  return true;\n};\n\n// src/commands/lift.ts\n\n\n// src/helpers/isNodeActive.ts\nfunction isNodeActive(state, typeOrName, attributes = {}) {\n  const { from, to, empty } = state.selection;\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n  const nodeRanges = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return;\n    }\n    const relativeFrom = Math.max(from, pos);\n    const relativeTo = Math.min(to, pos + node.nodeSize);\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo\n    });\n  });\n  const selectionRange = to - from;\n  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {\n    if (!type) {\n      return true;\n    }\n    return type.name === nodeRange.node.type.name;\n  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));\n  if (empty) {\n    return !!matchedNodeRanges.length;\n  }\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\n  return range >= selectionRange;\n}\n\n// src/commands/lift.ts\nvar lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive2 = isNodeActive(state, type, attributes);\n  if (!isActive2) {\n    return false;\n  }\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.lift)(state, dispatch);\n};\n\n// src/commands/liftEmptyBlock.ts\n\nvar liftEmptyBlock = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.liftEmptyBlock)(state, dispatch);\n};\n\n// src/commands/liftListItem.ts\n\nvar liftListItem = (typeOrName) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_4__.liftListItem)(type)(state, dispatch);\n};\n\n// src/commands/newlineInCode.ts\n\nvar newlineInCode = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.newlineInCode)(state, dispatch);\n};\n\n// src/helpers/getSchemaTypeNameByName.ts\nfunction getSchemaTypeNameByName(name, schema) {\n  if (schema.nodes[name]) {\n    return \"node\";\n  }\n  if (schema.marks[name]) {\n    return \"mark\";\n  }\n  return null;\n}\n\n// src/utilities/deleteProps.ts\nfunction deleteProps(obj, propOrProps) {\n  const props = typeof propOrProps === \"string\" ? [propOrProps] : propOrProps;\n  return Object.keys(obj).reduce((newObj, prop) => {\n    if (!props.includes(prop)) {\n      newObj[prop] = obj[prop];\n    }\n    return newObj;\n  }, {});\n}\n\n// src/commands/resetAttributes.ts\nvar resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === \"string\" ? typeOrName : typeOrName.name,\n    state.schema\n  );\n  if (!schemaType) {\n    return false;\n  }\n  if (schemaType === \"node\") {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n  if (schemaType === \"mark\") {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n  let canReset = false;\n  tr.selection.ranges.forEach((range) => {\n    state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n      if (nodeType && nodeType === node.type) {\n        canReset = true;\n        if (dispatch) {\n          tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));\n        }\n      }\n      if (markType && node.marks.length) {\n        node.marks.forEach((mark) => {\n          if (markType === mark.type) {\n            canReset = true;\n            if (dispatch) {\n              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n            }\n          }\n        });\n      }\n    });\n  });\n  return canReset;\n};\n\n// src/commands/scrollIntoView.ts\nvar scrollIntoView = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    tr.scrollIntoView();\n  }\n  return true;\n};\n\n// src/commands/selectAll.ts\n\nvar selectAll = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const selection = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.AllSelection(tr.doc);\n    tr.setSelection(selection);\n  }\n  return true;\n};\n\n// src/commands/selectNodeBackward.ts\n\nvar selectNodeBackward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectNodeBackward)(state, dispatch);\n};\n\n// src/commands/selectNodeForward.ts\n\nvar selectNodeForward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectNodeForward)(state, dispatch);\n};\n\n// src/commands/selectParentNode.ts\n\nvar selectParentNode = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectParentNode)(state, dispatch);\n};\n\n// src/commands/selectTextblockEnd.ts\n\nvar selectTextblockEnd = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectTextblockEnd)(state, dispatch);\n};\n\n// src/commands/selectTextblockStart.ts\n\nvar selectTextblockStart = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectTextblockStart)(state, dispatch);\n};\n\n// src/helpers/createDocument.ts\nfunction createDocument(content, schema, parseOptions = {}, options = {}) {\n  return createNodeFromContent(content, schema, {\n    slice: false,\n    parseOptions,\n    errorOnInvalidContent: options.errorOnInvalidContent\n  });\n}\n\n// src/commands/setContent.ts\nvar setContent = (content, { errorOnInvalidContent, emitUpdate = true, parseOptions = {} } = {}) => ({ editor, tr, dispatch, commands }) => {\n  const { doc } = tr;\n  if (parseOptions.preserveWhitespace !== \"full\") {\n    const document2 = createDocument(content, editor.schema, parseOptions, {\n      errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck\n    });\n    if (dispatch) {\n      tr.replaceWith(0, doc.content.size, document2).setMeta(\"preventUpdate\", !emitUpdate);\n    }\n    return true;\n  }\n  if (dispatch) {\n    tr.setMeta(\"preventUpdate\", !emitUpdate);\n  }\n  return commands.insertContentAt({ from: 0, to: doc.content.size }, content, {\n    parseOptions,\n    errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck\n  });\n};\n\n// src/helpers/getMarkAttributes.ts\nfunction getMarkAttributes(state, typeOrName) {\n  const type = getMarkType(typeOrName, state.schema);\n  const { from, to, empty } = state.selection;\n  const marks = [];\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks);\n    }\n    marks.push(...state.selection.$head.marks());\n  } else {\n    state.doc.nodesBetween(from, to, (node) => {\n      marks.push(...node.marks);\n    });\n  }\n  const mark = marks.find((markItem) => markItem.type.name === type.name);\n  if (!mark) {\n    return {};\n  }\n  return { ...mark.attrs };\n}\n\n// src/helpers/combineTransactionSteps.ts\n\nfunction combineTransactionSteps(oldDoc, transactions) {\n  const transform = new _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.Transform(oldDoc);\n  transactions.forEach((transaction) => {\n    transaction.steps.forEach((step) => {\n      transform.step(step);\n    });\n  });\n  return transform;\n}\n\n// src/helpers/defaultBlockAt.ts\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const { type } = match.edge(i);\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n  return null;\n}\n\n// src/helpers/findChildren.ts\nfunction findChildren(node, predicate) {\n  const nodesWithPos = [];\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\n// src/helpers/findChildrenInRange.ts\nfunction findChildrenInRange(node, range, predicate) {\n  const nodesWithPos = [];\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\n// src/helpers/findParentNodeClosestToPos.ts\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n}\n\n// src/helpers/findParentNode.ts\nfunction findParentNode(predicate) {\n  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);\n}\n\n// src/helpers/getExtensionField.ts\nfunction getExtensionField(extension, field, context) {\n  if (extension.config[field] === void 0 && extension.parent) {\n    return getExtensionField(extension.parent, field, context);\n  }\n  if (typeof extension.config[field] === \"function\") {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n    });\n    return value;\n  }\n  return extension.config[field];\n}\n\n// src/helpers/flattenExtensions.ts\nfunction flattenExtensions(extensions) {\n  return extensions.map((extension) => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addExtensions = getExtensionField(extension, \"addExtensions\", context);\n    if (addExtensions) {\n      return [extension, ...flattenExtensions(addExtensions())];\n    }\n    return extension;\n  }).flat(10);\n}\n\n// src/helpers/generateHTML.ts\n\n\n// src/helpers/getHTMLFromFragment.ts\n\nfunction getHTMLFromFragment(fragment, schema) {\n  const documentFragment = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n  const temporaryDocument = document.implementation.createHTMLDocument();\n  const container = temporaryDocument.createElement(\"div\");\n  container.appendChild(documentFragment);\n  return container.innerHTML;\n}\n\n// src/helpers/getSchemaByResolvedExtensions.ts\n\n\n// src/utilities/isFunction.ts\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n\n// src/utilities/callOrReturn.ts\nfunction callOrReturn(value, context = void 0, ...props) {\n  if (isFunction(value)) {\n    if (context) {\n      return value.bind(context)(...props);\n    }\n    return value(...props);\n  }\n  return value;\n}\n\n// src/utilities/isEmptyObject.ts\nfunction isEmptyObject(value = {}) {\n  return Object.keys(value).length === 0 && value.constructor === Object;\n}\n\n// src/helpers/splitExtensions.ts\nfunction splitExtensions(extensions) {\n  const baseExtensions = extensions.filter((extension) => extension.type === \"extension\");\n  const nodeExtensions = extensions.filter((extension) => extension.type === \"node\");\n  const markExtensions = extensions.filter((extension) => extension.type === \"mark\");\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions\n  };\n}\n\n// src/helpers/getAttributesFromExtensions.ts\nfunction getAttributesFromExtensions(extensions) {\n  const extensionAttributes = [];\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\n  const defaultAttribute = {\n    default: null,\n    validate: void 0,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false\n  };\n  extensions.forEach((extension) => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n      extensions: nodeAndMarkExtensions\n    };\n    const addGlobalAttributes = getExtensionField(\n      extension,\n      \"addGlobalAttributes\",\n      context\n    );\n    if (!addGlobalAttributes) {\n      return;\n    }\n    const globalAttributes = addGlobalAttributes();\n    globalAttributes.forEach((globalAttribute) => {\n      globalAttribute.types.forEach((type) => {\n        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {\n          extensionAttributes.push({\n            type,\n            name,\n            attribute: {\n              ...defaultAttribute,\n              ...attribute\n            }\n          });\n        });\n      });\n    });\n  });\n  nodeAndMarkExtensions.forEach((extension) => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addAttributes = getExtensionField(\n      extension,\n      \"addAttributes\",\n      context\n    );\n    if (!addAttributes) {\n      return;\n    }\n    const attributes = addAttributes();\n    Object.entries(attributes).forEach(([name, attribute]) => {\n      const mergedAttr = {\n        ...defaultAttribute,\n        ...attribute\n      };\n      if (typeof (mergedAttr == null ? void 0 : mergedAttr.default) === \"function\") {\n        mergedAttr.default = mergedAttr.default();\n      }\n      if ((mergedAttr == null ? void 0 : mergedAttr.isRequired) && (mergedAttr == null ? void 0 : mergedAttr.default) === void 0) {\n        delete mergedAttr.default;\n      }\n      extensionAttributes.push({\n        type: extension.name,\n        name,\n        attribute: mergedAttr\n      });\n    });\n  });\n  return extensionAttributes;\n}\n\n// src/utilities/mergeAttributes.ts\nfunction mergeAttributes(...objects) {\n  return objects.filter((item) => !!item).reduce((items, item) => {\n    const mergedAttributes = { ...items };\n    Object.entries(item).forEach(([key, value]) => {\n      const exists = mergedAttributes[key];\n      if (!exists) {\n        mergedAttributes[key] = value;\n        return;\n      }\n      if (key === \"class\") {\n        const valueClasses = value ? String(value).split(\" \") : [];\n        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(\" \") : [];\n        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));\n        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(\" \");\n      } else if (key === \"style\") {\n        const newStyles = value ? value.split(\";\").map((style2) => style2.trim()).filter(Boolean) : [];\n        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(\";\").map((style2) => style2.trim()).filter(Boolean) : [];\n        const styleMap = /* @__PURE__ */ new Map();\n        existingStyles.forEach((style2) => {\n          const [property, val] = style2.split(\":\").map((part) => part.trim());\n          styleMap.set(property, val);\n        });\n        newStyles.forEach((style2) => {\n          const [property, val] = style2.split(\":\").map((part) => part.trim());\n          styleMap.set(property, val);\n        });\n        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join(\"; \");\n      } else {\n        mergedAttributes[key] = value;\n      }\n    });\n    return mergedAttributes;\n  }, {});\n}\n\n// src/helpers/getRenderedAttributes.ts\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {\n    if (!item.attribute.renderHTML) {\n      return {\n        [item.name]: nodeOrMark.attrs[item.name]\n      };\n    }\n    return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\n}\n\n// src/utilities/fromString.ts\nfunction fromString(value) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value);\n  }\n  if (value === \"true\") {\n    return true;\n  }\n  if (value === \"false\") {\n    return false;\n  }\n  return value;\n}\n\n// src/helpers/injectExtensionAttributesToParseRule.ts\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n  if (\"style\" in parseRule) {\n    return parseRule;\n  }\n  return {\n    ...parseRule,\n    getAttrs: (node) => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n      if (oldAttributes === false) {\n        return false;\n      }\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));\n        if (value === null || value === void 0) {\n          return items;\n        }\n        return {\n          ...items,\n          [item.name]: value\n        };\n      }, {});\n      return { ...oldAttributes, ...newAttributes };\n    }\n  };\n}\n\n// src/helpers/getSchemaByResolvedExtensions.ts\nfunction cleanUpSchemaItem(data) {\n  return Object.fromEntries(\n    // @ts-ignore\n    Object.entries(data).filter(([key, value]) => {\n      if (key === \"attrs\" && isEmptyObject(value)) {\n        return false;\n      }\n      return value !== null && value !== void 0;\n    })\n  );\n}\nfunction buildAttributeSpec(extensionAttribute) {\n  var _a, _b;\n  const spec = {};\n  if (!((_a = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a.isRequired) && \"default\" in ((extensionAttribute == null ? void 0 : extensionAttribute.attribute) || {})) {\n    spec.default = extensionAttribute.attribute.default;\n  }\n  if (((_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate) !== void 0) {\n    spec.validate = extensionAttribute.attribute.validate;\n  }\n  return [extensionAttribute.name, spec];\n}\nfunction getSchemaByResolvedExtensions(extensions, editor) {\n  var _a;\n  const allAttributes = getAttributesFromExtensions(extensions);\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, \"topNode\"))) == null ? void 0 : _a.name;\n  const nodes = Object.fromEntries(\n    nodeExtensions.map((extension) => {\n      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor\n      };\n      const extraNodeFields = extensions.reduce((fields, e) => {\n        const extendNodeSchema = getExtensionField(e, \"extendNodeSchema\", context);\n        return {\n          ...fields,\n          ...extendNodeSchema ? extendNodeSchema(extension) : {}\n        };\n      }, {});\n      const schema = cleanUpSchemaItem({\n        ...extraNodeFields,\n        content: callOrReturn(getExtensionField(extension, \"content\", context)),\n        marks: callOrReturn(getExtensionField(extension, \"marks\", context)),\n        group: callOrReturn(getExtensionField(extension, \"group\", context)),\n        inline: callOrReturn(getExtensionField(extension, \"inline\", context)),\n        atom: callOrReturn(getExtensionField(extension, \"atom\", context)),\n        selectable: callOrReturn(getExtensionField(extension, \"selectable\", context)),\n        draggable: callOrReturn(getExtensionField(extension, \"draggable\", context)),\n        code: callOrReturn(getExtensionField(extension, \"code\", context)),\n        whitespace: callOrReturn(getExtensionField(extension, \"whitespace\", context)),\n        linebreakReplacement: callOrReturn(\n          getExtensionField(extension, \"linebreakReplacement\", context)\n        ),\n        defining: callOrReturn(getExtensionField(extension, \"defining\", context)),\n        isolating: callOrReturn(getExtensionField(extension, \"isolating\", context)),\n        attrs: Object.fromEntries(extensionAttributes.map(buildAttributeSpec))\n      });\n      const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(\n          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)\n        );\n      }\n      const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n      if (renderHTML) {\n        schema.toDOM = (node) => renderHTML({\n          node,\n          HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n        });\n      }\n      const renderText = getExtensionField(extension, \"renderText\", context);\n      if (renderText) {\n        schema.toText = renderText;\n      }\n      return [extension.name, schema];\n    })\n  );\n  const marks = Object.fromEntries(\n    markExtensions.map((extension) => {\n      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor\n      };\n      const extraMarkFields = extensions.reduce((fields, e) => {\n        const extendMarkSchema = getExtensionField(e, \"extendMarkSchema\", context);\n        return {\n          ...fields,\n          ...extendMarkSchema ? extendMarkSchema(extension) : {}\n        };\n      }, {});\n      const schema = cleanUpSchemaItem({\n        ...extraMarkFields,\n        inclusive: callOrReturn(getExtensionField(extension, \"inclusive\", context)),\n        excludes: callOrReturn(getExtensionField(extension, \"excludes\", context)),\n        group: callOrReturn(getExtensionField(extension, \"group\", context)),\n        spanning: callOrReturn(getExtensionField(extension, \"spanning\", context)),\n        code: callOrReturn(getExtensionField(extension, \"code\", context)),\n        attrs: Object.fromEntries(extensionAttributes.map(buildAttributeSpec))\n      });\n      const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(\n          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)\n        );\n      }\n      const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n      if (renderHTML) {\n        schema.toDOM = (mark) => renderHTML({\n          mark,\n          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n        });\n      }\n      return [extension.name, schema];\n    })\n  );\n  return new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n    topNode,\n    nodes,\n    marks\n  });\n}\n\n// src/utilities/findDuplicates.ts\nfunction findDuplicates(items) {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index);\n  return Array.from(new Set(filtered));\n}\n\n// src/helpers/sortExtensions.ts\nfunction sortExtensions(extensions) {\n  const defaultPriority = 100;\n  return extensions.sort((a, b) => {\n    const priorityA = getExtensionField(a, \"priority\") || defaultPriority;\n    const priorityB = getExtensionField(b, \"priority\") || defaultPriority;\n    if (priorityA > priorityB) {\n      return -1;\n    }\n    if (priorityA < priorityB) {\n      return 1;\n    }\n    return 0;\n  });\n}\n\n// src/helpers/resolveExtensions.ts\nfunction resolveExtensions(extensions) {\n  const resolvedExtensions = sortExtensions(flattenExtensions(extensions));\n  const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));\n  if (duplicatedNames.length) {\n    console.warn(\n      `[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(\", \")}]. This can lead to issues.`\n    );\n  }\n  return resolvedExtensions;\n}\n\n// src/helpers/getSchema.ts\nfunction getSchema(extensions, editor) {\n  const resolvedExtensions = resolveExtensions(extensions);\n  return getSchemaByResolvedExtensions(resolvedExtensions, editor);\n}\n\n// src/helpers/generateHTML.ts\nfunction generateHTML(doc, extensions) {\n  const schema = getSchema(extensions);\n  const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n  return getHTMLFromFragment(contentNode.content, schema);\n}\n\n// src/helpers/generateJSON.ts\n\nfunction generateJSON(html, extensions) {\n  const schema = getSchema(extensions);\n  const dom = elementFromString(html);\n  return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\n\n// src/helpers/generateText.ts\n\n\n// src/helpers/getTextBetween.ts\nfunction getTextBetween(startNode, range, options) {\n  const { from, to } = range;\n  const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n  let text = \"\";\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    var _a;\n    if (node.isBlock && pos > from) {\n      text += blockSeparator;\n    }\n    const textSerializer = textSerializers == null ? void 0 : textSerializers[node.type.name];\n    if (textSerializer) {\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range\n        });\n      }\n      return false;\n    }\n    if (node.isText) {\n      text += (_a = node == null ? void 0 : node.text) == null ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);\n    }\n  });\n  return text;\n}\n\n// src/helpers/getText.ts\nfunction getText(node, options) {\n  const range = {\n    from: 0,\n    to: node.content.size\n  };\n  return getTextBetween(node, range, options);\n}\n\n// src/helpers/getTextSerializersFromSchema.ts\nfunction getTextSerializersFromSchema(schema) {\n  return Object.fromEntries(\n    Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText])\n  );\n}\n\n// src/helpers/generateText.ts\nfunction generateText(doc, extensions, options) {\n  const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n  const schema = getSchema(extensions);\n  const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...getTextSerializersFromSchema(schema),\n      ...textSerializers\n    }\n  });\n}\n\n// src/helpers/getNodeAttributes.ts\nfunction getNodeAttributes(state, typeOrName) {\n  const type = getNodeType(typeOrName, state.schema);\n  const { from, to } = state.selection;\n  const nodes = [];\n  state.doc.nodesBetween(from, to, (node2) => {\n    nodes.push(node2);\n  });\n  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);\n  if (!node) {\n    return {};\n  }\n  return { ...node.attrs };\n}\n\n// src/helpers/getAttributes.ts\nfunction getAttributes(state, typeOrName) {\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === \"string\" ? typeOrName : typeOrName.name,\n    state.schema\n  );\n  if (schemaType === \"node\") {\n    return getNodeAttributes(state, typeOrName);\n  }\n  if (schemaType === \"mark\") {\n    return getMarkAttributes(state, typeOrName);\n  }\n  return {};\n}\n\n// src/utilities/removeDuplicates.ts\nfunction removeDuplicates(array, by = JSON.stringify) {\n  const seen = {};\n  return array.filter((item) => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;\n  });\n}\n\n// src/helpers/getChangedRanges.ts\nfunction simplifyChangedRanges(changes) {\n  const uniqueChanges = removeDuplicates(changes);\n  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {\n    const rest = uniqueChanges.filter((_, i) => i !== index);\n    return !rest.some((otherChange) => {\n      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;\n    });\n  });\n}\nfunction getChangedRanges(transform) {\n  const { mapping, steps } = transform;\n  const changes = [];\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges = [];\n    if (!stepMap.ranges.length) {\n      const { from, to } = steps[index];\n      if (from === void 0 || to === void 0) {\n        return;\n      }\n      ranges.push({ from, to });\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({ from, to });\n      });\n    }\n    ranges.forEach(({ from, to }) => {\n      const newStart = mapping.slice(index).map(from, -1);\n      const newEnd = mapping.slice(index).map(to);\n      const oldStart = mapping.invert().map(newStart, -1);\n      const oldEnd = mapping.invert().map(newEnd);\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd\n        }\n      });\n    });\n  });\n  return simplifyChangedRanges(changes);\n}\n\n// src/helpers/getDebugJSON.ts\nfunction getDebugJSON(node, startOffset = 0) {\n  const isTopNode = node.type === node.type.schema.topNodeType;\n  const increment = isTopNode ? 0 : 1;\n  const from = startOffset;\n  const to = from + node.nodeSize;\n  const marks = node.marks.map((mark) => {\n    const output2 = {\n      type: mark.type.name\n    };\n    if (Object.keys(mark.attrs).length) {\n      output2.attrs = { ...mark.attrs };\n    }\n    return output2;\n  });\n  const attrs = { ...node.attrs };\n  const output = {\n    type: node.type.name,\n    from,\n    to\n  };\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs;\n  }\n  if (marks.length) {\n    output.marks = marks;\n  }\n  if (node.content.childCount) {\n    output.content = [];\n    node.forEach((child, offset) => {\n      var _a;\n      (_a = output.content) == null ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n    });\n  }\n  if (node.text) {\n    output.text = node.text;\n  }\n  return output;\n}\n\n// src/helpers/getMarksBetween.ts\nfunction getMarksBetween(from, to, doc) {\n  const marks = [];\n  if (from === to) {\n    doc.resolve(from).marks().forEach((mark) => {\n      const $pos = doc.resolve(from);\n      const range = getMarkRange($pos, mark.type);\n      if (!range) {\n        return;\n      }\n      marks.push({\n        mark,\n        ...range\n      });\n    });\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      if (!node || (node == null ? void 0 : node.nodeSize) === void 0) {\n        return;\n      }\n      marks.push(\n        ...node.marks.map((mark) => ({\n          from: pos,\n          to: pos + node.nodeSize,\n          mark\n        }))\n      );\n    });\n  }\n  return marks;\n}\n\n// src/helpers/getNodeAtPosition.ts\nvar getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20) => {\n  const $pos = state.doc.resolve(pos);\n  let currentDepth = maxDepth;\n  let node = null;\n  while (currentDepth > 0 && node === null) {\n    const currentNode = $pos.node(currentDepth);\n    if ((currentNode == null ? void 0 : currentNode.type.name) === typeOrName) {\n      node = currentNode;\n    } else {\n      currentDepth -= 1;\n    }\n  }\n  return [node, currentDepth];\n};\n\n// src/helpers/getSchemaTypeByName.ts\nfunction getSchemaTypeByName(name, schema) {\n  return schema.nodes[name] || schema.marks[name] || null;\n}\n\n// src/helpers/getSplittedAttributes.ts\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n  return Object.fromEntries(\n    Object.entries(attributes).filter(([name]) => {\n      const extensionAttribute = extensionAttributes.find((item) => {\n        return item.type === typeName && item.name === name;\n      });\n      if (!extensionAttribute) {\n        return false;\n      }\n      return extensionAttribute.attribute.keepOnSplit;\n    })\n  );\n}\n\n// src/helpers/getTextContentFromNodes.ts\nvar getTextContentFromNodes = ($from, maxMatch = 500) => {\n  let textBefore = \"\";\n  const sliceEndPos = $from.parentOffset;\n  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {\n    var _a, _b;\n    const chunk = ((_b = (_a = node.type.spec).toText) == null ? void 0 : _b.call(_a, {\n      node,\n      pos,\n      parent,\n      index\n    })) || node.textContent || \"%leaf%\";\n    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));\n  });\n  return textBefore;\n};\n\n// src/helpers/isMarkActive.ts\nfunction isMarkActive(state, typeOrName, attributes = {}) {\n  const { empty, ranges } = state.selection;\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {\n      if (!type) {\n        return true;\n      }\n      return type.name === mark.type.name;\n    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));\n  }\n  let selectionRange = 0;\n  const markRanges = [];\n  ranges.forEach(({ $from, $to }) => {\n    const from = $from.pos;\n    const to = $to.pos;\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return;\n      }\n      const relativeFrom = Math.max(from, pos);\n      const relativeTo = Math.min(to, pos + node.nodeSize);\n      const range2 = relativeTo - relativeFrom;\n      selectionRange += range2;\n      markRanges.push(\n        ...node.marks.map((mark) => ({\n          mark,\n          from: relativeFrom,\n          to: relativeTo\n        }))\n      );\n    });\n  });\n  if (selectionRange === 0) {\n    return false;\n  }\n  const matchedRange = markRanges.filter((markRange) => {\n    if (!type) {\n      return true;\n    }\n    return type.name === markRange.mark.type.name;\n  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  const excludedRange = markRanges.filter((markRange) => {\n    if (!type) {\n      return true;\n    }\n    return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n  return range >= selectionRange;\n}\n\n// src/helpers/isActive.ts\nfunction isActive(state, name, attributes = {}) {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n  }\n  const schemaType = getSchemaTypeNameByName(name, state.schema);\n  if (schemaType === \"node\") {\n    return isNodeActive(state, name, attributes);\n  }\n  if (schemaType === \"mark\") {\n    return isMarkActive(state, name, attributes);\n  }\n  return false;\n}\n\n// src/helpers/isAtEndOfNode.ts\nvar isAtEndOfNode = (state, nodeType) => {\n  const { $from, $to, $anchor } = state.selection;\n  if (nodeType) {\n    const parentNode = findParentNode((node) => node.type.name === nodeType)(state.selection);\n    if (!parentNode) {\n      return false;\n    }\n    const $parentPos = state.doc.resolve(parentNode.pos + 1);\n    if ($anchor.pos + 1 === $parentPos.end()) {\n      return true;\n    }\n    return false;\n  }\n  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n    return false;\n  }\n  return true;\n};\n\n// src/helpers/isAtStartOfNode.ts\nvar isAtStartOfNode = (state) => {\n  const { $from, $to } = state.selection;\n  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n    return false;\n  }\n  return true;\n};\n\n// src/helpers/isExtensionRulesEnabled.ts\nfunction isExtensionRulesEnabled(extension, enabled) {\n  if (Array.isArray(enabled)) {\n    return enabled.some((enabledExtension) => {\n      const name = typeof enabledExtension === \"string\" ? enabledExtension : enabledExtension.name;\n      return name === extension.name;\n    });\n  }\n  return enabled;\n}\n\n// src/helpers/isList.ts\nfunction isList(name, extensions) {\n  const { nodeExtensions } = splitExtensions(extensions);\n  const extension = nodeExtensions.find((item) => item.name === name);\n  if (!extension) {\n    return false;\n  }\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage\n  };\n  const group = callOrReturn(getExtensionField(extension, \"group\", context));\n  if (typeof group !== \"string\") {\n    return false;\n  }\n  return group.split(\" \").includes(\"list\");\n}\n\n// src/helpers/isNodeEmpty.ts\nfunction isNodeEmpty(node, {\n  checkChildren = true,\n  ignoreWhitespace = false\n} = {}) {\n  var _a;\n  if (ignoreWhitespace) {\n    if (node.type.name === \"hardBreak\") {\n      return true;\n    }\n    if (node.isText) {\n      return /^\\s*$/m.test((_a = node.text) != null ? _a : \"\");\n    }\n  }\n  if (node.isText) {\n    return !node.text;\n  }\n  if (node.isAtom || node.isLeaf) {\n    return false;\n  }\n  if (node.content.childCount === 0) {\n    return true;\n  }\n  if (checkChildren) {\n    let isContentEmpty = true;\n    node.content.forEach((childNode) => {\n      if (isContentEmpty === false) {\n        return;\n      }\n      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {\n        isContentEmpty = false;\n      }\n    });\n    return isContentEmpty;\n  }\n  return false;\n}\n\n// src/helpers/isNodeSelection.ts\n\nfunction isNodeSelection(value) {\n  return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection;\n}\n\n// src/helpers/MappablePosition.ts\nvar MappablePosition = class _MappablePosition {\n  constructor(position) {\n    this.position = position;\n  }\n  /**\n   * Creates a MappablePosition from a JSON object.\n   */\n  static fromJSON(json) {\n    return new _MappablePosition(json.position);\n  }\n  /**\n   * Converts the MappablePosition to a JSON object.\n   */\n  toJSON() {\n    return {\n      position: this.position\n    };\n  }\n};\nfunction getUpdatedPosition(position, transaction) {\n  const mapResult = transaction.mapping.mapResult(position.position);\n  return {\n    position: new MappablePosition(mapResult.pos),\n    mapResult\n  };\n}\nfunction createMappablePosition(position) {\n  return new MappablePosition(position);\n}\n\n// src/helpers/posToDOMRect.ts\nfunction posToDOMRect(view, from, to) {\n  const minPos = 0;\n  const maxPos = view.state.doc.content.size;\n  const resolvedFrom = minMax(from, minPos, maxPos);\n  const resolvedEnd = minMax(to, minPos, maxPos);\n  const start = view.coordsAtPos(resolvedFrom);\n  const end = view.coordsAtPos(resolvedEnd, -1);\n  const top = Math.min(start.top, end.top);\n  const bottom = Math.max(start.bottom, end.bottom);\n  const left = Math.min(start.left, end.left);\n  const right = Math.max(start.right, end.right);\n  const width = right - left;\n  const height = bottom - top;\n  const x = left;\n  const y = top;\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y\n  };\n  return {\n    ...data,\n    toJSON: () => data\n  };\n}\n\n// src/helpers/rewriteUnknownContent.ts\nfunction rewriteUnknownContentInner({\n  json,\n  validMarks,\n  validNodes,\n  options,\n  rewrittenContent = []\n}) {\n  if (json.marks && Array.isArray(json.marks)) {\n    json.marks = json.marks.filter((mark) => {\n      const name = typeof mark === \"string\" ? mark : mark.type;\n      if (validMarks.has(name)) {\n        return true;\n      }\n      rewrittenContent.push({\n        original: JSON.parse(JSON.stringify(mark)),\n        unsupported: name\n      });\n      return false;\n    });\n  }\n  if (json.content && Array.isArray(json.content)) {\n    json.content = json.content.map(\n      (value) => rewriteUnknownContentInner({\n        json: value,\n        validMarks,\n        validNodes,\n        options,\n        rewrittenContent\n      }).json\n    ).filter((a) => a !== null && a !== void 0);\n  }\n  if (json.type && !validNodes.has(json.type)) {\n    rewrittenContent.push({\n      original: JSON.parse(JSON.stringify(json)),\n      unsupported: json.type\n    });\n    if (json.content && Array.isArray(json.content) && (options == null ? void 0 : options.fallbackToParagraph) !== false) {\n      json.type = \"paragraph\";\n      return {\n        json,\n        rewrittenContent\n      };\n    }\n    return {\n      json: null,\n      rewrittenContent\n    };\n  }\n  return { json, rewrittenContent };\n}\nfunction rewriteUnknownContent(json, schema, options) {\n  return rewriteUnknownContentInner({\n    json,\n    validNodes: new Set(Object.keys(schema.nodes)),\n    validMarks: new Set(Object.keys(schema.marks)),\n    options\n  });\n}\n\n// src/commands/setMark.ts\nfunction canSetMark(state, tr, newMarkType) {\n  var _a;\n  const { selection } = tr;\n  let cursor = null;\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor;\n  }\n  if (cursor) {\n    const currentMarks = (_a = state.storedMarks) != null ? _a : cursor.marks();\n    const parentAllowsMarkType = cursor.parent.type.allowsMarkType(newMarkType);\n    return parentAllowsMarkType && (!!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType)));\n  }\n  const { ranges } = selection;\n  return ranges.some(({ $from, $to }) => {\n    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      if (someNodeSupportsMark) {\n        return false;\n      }\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n      }\n      return !someNodeSupportsMark;\n    });\n    return someNodeSupportsMark;\n  });\n}\nvar setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const { selection } = tr;\n  const { empty, ranges } = selection;\n  const type = getMarkType(typeOrName, state.schema);\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type);\n      tr.addStoredMark(\n        type.create({\n          ...oldAttributes,\n          ...attributes\n        })\n      );\n    } else {\n      ranges.forEach((range) => {\n        const from = range.$from.pos;\n        const to = range.$to.pos;\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from);\n          const trimmedTo = Math.min(pos + node.nodeSize, to);\n          const someHasMark = node.marks.find((mark) => mark.type === type);\n          if (someHasMark) {\n            node.marks.forEach((mark) => {\n              if (type === mark.type) {\n                tr.addMark(\n                  trimmedFrom,\n                  trimmedTo,\n                  type.create({\n                    ...mark.attrs,\n                    ...attributes\n                  })\n                );\n              }\n            });\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n          }\n        });\n      });\n    }\n  }\n  return canSetMark(state, tr, type);\n};\n\n// src/commands/setMeta.ts\nvar setMeta = (key, value) => ({ tr }) => {\n  tr.setMeta(key, value);\n  return true;\n};\n\n// src/commands/setNode.ts\n\nvar setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  let attributesToCopy;\n  if (state.selection.$anchor.sameParent(state.selection.$head)) {\n    attributesToCopy = state.selection.$anchor.parent.attrs;\n  }\n  if (!type.isTextblock) {\n    console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n    return false;\n  }\n  return chain().command(({ commands }) => {\n    const canSetBlock = (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.setBlockType)(type, { ...attributesToCopy, ...attributes })(state);\n    if (canSetBlock) {\n      return true;\n    }\n    return commands.clearNodes();\n  }).command(({ state: updatedState }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.setBlockType)(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);\n  }).run();\n};\n\n// src/commands/setNodeSelection.ts\n\nvar setNodeSelection = (position) => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr;\n    const from = minMax(position, 0, doc.content.size);\n    const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(doc, from);\n    tr.setSelection(selection);\n  }\n  return true;\n};\n\n// src/commands/setTextDirection.ts\nvar setTextDirection = (direction, position) => ({ tr, state, dispatch }) => {\n  const { selection } = state;\n  let from;\n  let to;\n  if (typeof position === \"number\") {\n    from = position;\n    to = position;\n  } else if (position && \"from\" in position && \"to\" in position) {\n    from = position.from;\n    to = position.to;\n  } else {\n    from = selection.from;\n    to = selection.to;\n  }\n  if (dispatch) {\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n      if (node.isText) {\n        return;\n      }\n      tr.setNodeMarkup(pos, void 0, {\n        ...node.attrs,\n        dir: direction\n      });\n    });\n  }\n  return true;\n};\n\n// src/commands/setTextSelection.ts\n\nvar setTextSelection = (position) => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr;\n    const { from, to } = typeof position === \"number\" ? { from: position, to: position } : position;\n    const minPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.atStart(doc).from;\n    const maxPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.atEnd(doc).to;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(doc, resolvedFrom, resolvedEnd);\n    tr.setSelection(selection);\n  }\n  return true;\n};\n\n// src/commands/sinkListItem.ts\n\nvar sinkListItem = (typeOrName) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_4__.sinkListItem)(type)(state, dispatch);\n};\n\n// src/commands/splitBlock.ts\n\n\nfunction ensureMarks(state, splittableMarks) {\n  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n  if (marks) {\n    const filteredMarks = marks.filter((mark) => splittableMarks == null ? void 0 : splittableMarks.includes(mark.type.name));\n    state.tr.ensureMarks(filteredMarks);\n  }\n}\nvar splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor }) => {\n  const { selection, doc } = tr;\n  const { $from, $to } = selection;\n  const extensionAttributes = editor.extensionManager.attributes;\n  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n  if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(doc, $from.pos)) {\n      return false;\n    }\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks);\n      }\n      tr.split($from.pos).scrollIntoView();\n    }\n    return true;\n  }\n  if (!$from.parent.isBlock) {\n    return false;\n  }\n  const atEnd = $to.parentOffset === $to.parent.content.size;\n  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n  let types = atEnd && deflt ? [\n    {\n      type: deflt,\n      attrs: newAttributes\n    }\n  ] : void 0;\n  let can = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n  if (!types && !can && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {\n    can = true;\n    types = deflt ? [\n      {\n        type: deflt,\n        attrs: newAttributes\n      }\n    ] : void 0;\n  }\n  if (dispatch) {\n    if (can) {\n      if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection) {\n        tr.deleteSelection();\n      }\n      tr.split(tr.mapping.map($from.pos), 1, types);\n      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n        const first2 = tr.mapping.map($from.before());\n        const $first = tr.doc.resolve(first2);\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n        }\n      }\n    }\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks);\n    }\n    tr.scrollIntoView();\n  }\n  return can;\n};\n\n// src/commands/splitListItem.ts\n\n\n\nvar splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr, state, dispatch, editor }) => {\n  var _a;\n  const type = getNodeType(typeOrName, state.schema);\n  const { $from, $to } = state.selection;\n  const node = state.selection.node;\n  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n    return false;\n  }\n  const grandParent = $from.node(-1);\n  if (grandParent.type !== type) {\n    return false;\n  }\n  const extensionAttributes = editor.extensionManager.attributes;\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n      return false;\n    }\n    if (dispatch) {\n      let wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.empty;\n      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from($from.node(d).copy(wrap));\n      }\n      const depthAfter = (\n        // eslint-disable-next-line no-nested-ternary\n        $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3\n      );\n      const newNextTypeAttributes2 = {\n        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n        ...overrideAttrs\n      };\n      const nextType2 = ((_a = type.contentMatch.defaultType) == null ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;\n      wrap = wrap.append(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(type.createAndFill(null, nextType2) || void 0));\n      const start = $from.before($from.depth - (depthBefore - 1));\n      tr.replace(start, $from.after(-depthAfter), new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Slice(wrap, 4 - depthBefore, 0));\n      let sel = -1;\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false;\n        }\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1;\n        }\n      });\n      if (sel > -1) {\n        tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.near(tr.doc.resolve(sel)));\n      }\n      tr.scrollIntoView();\n    }\n    return true;\n  }\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n  const newTypeAttributes = {\n    ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),\n    ...overrideAttrs\n  };\n  const newNextTypeAttributes = {\n    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n    ...overrideAttrs\n  };\n  tr.delete($from.pos, $to.pos);\n  const types = nextType ? [\n    { type, attrs: newTypeAttributes },\n    { type: nextType, attrs: newNextTypeAttributes }\n  ] : [{ type, attrs: newTypeAttributes }];\n  if (!(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, $from.pos, 2)) {\n    return false;\n  }\n  if (dispatch) {\n    const { selection, storedMarks } = state;\n    const { splittableMarks } = editor.extensionManager;\n    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n    tr.split($from.pos, 2, types).scrollIntoView();\n    if (!marks || !dispatch) {\n      return true;\n    }\n    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));\n    tr.ensureMarks(filteredMarks);\n  }\n  return true;\n};\n\n// src/commands/toggleList.ts\n\nvar joinListBackwards = (tr, listType) => {\n  const list = findParentNode((node) => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n  if (before === void 0) {\n    return true;\n  }\n  const nodeBefore = tr.doc.nodeAt(before);\n  const canJoinBackwards = list.node.type === (nodeBefore == null ? void 0 : nodeBefore.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, list.pos);\n  if (!canJoinBackwards) {\n    return true;\n  }\n  tr.join(list.pos);\n  return true;\n};\nvar joinListForwards = (tr, listType) => {\n  const list = findParentNode((node) => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const after = tr.doc.resolve(list.start).after(list.depth);\n  if (after === void 0) {\n    return true;\n  }\n  const nodeAfter = tr.doc.nodeAt(after);\n  const canJoinForwards = list.node.type === (nodeAfter == null ? void 0 : nodeAfter.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, after);\n  if (!canJoinForwards) {\n    return true;\n  }\n  tr.join(after);\n  return true;\n};\nvar toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state, dispatch, chain, commands, can }) => {\n  const { extensions, splittableMarks } = editor.extensionManager;\n  const listType = getNodeType(listTypeOrName, state.schema);\n  const itemType = getNodeType(itemTypeOrName, state.schema);\n  const { selection, storedMarks } = state;\n  const { $from, $to } = selection;\n  const range = $from.blockRange($to);\n  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n  if (!range) {\n    return false;\n  }\n  const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType);\n    }\n    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n      return chain().command(() => {\n        tr.setNodeMarkup(parentList.pos, listType);\n        return true;\n      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n    }\n  }\n  if (!keepMarks || !marks || !dispatch) {\n    return chain().command(() => {\n      const canWrapInList = can().wrapInList(listType, attributes);\n      if (canWrapInList) {\n        return true;\n      }\n      return commands.clearNodes();\n    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n  }\n  return chain().command(() => {\n    const canWrapInList = can().wrapInList(listType, attributes);\n    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));\n    tr.ensureMarks(filteredMarks);\n    if (canWrapInList) {\n      return true;\n    }\n    return commands.clearNodes();\n  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n};\n\n// src/commands/toggleMark.ts\nvar toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {\n  const { extendEmptyMarkRange = false } = options;\n  const type = getMarkType(typeOrName, state.schema);\n  const isActive2 = isMarkActive(state, type, attributes);\n  if (isActive2) {\n    return commands.unsetMark(type, { extendEmptyMarkRange });\n  }\n  return commands.setMark(type, attributes);\n};\n\n// src/commands/toggleNode.ts\nvar toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const toggleType = getNodeType(toggleTypeOrName, state.schema);\n  const isActive2 = isNodeActive(state, type, attributes);\n  let attributesToCopy;\n  if (state.selection.$anchor.sameParent(state.selection.$head)) {\n    attributesToCopy = state.selection.$anchor.parent.attrs;\n  }\n  if (isActive2) {\n    return commands.setNode(toggleType, attributesToCopy);\n  }\n  return commands.setNode(type, { ...attributesToCopy, ...attributes });\n};\n\n// src/commands/toggleWrap.ts\nvar toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive2 = isNodeActive(state, type, attributes);\n  if (isActive2) {\n    return commands.lift(type);\n  }\n  return commands.wrapIn(type, attributes);\n};\n\n// src/commands/undoInputRule.ts\nvar undoInputRule = () => ({ state, dispatch }) => {\n  const plugins = state.plugins;\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i];\n    let undoable;\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr;\n        const toUndo = undoable.transform;\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        }\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n// src/commands/unsetAllMarks.ts\nvar unsetAllMarks = () => ({ tr, dispatch }) => {\n  const { selection } = tr;\n  const { empty, ranges } = selection;\n  if (empty) {\n    return true;\n  }\n  if (dispatch) {\n    ranges.forEach((range) => {\n      tr.removeMark(range.$from.pos, range.$to.pos);\n    });\n  }\n  return true;\n};\n\n// src/commands/unsetMark.ts\nvar unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\n  var _a;\n  const { extendEmptyMarkRange = false } = options;\n  const { selection } = tr;\n  const type = getMarkType(typeOrName, state.schema);\n  const { $from, empty, ranges } = selection;\n  if (!dispatch) {\n    return true;\n  }\n  if (empty && extendEmptyMarkRange) {\n    let { from, to } = selection;\n    const attrs = (_a = $from.marks().find((mark) => mark.type === type)) == null ? void 0 : _a.attrs;\n    const range = getMarkRange($from, type, attrs);\n    if (range) {\n      from = range.from;\n      to = range.to;\n    }\n    tr.removeMark(from, to, type);\n  } else {\n    ranges.forEach((range) => {\n      tr.removeMark(range.$from.pos, range.$to.pos, type);\n    });\n  }\n  tr.removeStoredMark(type);\n  return true;\n};\n\n// src/commands/unsetTextDirection.ts\nvar unsetTextDirection = (position) => ({ tr, state, dispatch }) => {\n  const { selection } = state;\n  let from;\n  let to;\n  if (typeof position === \"number\") {\n    from = position;\n    to = position;\n  } else if (position && \"from\" in position && \"to\" in position) {\n    from = position.from;\n    to = position.to;\n  } else {\n    from = selection.from;\n    to = selection.to;\n  }\n  if (dispatch) {\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n      if (node.isText) {\n        return;\n      }\n      const newAttrs = { ...node.attrs };\n      delete newAttrs.dir;\n      tr.setNodeMarkup(pos, void 0, newAttrs);\n    });\n  }\n  return true;\n};\n\n// src/commands/updateAttributes.ts\nvar updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === \"string\" ? typeOrName : typeOrName.name,\n    state.schema\n  );\n  if (!schemaType) {\n    return false;\n  }\n  if (schemaType === \"node\") {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n  if (schemaType === \"mark\") {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n  let canUpdate = false;\n  tr.selection.ranges.forEach((range) => {\n    const from = range.$from.pos;\n    const to = range.$to.pos;\n    let lastPos;\n    let lastNode;\n    let trimmedFrom;\n    let trimmedTo;\n    if (tr.selection.empty) {\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          canUpdate = true;\n          trimmedFrom = Math.max(pos, from);\n          trimmedTo = Math.min(pos + node.nodeSize, to);\n          lastPos = pos;\n          lastNode = node;\n        }\n      });\n    } else {\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (pos < from && nodeType && nodeType === node.type) {\n          canUpdate = true;\n          trimmedFrom = Math.max(pos, from);\n          trimmedTo = Math.min(pos + node.nodeSize, to);\n          lastPos = pos;\n          lastNode = node;\n        }\n        if (pos >= from && pos <= to) {\n          if (nodeType && nodeType === node.type) {\n            canUpdate = true;\n            if (dispatch) {\n              tr.setNodeMarkup(pos, void 0, {\n                ...node.attrs,\n                ...attributes\n              });\n            }\n          }\n          if (markType && node.marks.length) {\n            node.marks.forEach((mark) => {\n              if (markType === mark.type) {\n                canUpdate = true;\n                if (dispatch) {\n                  const trimmedFrom2 = Math.max(pos, from);\n                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);\n                  tr.addMark(\n                    trimmedFrom2,\n                    trimmedTo2,\n                    markType.create({\n                      ...mark.attrs,\n                      ...attributes\n                    })\n                  );\n                }\n              }\n            });\n          }\n        }\n      });\n    }\n    if (lastNode) {\n      if (lastPos !== void 0 && dispatch) {\n        tr.setNodeMarkup(lastPos, void 0, {\n          ...lastNode.attrs,\n          ...attributes\n        });\n      }\n      if (markType && lastNode.marks.length) {\n        lastNode.marks.forEach((mark) => {\n          if (markType === mark.type && dispatch) {\n            tr.addMark(\n              trimmedFrom,\n              trimmedTo,\n              markType.create({\n                ...mark.attrs,\n                ...attributes\n              })\n            );\n          }\n        });\n      }\n    }\n  });\n  return canUpdate;\n};\n\n// src/commands/wrapIn.ts\n\nvar wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.wrapIn)(type, attributes)(state, dispatch);\n};\n\n// src/commands/wrapInList.ts\n\nvar wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_4__.wrapInList)(type, attributes)(state, dispatch);\n};\n\n// src/Editor.ts\n\n\n\n// src/EventEmitter.ts\nvar EventEmitter = class {\n  constructor() {\n    this.callbacks = {};\n  }\n  on(event, fn) {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [];\n    }\n    this.callbacks[event].push(fn);\n    return this;\n  }\n  emit(event, ...args) {\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      callbacks.forEach((callback) => callback.apply(this, args));\n    }\n    return this;\n  }\n  off(event, fn) {\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);\n      } else {\n        delete this.callbacks[event];\n      }\n    }\n    return this;\n  }\n  once(event, fn) {\n    const onceFn = (...args) => {\n      this.off(event, onceFn);\n      fn.apply(this, args);\n    };\n    return this.on(event, onceFn);\n  }\n  removeAllListeners() {\n    this.callbacks = {};\n  }\n};\n\n// src/ExtensionManager.ts\n\n\n// src/InputRule.ts\n\n\nvar InputRule = class {\n  constructor(config) {\n    var _a;\n    this.find = config.find;\n    this.handler = config.handler;\n    this.undoable = (_a = config.undoable) != null ? _a : true;\n  }\n};\nvar inputRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return find.exec(text);\n  }\n  const inputRuleMatch = find(text);\n  if (!inputRuleMatch) {\n    return null;\n  }\n  const result = [inputRuleMatch.text];\n  result.index = inputRuleMatch.index;\n  result.input = text;\n  result.data = inputRuleMatch.data;\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n    }\n    result.push(inputRuleMatch.replaceWith);\n  }\n  return result;\n};\nfunction run(config) {\n  var _a;\n  const { editor, from, to, text, rules, plugin } = config;\n  const { view } = editor;\n  if (view.composing) {\n    return false;\n  }\n  const $from = view.state.doc.resolve(from);\n  if (\n    // check for code node\n    $from.parent.type.spec.code || // check for code mark\n    !!((_a = $from.nodeBefore || $from.nodeAfter) == null ? void 0 : _a.marks.find((mark) => mark.type.spec.code))\n  ) {\n    return false;\n  }\n  let matched = false;\n  const textBefore = getTextContentFromNodes($from) + text;\n  rules.forEach((rule) => {\n    if (matched) {\n      return;\n    }\n    const match = inputRuleMatcherHandler(textBefore, rule.find);\n    if (!match) {\n      return;\n    }\n    const tr = view.state.tr;\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr\n    });\n    const range = {\n      from: from - (match[0].length - text.length),\n      to\n    };\n    const { commands, chain, can } = new CommandManager({\n      editor,\n      state\n    });\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can\n    });\n    if (handler === null || !tr.steps.length) {\n      return;\n    }\n    if (rule.undoable) {\n      tr.setMeta(plugin, {\n        transform: tr,\n        from,\n        to,\n        text\n      });\n    }\n    view.dispatch(tr);\n    matched = true;\n  });\n  return matched;\n}\nfunction inputRulesPlugin(props) {\n  const { editor, rules } = props;\n  const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, prev, state) {\n        const stored = tr.getMeta(plugin);\n        if (stored) {\n          return stored;\n        }\n        const simulatedInputMeta = tr.getMeta(\"applyInputRules\");\n        const isSimulatedInput = !!simulatedInputMeta;\n        if (isSimulatedInput) {\n          setTimeout(() => {\n            let { text } = simulatedInputMeta;\n            if (typeof text === \"string\") {\n              text = text;\n            } else {\n              text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(text), state.schema);\n            }\n            const { from } = simulatedInputMeta;\n            const to = from + text.length;\n            run({\n              editor,\n              from,\n              to,\n              text,\n              rules,\n              plugin\n            });\n          });\n        }\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin\n        });\n      },\n      handleDOMEvents: {\n        compositionend: (view) => {\n          setTimeout(() => {\n            const { $cursor } = view.state.selection;\n            if ($cursor) {\n              run({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: \"\",\n                rules,\n                plugin\n              });\n            }\n          });\n          return false;\n        }\n      },\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== \"Enter\") {\n          return false;\n        }\n        const { $cursor } = view.state.selection;\n        if ($cursor) {\n          return run({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: \"\\n\",\n            rules,\n            plugin\n          });\n        }\n        return false;\n      }\n    },\n    // @ts-ignore\n    isInputRules: true\n  });\n  return plugin;\n}\n\n// src/utilities/isPlainObject.ts\nfunction getType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n  if (getType(value) !== \"Object\") {\n    return false;\n  }\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\n\n// src/utilities/mergeDeep.ts\nfunction mergeDeep(target, source) {\n  const output = { ...target };\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isPlainObject(source[key]) && isPlainObject(target[key])) {\n        output[key] = mergeDeep(target[key], source[key]);\n      } else {\n        output[key] = source[key];\n      }\n    });\n  }\n  return output;\n}\n\n// src/Extendable.ts\nvar Extendable = class {\n  constructor(config = {}) {\n    this.type = \"extendable\";\n    this.parent = null;\n    this.child = null;\n    this.name = \"\";\n    this.config = {\n      name: this.name\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n  }\n  get options() {\n    return {\n      ...callOrReturn(\n        getExtensionField(this, \"addOptions\", {\n          name: this.name\n        })\n      ) || {}\n    };\n  }\n  get storage() {\n    return {\n      ...callOrReturn(\n        getExtensionField(this, \"addStorage\", {\n          name: this.name,\n          options: this.options\n        })\n      ) || {}\n    };\n  }\n  configure(options = {}) {\n    const extension = this.extend({\n      ...this.config,\n      addOptions: () => {\n        return mergeDeep(this.options, options);\n      }\n    });\n    extension.name = this.name;\n    extension.parent = this.parent;\n    return extension;\n  }\n  extend(extendedConfig = {}) {\n    const extension = new this.constructor({ ...this.config, ...extendedConfig });\n    extension.parent = this;\n    this.child = extension;\n    extension.name = \"name\" in extendedConfig ? extendedConfig.name : extension.parent.name;\n    return extension;\n  }\n};\n\n// src/Mark.ts\nvar Mark = class _Mark extends Extendable {\n  constructor() {\n    super(...arguments);\n    this.type = \"mark\";\n  }\n  /**\n   * Create a new Mark instance\n   * @param config - Mark configuration object or a function that returns a configuration object\n   */\n  static create(config = {}) {\n    const resolvedConfig = typeof config === \"function\" ? config() : config;\n    return new _Mark(resolvedConfig);\n  }\n  static handleExit({ editor, mark }) {\n    const { tr } = editor.state;\n    const currentPos = editor.state.selection.$from;\n    const isAtEnd = currentPos.pos === currentPos.end();\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks();\n      const isInMark = !!currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);\n      if (!isInMark) {\n        return false;\n      }\n      const removeMark = currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);\n      if (removeMark) {\n        tr.removeStoredMark(removeMark);\n      }\n      tr.insertText(\" \", currentPos.pos);\n      editor.view.dispatch(tr);\n      return true;\n    }\n    return false;\n  }\n  configure(options) {\n    return super.configure(options);\n  }\n  extend(extendedConfig) {\n    const resolvedConfig = typeof extendedConfig === \"function\" ? extendedConfig() : extendedConfig;\n    return super.extend(resolvedConfig);\n  }\n};\n\n// src/PasteRule.ts\n\n\n\n// src/utilities/isNumber.ts\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\n\n// src/PasteRule.ts\nvar PasteRule = class {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n};\nvar pasteRuleMatcherHandler = (text, find, event) => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)];\n  }\n  const matches = find(text, event);\n  if (!matches) {\n    return [];\n  }\n  return matches.map((pasteRuleMatch) => {\n    const result = [pasteRuleMatch.text];\n    result.index = pasteRuleMatch.index;\n    result.input = text;\n    result.data = pasteRuleMatch.data;\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n      }\n      result.push(pasteRuleMatch.replaceWith);\n    }\n    return result;\n  });\n};\nfunction run2(config) {\n  const { editor, state, from, to, rule, pasteEvent, dropEvent } = config;\n  const { commands, chain, can } = new CommandManager({\n    editor,\n    state\n  });\n  const handlers = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    var _a, _b, _c, _d, _e;\n    if (((_b = (_a = node.type) == null ? void 0 : _a.spec) == null ? void 0 : _b.code) || !(node.isText || node.isTextblock || node.isInline)) {\n      return;\n    }\n    const contentSize = (_e = (_d = (_c = node.content) == null ? void 0 : _c.size) != null ? _d : node.nodeSize) != null ? _e : 0;\n    const resolvedFrom = Math.max(from, pos);\n    const resolvedTo = Math.min(to, pos + contentSize);\n    if (resolvedFrom >= resolvedTo) {\n      return;\n    }\n    const textToMatch = node.isText ? node.text || \"\" : node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, \"\\uFFFC\");\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);\n    matches.forEach((match) => {\n      if (match.index === void 0) {\n        return;\n      }\n      const start = resolvedFrom + match.index + 1;\n      const end = start + match[0].length;\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end)\n      };\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can,\n        pasteEvent,\n        dropEvent\n      });\n      handlers.push(handler);\n    });\n  });\n  const success = handlers.every((handler) => handler !== null);\n  return success;\n}\nvar tiptapDragFromOtherEditor = null;\nvar createClipboardPasteEvent = (text) => {\n  var _a;\n  const event = new ClipboardEvent(\"paste\", {\n    clipboardData: new DataTransfer()\n  });\n  (_a = event.clipboardData) == null ? void 0 : _a.setData(\"text/html\", text);\n  return event;\n};\nfunction pasteRulesPlugin(props) {\n  const { editor, rules } = props;\n  let dragSourceElement = null;\n  let isPastedFromProseMirror = false;\n  let isDroppedFromProseMirror = false;\n  let pasteEvent = typeof ClipboardEvent !== \"undefined\" ? new ClipboardEvent(\"paste\") : null;\n  let dropEvent;\n  try {\n    dropEvent = typeof DragEvent !== \"undefined\" ? new DragEvent(\"drop\") : null;\n  } catch {\n    dropEvent = null;\n  }\n  const processEvent = ({\n    state,\n    from,\n    to,\n    rule,\n    pasteEvt\n  }) => {\n    const tr = state.tr;\n    const chainableState = createChainableState({\n      state,\n      transaction: tr\n    });\n    const handler = run2({\n      editor,\n      state: chainableState,\n      from: Math.max(from - 1, 0),\n      to: to.b - 1,\n      rule,\n      pasteEvent: pasteEvt,\n      dropEvent\n    });\n    if (!handler || !tr.steps.length) {\n      return;\n    }\n    try {\n      dropEvent = typeof DragEvent !== \"undefined\" ? new DragEvent(\"drop\") : null;\n    } catch {\n      dropEvent = null;\n    }\n    pasteEvent = typeof ClipboardEvent !== \"undefined\" ? new ClipboardEvent(\"paste\") : null;\n    return tr;\n  };\n  const plugins = rules.map((rule) => {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = (event) => {\n          var _a;\n          dragSourceElement = ((_a = view.dom.parentElement) == null ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;\n          if (dragSourceElement) {\n            tiptapDragFromOtherEditor = editor;\n          }\n        };\n        const handleDragend = () => {\n          if (tiptapDragFromOtherEditor) {\n            tiptapDragFromOtherEditor = null;\n          }\n        };\n        window.addEventListener(\"dragstart\", handleDragstart);\n        window.addEventListener(\"dragend\", handleDragend);\n        return {\n          destroy() {\n            window.removeEventListener(\"dragstart\", handleDragstart);\n            window.removeEventListener(\"dragend\", handleDragend);\n          }\n        };\n      },\n      props: {\n        handleDOMEvents: {\n          drop: (view, event) => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n            dropEvent = event;\n            if (!isDroppedFromProseMirror) {\n              const dragFromOtherEditor = tiptapDragFromOtherEditor;\n              if (dragFromOtherEditor == null ? void 0 : dragFromOtherEditor.isEditable) {\n                setTimeout(() => {\n                  const selection = dragFromOtherEditor.state.selection;\n                  if (selection) {\n                    dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });\n                  }\n                }, 10);\n              }\n            }\n            return false;\n          },\n          paste: (_view, event) => {\n            var _a;\n            const html = (_a = event.clipboardData) == null ? void 0 : _a.getData(\"text/html\");\n            pasteEvent = event;\n            isPastedFromProseMirror = !!(html == null ? void 0 : html.includes(\"data-pm-slice\"));\n            return false;\n          }\n        }\n      },\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0];\n        const isPaste = transaction.getMeta(\"uiEvent\") === \"paste\" && !isPastedFromProseMirror;\n        const isDrop = transaction.getMeta(\"uiEvent\") === \"drop\" && !isDroppedFromProseMirror;\n        const simulatedPasteMeta = transaction.getMeta(\"applyPasteRules\");\n        const isSimulatedPaste = !!simulatedPasteMeta;\n        if (!isPaste && !isDrop && !isSimulatedPaste) {\n          return;\n        }\n        if (isSimulatedPaste) {\n          let { text } = simulatedPasteMeta;\n          if (typeof text === \"string\") {\n            text = text;\n          } else {\n            text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(text), state.schema);\n          }\n          const { from: from2 } = simulatedPasteMeta;\n          const to2 = from2 + text.length;\n          const pasteEvt = createClipboardPasteEvent(text);\n          return processEvent({\n            rule,\n            state,\n            from: from2,\n            to: { b: to2 },\n            pasteEvt\n          });\n        }\n        const from = oldState.doc.content.findDiffStart(state.doc.content);\n        const to = oldState.doc.content.findDiffEnd(state.doc.content);\n        if (!isNumber(from) || !to || from === to.b) {\n          return;\n        }\n        return processEvent({\n          rule,\n          state,\n          from,\n          to,\n          pasteEvt: pasteEvent\n        });\n      }\n    });\n  });\n  return plugins;\n}\n\n// src/ExtensionManager.ts\nvar ExtensionManager = class {\n  constructor(extensions, editor) {\n    this.splittableMarks = [];\n    this.editor = editor;\n    this.baseExtensions = extensions;\n    this.extensions = resolveExtensions(extensions);\n    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);\n    this.setupExtensions();\n  }\n  /**\n   * Get all commands from the extensions.\n   * @returns An object with all commands where the key is the command name and the value is the command function\n   */\n  get commands() {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: this.editor.extensionStorage[extension.name],\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const addCommands = getExtensionField(extension, \"addCommands\", context);\n      if (!addCommands) {\n        return commands;\n      }\n      return {\n        ...commands,\n        ...addCommands()\n      };\n    }, {});\n  }\n  /**\n   * Get all registered Prosemirror plugins from the extensions.\n   * @returns An array of Prosemirror plugins\n   */\n  get plugins() {\n    const { editor } = this;\n    const extensions = sortExtensions([...this.extensions].reverse());\n    const allPlugins = extensions.flatMap((extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: this.editor.extensionStorage[extension.name],\n        editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const plugins = [];\n      const addKeyboardShortcuts = getExtensionField(\n        extension,\n        \"addKeyboardShortcuts\",\n        context\n      );\n      let defaultBindings = {};\n      if (extension.type === \"mark\" && getExtensionField(extension, \"exitable\", context)) {\n        defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension });\n      }\n      if (addKeyboardShortcuts) {\n        const bindings = Object.fromEntries(\n          Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n            return [shortcut, () => method({ editor })];\n          })\n        );\n        defaultBindings = { ...defaultBindings, ...bindings };\n      }\n      const keyMapPlugin = (0,_tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_6__.keymap)(defaultBindings);\n      plugins.push(keyMapPlugin);\n      const addInputRules = getExtensionField(extension, \"addInputRules\", context);\n      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n        const rules = addInputRules();\n        if (rules && rules.length) {\n          const inputResult = inputRulesPlugin({\n            editor,\n            rules\n          });\n          const inputPlugins = Array.isArray(inputResult) ? inputResult : [inputResult];\n          plugins.push(...inputPlugins);\n        }\n      }\n      const addPasteRules = getExtensionField(extension, \"addPasteRules\", context);\n      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n        const rules = addPasteRules();\n        if (rules && rules.length) {\n          const pasteRules = pasteRulesPlugin({ editor, rules });\n          plugins.push(...pasteRules);\n        }\n      }\n      const addProseMirrorPlugins = getExtensionField(\n        extension,\n        \"addProseMirrorPlugins\",\n        context\n      );\n      if (addProseMirrorPlugins) {\n        const proseMirrorPlugins = addProseMirrorPlugins();\n        plugins.push(...proseMirrorPlugins);\n      }\n      return plugins;\n    });\n    return allPlugins;\n  }\n  /**\n   * Get all attributes from the extensions.\n   * @returns An array of attributes\n   */\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions);\n  }\n  /**\n   * Get all node views from the extensions.\n   * @returns An object with all node views where the key is the node name and the value is the node view function\n   */\n  get nodeViews() {\n    const { editor } = this;\n    const { nodeExtensions } = splitExtensions(this.extensions);\n    return Object.fromEntries(\n      nodeExtensions.filter((extension) => !!getExtensionField(extension, \"addNodeView\")).map((extension) => {\n        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: this.editor.extensionStorage[extension.name],\n          editor,\n          type: getNodeType(extension.name, this.schema)\n        };\n        const addNodeView = getExtensionField(extension, \"addNodeView\", context);\n        if (!addNodeView) {\n          return [];\n        }\n        const nodeViewResult = addNodeView();\n        if (!nodeViewResult) {\n          return [];\n        }\n        const nodeview = (node, view, getPos, decorations, innerDecorations) => {\n          const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n          return nodeViewResult({\n            // pass-through\n            node,\n            view,\n            getPos,\n            decorations,\n            innerDecorations,\n            // tiptap-specific\n            editor,\n            extension,\n            HTMLAttributes\n          });\n        };\n        return [extension.name, nodeview];\n      })\n    );\n  }\n  get markViews() {\n    const { editor } = this;\n    const { markExtensions } = splitExtensions(this.extensions);\n    return Object.fromEntries(\n      markExtensions.filter((extension) => !!getExtensionField(extension, \"addMarkView\")).map((extension) => {\n        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: this.editor.extensionStorage[extension.name],\n          editor,\n          type: getMarkType(extension.name, this.schema)\n        };\n        const addMarkView = getExtensionField(extension, \"addMarkView\", context);\n        if (!addMarkView) {\n          return [];\n        }\n        const markView = (mark, view, inline) => {\n          const HTMLAttributes = getRenderedAttributes(mark, extensionAttributes);\n          return addMarkView()({\n            // pass-through\n            mark,\n            view,\n            inline,\n            // tiptap-specific\n            editor,\n            extension,\n            HTMLAttributes,\n            updateAttributes: (attrs) => {\n              updateMarkViewAttributes(mark, editor, attrs);\n            }\n          });\n        };\n        return [extension.name, markView];\n      })\n    );\n  }\n  /**\n   * Go through all extensions, create extension storages & setup marks\n   * & bind editor event listener.\n   */\n  setupExtensions() {\n    const extensions = this.extensions;\n    this.editor.extensionStorage = Object.fromEntries(\n      extensions.map((extension) => [extension.name, extension.storage])\n    );\n    extensions.forEach((extension) => {\n      var _a;\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: this.editor.extensionStorage[extension.name],\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      if (extension.type === \"mark\") {\n        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, \"keepOnSplit\", context))) != null ? _a : true;\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name);\n        }\n      }\n      const onBeforeCreate = getExtensionField(extension, \"onBeforeCreate\", context);\n      const onCreate = getExtensionField(extension, \"onCreate\", context);\n      const onUpdate = getExtensionField(extension, \"onUpdate\", context);\n      const onSelectionUpdate = getExtensionField(\n        extension,\n        \"onSelectionUpdate\",\n        context\n      );\n      const onTransaction = getExtensionField(extension, \"onTransaction\", context);\n      const onFocus = getExtensionField(extension, \"onFocus\", context);\n      const onBlur = getExtensionField(extension, \"onBlur\", context);\n      const onDestroy = getExtensionField(extension, \"onDestroy\", context);\n      if (onBeforeCreate) {\n        this.editor.on(\"beforeCreate\", onBeforeCreate);\n      }\n      if (onCreate) {\n        this.editor.on(\"create\", onCreate);\n      }\n      if (onUpdate) {\n        this.editor.on(\"update\", onUpdate);\n      }\n      if (onSelectionUpdate) {\n        this.editor.on(\"selectionUpdate\", onSelectionUpdate);\n      }\n      if (onTransaction) {\n        this.editor.on(\"transaction\", onTransaction);\n      }\n      if (onFocus) {\n        this.editor.on(\"focus\", onFocus);\n      }\n      if (onBlur) {\n        this.editor.on(\"blur\", onBlur);\n      }\n      if (onDestroy) {\n        this.editor.on(\"destroy\", onDestroy);\n      }\n    });\n  }\n};\nExtensionManager.resolve = resolveExtensions;\nExtensionManager.sort = sortExtensions;\nExtensionManager.flatten = flattenExtensions;\n\n// src/extensions/index.ts\nvar extensions_exports = {};\n__export(extensions_exports, {\n  ClipboardTextSerializer: () => ClipboardTextSerializer,\n  Commands: () => Commands,\n  Delete: () => Delete,\n  Drop: () => Drop,\n  Editable: () => Editable,\n  FocusEvents: () => FocusEvents,\n  Keymap: () => Keymap,\n  Paste: () => Paste,\n  Tabindex: () => Tabindex,\n  TextDirection: () => TextDirection,\n  focusEventsPluginKey: () => focusEventsPluginKey\n});\n\n// src/extensions/clipboardTextSerializer.ts\n\n\n// src/Extension.ts\nvar Extension = class _Extension extends Extendable {\n  constructor() {\n    super(...arguments);\n    this.type = \"extension\";\n  }\n  /**\n   * Create a new Extension instance\n   * @param config - Extension configuration object or a function that returns a configuration object\n   */\n  static create(config = {}) {\n    const resolvedConfig = typeof config === \"function\" ? config() : config;\n    return new _Extension(resolvedConfig);\n  }\n  configure(options) {\n    return super.configure(options);\n  }\n  extend(extendedConfig) {\n    const resolvedConfig = typeof extendedConfig === \"function\" ? extendedConfig() : extendedConfig;\n    return super.extend(resolvedConfig);\n  }\n};\n\n// src/extensions/clipboardTextSerializer.ts\nvar ClipboardTextSerializer = Extension.create({\n  name: \"clipboardTextSerializer\",\n  addOptions() {\n    return {\n      blockSeparator: void 0\n    };\n  },\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"clipboardTextSerializer\"),\n        props: {\n          clipboardTextSerializer: () => {\n            const { editor } = this;\n            const { state, schema } = editor;\n            const { doc, selection } = state;\n            const { ranges } = selection;\n            const from = Math.min(...ranges.map((range2) => range2.$from.pos));\n            const to = Math.max(...ranges.map((range2) => range2.$to.pos));\n            const textSerializers = getTextSerializersFromSchema(schema);\n            const range = { from, to };\n            return getTextBetween(doc, range, {\n              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},\n              textSerializers\n            });\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/commands.ts\nvar Commands = Extension.create({\n  name: \"commands\",\n  addCommands() {\n    return {\n      ...commands_exports\n    };\n  }\n});\n\n// src/extensions/delete.ts\n\nvar Delete = Extension.create({\n  name: \"delete\",\n  onUpdate({ transaction, appendedTransactions }) {\n    var _a, _b, _c;\n    const callback = () => {\n      var _a2, _b2, _c2, _d;\n      if ((_d = (_c2 = (_b2 = (_a2 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a2.delete) == null ? void 0 : _b2.filterTransaction) == null ? void 0 : _c2.call(_b2, transaction)) != null ? _d : transaction.getMeta(\"y-sync$\")) {\n        return;\n      }\n      const nextTransaction = combineTransactionSteps(transaction.before, [transaction, ...appendedTransactions]);\n      const changes = getChangedRanges(nextTransaction);\n      changes.forEach((change) => {\n        if (nextTransaction.mapping.mapResult(change.oldRange.from).deletedAfter && nextTransaction.mapping.mapResult(change.oldRange.to).deletedBefore) {\n          nextTransaction.before.nodesBetween(change.oldRange.from, change.oldRange.to, (node, from) => {\n            const to = from + node.nodeSize - 2;\n            const isFullyWithinRange = change.oldRange.from <= from && to <= change.oldRange.to;\n            this.editor.emit(\"delete\", {\n              type: \"node\",\n              node,\n              from,\n              to,\n              newFrom: nextTransaction.mapping.map(from),\n              newTo: nextTransaction.mapping.map(to),\n              deletedRange: change.oldRange,\n              newRange: change.newRange,\n              partial: !isFullyWithinRange,\n              editor: this.editor,\n              transaction,\n              combinedTransform: nextTransaction\n            });\n          });\n        }\n      });\n      const mapping = nextTransaction.mapping;\n      nextTransaction.steps.forEach((step, index) => {\n        var _a3, _b3;\n        if (step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveMarkStep) {\n          const newStart = mapping.slice(index).map(step.from, -1);\n          const newEnd = mapping.slice(index).map(step.to);\n          const oldStart = mapping.invert().map(newStart, -1);\n          const oldEnd = mapping.invert().map(newEnd);\n          const foundBeforeMark = (_a3 = nextTransaction.doc.nodeAt(newStart - 1)) == null ? void 0 : _a3.marks.some((mark) => mark.eq(step.mark));\n          const foundAfterMark = (_b3 = nextTransaction.doc.nodeAt(newEnd)) == null ? void 0 : _b3.marks.some((mark) => mark.eq(step.mark));\n          this.editor.emit(\"delete\", {\n            type: \"mark\",\n            mark: step.mark,\n            from: step.from,\n            to: step.to,\n            deletedRange: {\n              from: oldStart,\n              to: oldEnd\n            },\n            newRange: {\n              from: newStart,\n              to: newEnd\n            },\n            partial: Boolean(foundAfterMark || foundBeforeMark),\n            editor: this.editor,\n            transaction,\n            combinedTransform: nextTransaction\n          });\n        }\n      });\n    };\n    if ((_c = (_b = (_a = this.editor.options.coreExtensionOptions) == null ? void 0 : _a.delete) == null ? void 0 : _b.async) != null ? _c : true) {\n      setTimeout(callback, 0);\n    } else {\n      callback();\n    }\n  }\n});\n\n// src/extensions/drop.ts\n\nvar Drop = Extension.create({\n  name: \"drop\",\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"tiptapDrop\"),\n        props: {\n          handleDrop: (_, e, slice, moved) => {\n            this.editor.emit(\"drop\", {\n              editor: this.editor,\n              event: e,\n              slice,\n              moved\n            });\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/editable.ts\n\nvar Editable = Extension.create({\n  name: \"editable\",\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"editable\"),\n        props: {\n          editable: () => this.editor.options.editable\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/focusEvents.ts\n\nvar focusEventsPluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"focusEvents\");\nvar FocusEvents = Extension.create({\n  name: \"focusEvents\",\n  addProseMirrorPlugins() {\n    const { editor } = this;\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: focusEventsPluginKey,\n        props: {\n          handleDOMEvents: {\n            focus: (view, event) => {\n              editor.isFocused = true;\n              const transaction = editor.state.tr.setMeta(\"focus\", { event }).setMeta(\"addToHistory\", false);\n              view.dispatch(transaction);\n              return false;\n            },\n            blur: (view, event) => {\n              editor.isFocused = false;\n              const transaction = editor.state.tr.setMeta(\"blur\", { event }).setMeta(\"addToHistory\", false);\n              view.dispatch(transaction);\n              return false;\n            }\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/keymap.ts\n\nvar Keymap = Extension.create({\n  name: \"keymap\",\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({ commands }) => [\n      () => commands.undoInputRule(),\n      // maybe convert first text block node to default node\n      () => commands.command(({ tr }) => {\n        const { selection, doc } = tr;\n        const { empty, $anchor } = selection;\n        const { pos, parent } = $anchor;\n        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;\n        const parentIsIsolating = $parentPos.parent.type.spec.isolating;\n        const parentPos = $anchor.pos - $anchor.parentOffset;\n        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atStart(doc).from === pos;\n        if (!empty || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === \"paragraph\") {\n          return false;\n        }\n        return commands.clearNodes();\n      }),\n      () => commands.deleteSelection(),\n      () => commands.joinBackward(),\n      () => commands.selectNodeBackward()\n    ]);\n    const handleDelete = () => this.editor.commands.first(({ commands }) => [\n      () => commands.deleteSelection(),\n      () => commands.deleteCurrentNode(),\n      () => commands.joinForward(),\n      () => commands.selectNodeForward()\n    ]);\n    const handleEnter = () => this.editor.commands.first(({ commands }) => [\n      () => commands.newlineInCode(),\n      () => commands.createParagraphNear(),\n      () => commands.liftEmptyBlock(),\n      () => commands.splitBlock()\n    ]);\n    const baseKeymap = {\n      Enter: handleEnter,\n      \"Mod-Enter\": () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      \"Mod-Backspace\": handleBackspace,\n      \"Shift-Backspace\": handleBackspace,\n      Delete: handleDelete,\n      \"Mod-Delete\": handleDelete,\n      \"Mod-a\": () => this.editor.commands.selectAll()\n    };\n    const pcKeymap = {\n      ...baseKeymap\n    };\n    const macKeymap = {\n      ...baseKeymap,\n      \"Ctrl-h\": handleBackspace,\n      \"Alt-Backspace\": handleBackspace,\n      \"Ctrl-d\": handleDelete,\n      \"Ctrl-Alt-Backspace\": handleDelete,\n      \"Alt-Delete\": handleDelete,\n      \"Alt-d\": handleDelete,\n      \"Ctrl-a\": () => this.editor.commands.selectTextblockStart(),\n      \"Ctrl-e\": () => this.editor.commands.selectTextblockEnd()\n    };\n    if (isiOS() || isMacOS()) {\n      return macKeymap;\n    }\n    return pcKeymap;\n  },\n  addProseMirrorPlugins() {\n    return [\n      // With this plugin we check if the whole document was selected and deleted.\n      // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n      // to a paragraph if necessary.\n      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well\n      // with many other commands.\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"clearDocument\"),\n        appendTransaction: (transactions, oldState, newState) => {\n          if (transactions.some((tr2) => tr2.getMeta(\"composition\"))) {\n            return;\n          }\n          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n          const ignoreTr = transactions.some((transaction) => transaction.getMeta(\"preventClearDocument\"));\n          if (!docChanges || ignoreTr) {\n            return;\n          }\n          const { empty, from, to } = oldState.selection;\n          const allFrom = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atStart(oldState.doc).from;\n          const allEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atEnd(oldState.doc).to;\n          const allWasSelected = from === allFrom && to === allEnd;\n          if (empty || !allWasSelected) {\n            return;\n          }\n          const isEmpty = isNodeEmpty(newState.doc);\n          if (!isEmpty) {\n            return;\n          }\n          const tr = newState.tr;\n          const state = createChainableState({\n            state: newState,\n            transaction: tr\n          });\n          const { commands } = new CommandManager({\n            editor: this.editor,\n            state\n          });\n          commands.clearNodes();\n          if (!tr.steps.length) {\n            return;\n          }\n          return tr;\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/paste.ts\n\nvar Paste = Extension.create({\n  name: \"paste\",\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"tiptapPaste\"),\n        props: {\n          handlePaste: (_view, e, slice) => {\n            this.editor.emit(\"paste\", {\n              editor: this.editor,\n              event: e,\n              slice\n            });\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/tabindex.ts\n\nvar Tabindex = Extension.create({\n  name: \"tabindex\",\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"tabindex\"),\n        props: {\n          attributes: () => this.editor.isEditable ? { tabindex: \"0\" } : {}\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/textDirection.ts\n\nvar TextDirection = Extension.create({\n  name: \"textDirection\",\n  addOptions() {\n    return {\n      direction: void 0\n    };\n  },\n  addGlobalAttributes() {\n    if (!this.options.direction) {\n      return [];\n    }\n    const { nodeExtensions } = splitExtensions(this.extensions);\n    return [\n      {\n        types: nodeExtensions.filter((extension) => extension.name !== \"text\").map((extension) => extension.name),\n        attributes: {\n          dir: {\n            default: this.options.direction,\n            parseHTML: (element) => {\n              const dir = element.getAttribute(\"dir\");\n              if (dir && (dir === \"ltr\" || dir === \"rtl\" || dir === \"auto\")) {\n                return dir;\n              }\n              return this.options.direction;\n            },\n            renderHTML: (attributes) => {\n              if (!attributes.dir) {\n                return {};\n              }\n              return {\n                dir: attributes.dir\n              };\n            }\n          }\n        }\n      }\n    ];\n  },\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"textDirection\"),\n        props: {\n          attributes: () => {\n            const direction = this.options.direction;\n            if (!direction) {\n              return {};\n            }\n            return {\n              dir: direction\n            };\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/NodePos.ts\nvar NodePos = class _NodePos {\n  constructor(pos, editor, isBlock = false, node = null) {\n    this.currentNode = null;\n    this.actualDepth = null;\n    this.isBlock = isBlock;\n    this.resolvedPos = pos;\n    this.editor = editor;\n    this.currentNode = node;\n  }\n  get name() {\n    return this.node.type.name;\n  }\n  get node() {\n    return this.currentNode || this.resolvedPos.node();\n  }\n  get element() {\n    return this.editor.view.domAtPos(this.pos).node;\n  }\n  get depth() {\n    var _a;\n    return (_a = this.actualDepth) != null ? _a : this.resolvedPos.depth;\n  }\n  get pos() {\n    return this.resolvedPos.pos;\n  }\n  get content() {\n    return this.node.content;\n  }\n  set content(content) {\n    let from = this.from;\n    let to = this.to;\n    if (this.isBlock) {\n      if (this.content.size === 0) {\n        console.error(`You can\\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);\n        return;\n      }\n      from = this.from + 1;\n      to = this.to - 1;\n    }\n    this.editor.commands.insertContentAt({ from, to }, content);\n  }\n  get attributes() {\n    return this.node.attrs;\n  }\n  get textContent() {\n    return this.node.textContent;\n  }\n  get size() {\n    return this.node.nodeSize;\n  }\n  get from() {\n    if (this.isBlock) {\n      return this.pos;\n    }\n    return this.resolvedPos.start(this.resolvedPos.depth);\n  }\n  get range() {\n    return {\n      from: this.from,\n      to: this.to\n    };\n  }\n  get to() {\n    if (this.isBlock) {\n      return this.pos + this.size;\n    }\n    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);\n  }\n  get parent() {\n    if (this.depth === 0) {\n      return null;\n    }\n    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);\n    const $pos = this.resolvedPos.doc.resolve(parentPos);\n    return new _NodePos($pos, this.editor);\n  }\n  get before() {\n    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));\n    if ($pos.depth !== this.depth) {\n      $pos = this.resolvedPos.doc.resolve(this.from - 3);\n    }\n    return new _NodePos($pos, this.editor);\n  }\n  get after() {\n    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));\n    if ($pos.depth !== this.depth) {\n      $pos = this.resolvedPos.doc.resolve(this.to + 3);\n    }\n    return new _NodePos($pos, this.editor);\n  }\n  get children() {\n    const children = [];\n    this.node.content.forEach((node, offset) => {\n      const isBlock = node.isBlock && !node.isTextblock;\n      const isNonTextAtom = node.isAtom && !node.isText;\n      const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1);\n      if (targetPos < 0 || targetPos > this.resolvedPos.doc.nodeSize - 2) {\n        return;\n      }\n      const $pos = this.resolvedPos.doc.resolve(targetPos);\n      if (!isBlock && $pos.depth <= this.depth) {\n        return;\n      }\n      const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);\n      if (isBlock) {\n        childNodePos.actualDepth = this.depth + 1;\n      }\n      children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));\n    });\n    return children;\n  }\n  get firstChild() {\n    return this.children[0] || null;\n  }\n  get lastChild() {\n    const children = this.children;\n    return children[children.length - 1] || null;\n  }\n  closest(selector, attributes = {}) {\n    let node = null;\n    let currentNode = this.parent;\n    while (currentNode && !node) {\n      if (currentNode.node.type.name === selector) {\n        if (Object.keys(attributes).length > 0) {\n          const nodeAttributes = currentNode.node.attrs;\n          const attrKeys = Object.keys(attributes);\n          for (let index = 0; index < attrKeys.length; index += 1) {\n            const key = attrKeys[index];\n            if (nodeAttributes[key] !== attributes[key]) {\n              break;\n            }\n          }\n        } else {\n          node = currentNode;\n        }\n      }\n      currentNode = currentNode.parent;\n    }\n    return node;\n  }\n  querySelector(selector, attributes = {}) {\n    return this.querySelectorAll(selector, attributes, true)[0] || null;\n  }\n  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {\n    let nodes = [];\n    if (!this.children || this.children.length === 0) {\n      return nodes;\n    }\n    const attrKeys = Object.keys(attributes);\n    this.children.forEach((childPos) => {\n      if (firstItemOnly && nodes.length > 0) {\n        return;\n      }\n      if (childPos.node.type.name === selector) {\n        const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);\n        if (doesAllAttributesMatch) {\n          nodes.push(childPos);\n        }\n      }\n      if (firstItemOnly && nodes.length > 0) {\n        return;\n      }\n      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));\n    });\n    return nodes;\n  }\n  setAttribute(attributes) {\n    const { tr } = this.editor.state;\n    tr.setNodeMarkup(this.from, void 0, {\n      ...this.node.attrs,\n      ...attributes\n    });\n    this.editor.view.dispatch(tr);\n  }\n};\n\n// src/style.ts\nvar style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}`;\n\n// src/utilities/createStyleTag.ts\nfunction createStyleTag(style2, nonce, suffix) {\n  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : \"\"}]`);\n  if (tiptapStyleTag !== null) {\n    return tiptapStyleTag;\n  }\n  const styleNode = document.createElement(\"style\");\n  if (nonce) {\n    styleNode.setAttribute(\"nonce\", nonce);\n  }\n  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : \"\"}`, \"\");\n  styleNode.innerHTML = style2;\n  document.getElementsByTagName(\"head\")[0].appendChild(styleNode);\n  return styleNode;\n}\n\n// src/Editor.ts\nvar Editor = class extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.css = null;\n    this.className = \"tiptap\";\n    this.editorView = null;\n    this.isFocused = false;\n    /**\n     * The editor is considered initialized after the `create` event has been emitted.\n     */\n    this.isInitialized = false;\n    this.extensionStorage = {};\n    /**\n     * A unique ID for this editor instance.\n     */\n    this.instanceId = Math.random().toString(36).slice(2, 9);\n    this.options = {\n      element: typeof document !== \"undefined\" ? document.createElement(\"div\") : null,\n      content: \"\",\n      injectCSS: true,\n      injectNonce: void 0,\n      extensions: [],\n      autofocus: false,\n      editable: true,\n      textDirection: void 0,\n      editorProps: {},\n      parseOptions: {},\n      coreExtensionOptions: {},\n      enableInputRules: true,\n      enablePasteRules: true,\n      enableCoreExtensions: true,\n      enableContentCheck: false,\n      emitContentError: false,\n      onBeforeCreate: () => null,\n      onCreate: () => null,\n      onMount: () => null,\n      onUnmount: () => null,\n      onUpdate: () => null,\n      onSelectionUpdate: () => null,\n      onTransaction: () => null,\n      onFocus: () => null,\n      onBlur: () => null,\n      onDestroy: () => null,\n      onContentError: ({ error }) => {\n        throw error;\n      },\n      onPaste: () => null,\n      onDrop: () => null,\n      onDelete: () => null\n    };\n    this.isCapturingTransaction = false;\n    this.capturedTransaction = null;\n    /**\n     * Returns a set of utilities for working with positions and ranges.\n     */\n    this.utils = {\n      getUpdatedPosition,\n      createMappablePosition\n    };\n    this.setOptions(options);\n    this.createExtensionManager();\n    this.createCommandManager();\n    this.createSchema();\n    this.on(\"beforeCreate\", this.options.onBeforeCreate);\n    this.emit(\"beforeCreate\", { editor: this });\n    this.on(\"mount\", this.options.onMount);\n    this.on(\"unmount\", this.options.onUnmount);\n    this.on(\"contentError\", this.options.onContentError);\n    this.on(\"create\", this.options.onCreate);\n    this.on(\"update\", this.options.onUpdate);\n    this.on(\"selectionUpdate\", this.options.onSelectionUpdate);\n    this.on(\"transaction\", this.options.onTransaction);\n    this.on(\"focus\", this.options.onFocus);\n    this.on(\"blur\", this.options.onBlur);\n    this.on(\"destroy\", this.options.onDestroy);\n    this.on(\"drop\", ({ event, slice, moved }) => this.options.onDrop(event, slice, moved));\n    this.on(\"paste\", ({ event, slice }) => this.options.onPaste(event, slice));\n    this.on(\"delete\", this.options.onDelete);\n    const initialDoc = this.createDoc();\n    const selection = resolveFocusPosition(initialDoc, this.options.autofocus);\n    this.editorState = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.create({\n      doc: initialDoc,\n      schema: this.schema,\n      selection: selection || void 0\n    });\n    if (this.options.element) {\n      this.mount(this.options.element);\n    }\n  }\n  /**\n   * Attach the editor to the DOM, creating a new editor view.\n   */\n  mount(el) {\n    if (typeof document === \"undefined\") {\n      throw new Error(\n        `[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment.`\n      );\n    }\n    this.createView(el);\n    this.emit(\"mount\", { editor: this });\n    if (this.css && !document.head.contains(this.css)) {\n      document.head.appendChild(this.css);\n    }\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return;\n      }\n      if (this.options.autofocus !== false && this.options.autofocus !== null) {\n        this.commands.focus(this.options.autofocus);\n      }\n      this.emit(\"create\", { editor: this });\n      this.isInitialized = true;\n    }, 0);\n  }\n  /**\n   * Remove the editor from the DOM, but still allow remounting at a different point in time\n   */\n  unmount() {\n    if (this.editorView) {\n      const dom = this.editorView.dom;\n      if (dom == null ? void 0 : dom.editor) {\n        delete dom.editor;\n      }\n      this.editorView.destroy();\n    }\n    this.editorView = null;\n    this.isInitialized = false;\n    if (this.css && !document.querySelectorAll(`.${this.className}`).length) {\n      try {\n        if (typeof this.css.remove === \"function\") {\n          this.css.remove();\n        } else if (this.css.parentNode) {\n          this.css.parentNode.removeChild(this.css);\n        }\n      } catch (error) {\n        console.warn(\"Failed to remove CSS element:\", error);\n      }\n    }\n    this.css = null;\n    this.emit(\"unmount\", { editor: this });\n  }\n  /**\n   * Returns the editor storage.\n   */\n  get storage() {\n    return this.extensionStorage;\n  }\n  /**\n   * An object of all registered commands.\n   */\n  get commands() {\n    return this.commandManager.commands;\n  }\n  /**\n   * Create a command chain to call multiple commands at once.\n   */\n  chain() {\n    return this.commandManager.chain();\n  }\n  /**\n   * Check if a command or a command chain can be executed. Without executing it.\n   */\n  can() {\n    return this.commandManager.can();\n  }\n  /**\n   * Inject CSS styles.\n   */\n  injectCSS() {\n    if (this.options.injectCSS && typeof document !== \"undefined\") {\n      this.css = createStyleTag(style, this.options.injectNonce);\n    }\n  }\n  /**\n   * Update editor options.\n   *\n   * @param options A list of options\n   */\n  setOptions(options = {}) {\n    this.options = {\n      ...this.options,\n      ...options\n    };\n    if (!this.editorView || !this.state || this.isDestroyed) {\n      return;\n    }\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps);\n    }\n    this.view.updateState(this.state);\n  }\n  /**\n   * Update editable state of the editor.\n   */\n  setEditable(editable, emitUpdate = true) {\n    this.setOptions({ editable });\n    if (emitUpdate) {\n      this.emit(\"update\", { editor: this, transaction: this.state.tr, appendedTransactions: [] });\n    }\n  }\n  /**\n   * Returns whether the editor is editable.\n   */\n  get isEditable() {\n    return this.options.editable && this.view && this.view.editable;\n  }\n  /**\n   * Returns the editor state.\n   */\n  get view() {\n    if (this.editorView) {\n      return this.editorView;\n    }\n    return new Proxy(\n      {\n        state: this.editorState,\n        updateState: (state) => {\n          this.editorState = state;\n        },\n        dispatch: (tr) => {\n          this.dispatchTransaction(tr);\n        },\n        // Stub some commonly accessed properties to prevent errors\n        composing: false,\n        dragging: null,\n        editable: true,\n        isDestroyed: false\n      },\n      {\n        get: (obj, key) => {\n          if (this.editorView) {\n            return this.editorView[key];\n          }\n          if (key === \"state\") {\n            return this.editorState;\n          }\n          if (key in obj) {\n            return Reflect.get(obj, key);\n          }\n          throw new Error(\n            `[tiptap error]: The editor view is not available. Cannot access view['${key}']. The editor may not be mounted yet.`\n          );\n        }\n      }\n    );\n  }\n  /**\n   * Returns the editor state.\n   */\n  get state() {\n    if (this.editorView) {\n      this.editorState = this.view.state;\n    }\n    return this.editorState;\n  }\n  /**\n   * Register a ProseMirror plugin.\n   *\n   * @param plugin A ProseMirror plugin\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\n   * @returns The new editor state\n   */\n  registerPlugin(plugin, handlePlugins) {\n    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];\n    const state = this.state.reconfigure({ plugins });\n    this.view.updateState(state);\n    return state;\n  }\n  /**\n   * Unregister a ProseMirror plugin.\n   *\n   * @param nameOrPluginKeyToRemove The plugins name\n   * @returns The new editor state or undefined if the editor is destroyed\n   */\n  unregisterPlugin(nameOrPluginKeyToRemove) {\n    if (this.isDestroyed) {\n      return void 0;\n    }\n    const prevPlugins = this.state.plugins;\n    let plugins = prevPlugins;\n    [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {\n      const name = typeof nameOrPluginKey === \"string\" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\n      plugins = plugins.filter((plugin) => !plugin.key.startsWith(name));\n    });\n    if (prevPlugins.length === plugins.length) {\n      return void 0;\n    }\n    const state = this.state.reconfigure({\n      plugins\n    });\n    this.view.updateState(state);\n    return state;\n  }\n  /**\n   * Creates an extension manager.\n   */\n  createExtensionManager() {\n    var _a, _b;\n    const coreExtensions = this.options.enableCoreExtensions ? [\n      Editable,\n      ClipboardTextSerializer.configure({\n        blockSeparator: (_b = (_a = this.options.coreExtensionOptions) == null ? void 0 : _a.clipboardTextSerializer) == null ? void 0 : _b.blockSeparator\n      }),\n      Commands,\n      FocusEvents,\n      Keymap,\n      Tabindex,\n      Drop,\n      Paste,\n      Delete,\n      TextDirection.configure({\n        direction: this.options.textDirection\n      })\n    ].filter((ext) => {\n      if (typeof this.options.enableCoreExtensions === \"object\") {\n        return this.options.enableCoreExtensions[ext.name] !== false;\n      }\n      return true;\n    }) : [];\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {\n      return [\"extension\", \"node\", \"mark\"].includes(extension == null ? void 0 : extension.type);\n    });\n    this.extensionManager = new ExtensionManager(allExtensions, this);\n  }\n  /**\n   * Creates an command manager.\n   */\n  createCommandManager() {\n    this.commandManager = new CommandManager({\n      editor: this\n    });\n  }\n  /**\n   * Creates a ProseMirror schema.\n   */\n  createSchema() {\n    this.schema = this.extensionManager.schema;\n  }\n  /**\n   * Creates the initial document.\n   */\n  createDoc() {\n    let doc;\n    try {\n      doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {\n        errorOnInvalidContent: this.options.enableContentCheck\n      });\n    } catch (e) {\n      if (!(e instanceof Error) || ![\"[tiptap error]: Invalid JSON content\", \"[tiptap error]: Invalid HTML content\"].includes(e.message)) {\n        throw e;\n      }\n      this.emit(\"contentError\", {\n        editor: this,\n        error: e,\n        disableCollaboration: () => {\n          if (\"collaboration\" in this.storage && typeof this.storage.collaboration === \"object\" && this.storage.collaboration) {\n            ;\n            this.storage.collaboration.isDisabled = true;\n          }\n          this.options.extensions = this.options.extensions.filter((extension) => extension.name !== \"collaboration\");\n          this.createExtensionManager();\n        }\n      });\n      doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {\n        errorOnInvalidContent: false\n      });\n    }\n    return doc;\n  }\n  /**\n   * Creates a ProseMirror view.\n   */\n  createView(element) {\n    var _a;\n    this.editorView = new _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_5__.EditorView(element, {\n      ...this.options.editorProps,\n      attributes: {\n        // add `role=\"textbox\"` to the editor element\n        role: \"textbox\",\n        ...(_a = this.options.editorProps) == null ? void 0 : _a.attributes\n      },\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: this.editorState,\n      markViews: this.extensionManager.markViews,\n      nodeViews: this.extensionManager.nodeViews\n    });\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins\n    });\n    this.view.updateState(newState);\n    this.prependClass();\n    this.injectCSS();\n    const dom = this.view.dom;\n    dom.editor = this;\n  }\n  /**\n   * Creates all node and mark views.\n   */\n  createNodeViews() {\n    if (this.view.isDestroyed) {\n      return;\n    }\n    this.view.setProps({\n      markViews: this.extensionManager.markViews,\n      nodeViews: this.extensionManager.nodeViews\n    });\n  }\n  /**\n   * Prepend class name to element.\n   */\n  prependClass() {\n    this.view.dom.className = `${this.className} ${this.view.dom.className}`;\n  }\n  captureTransaction(fn) {\n    this.isCapturingTransaction = true;\n    fn();\n    this.isCapturingTransaction = false;\n    const tr = this.capturedTransaction;\n    this.capturedTransaction = null;\n    return tr;\n  }\n  /**\n   * The callback over which to send transactions (state updates) produced by the view.\n   *\n   * @param transaction An editor state transaction\n   */\n  dispatchTransaction(transaction) {\n    if (this.view.isDestroyed) {\n      return;\n    }\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction;\n        return;\n      }\n      transaction.steps.forEach((step) => {\n        var _a;\n        return (_a = this.capturedTransaction) == null ? void 0 : _a.step(step);\n      });\n      return;\n    }\n    const { state, transactions } = this.state.applyTransaction(transaction);\n    const selectionHasChanged = !this.state.selection.eq(state.selection);\n    const rootTrWasApplied = transactions.includes(transaction);\n    const prevState = this.state;\n    this.emit(\"beforeTransaction\", {\n      editor: this,\n      transaction,\n      nextState: state\n    });\n    if (!rootTrWasApplied) {\n      return;\n    }\n    this.view.updateState(state);\n    this.emit(\"transaction\", {\n      editor: this,\n      transaction,\n      appendedTransactions: transactions.slice(1)\n    });\n    if (selectionHasChanged) {\n      this.emit(\"selectionUpdate\", {\n        editor: this,\n        transaction\n      });\n    }\n    const mostRecentFocusTr = transactions.findLast((tr) => tr.getMeta(\"focus\") || tr.getMeta(\"blur\"));\n    const focus2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta(\"focus\");\n    const blur2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta(\"blur\");\n    if (focus2) {\n      this.emit(\"focus\", {\n        editor: this,\n        event: focus2.event,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        transaction: mostRecentFocusTr\n      });\n    }\n    if (blur2) {\n      this.emit(\"blur\", {\n        editor: this,\n        event: blur2.event,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        transaction: mostRecentFocusTr\n      });\n    }\n    if (transaction.getMeta(\"preventUpdate\") || !transactions.some((tr) => tr.docChanged) || prevState.doc.eq(state.doc)) {\n      return;\n    }\n    this.emit(\"update\", {\n      editor: this,\n      transaction,\n      appendedTransactions: transactions.slice(1)\n    });\n  }\n  /**\n   * Get attributes of the currently selected node or mark.\n   */\n  getAttributes(nameOrType) {\n    return getAttributes(this.state, nameOrType);\n  }\n  isActive(nameOrAttributes, attributesOrUndefined) {\n    const name = typeof nameOrAttributes === \"string\" ? nameOrAttributes : null;\n    const attributes = typeof nameOrAttributes === \"string\" ? attributesOrUndefined : nameOrAttributes;\n    return isActive(this.state, name, attributes);\n  }\n  /**\n   * Get the document as JSON.\n   */\n  getJSON() {\n    return this.state.doc.toJSON();\n  }\n  /**\n   * Get the document as HTML.\n   */\n  getHTML() {\n    return getHTMLFromFragment(this.state.doc.content, this.schema);\n  }\n  /**\n   * Get the document as text.\n   */\n  getText(options) {\n    const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...getTextSerializersFromSchema(this.schema),\n        ...textSerializers\n      }\n    });\n  }\n  /**\n   * Check if there is no content.\n   */\n  get isEmpty() {\n    return isNodeEmpty(this.state.doc);\n  }\n  /**\n   * Destroy the editor.\n   */\n  destroy() {\n    this.emit(\"destroy\");\n    this.unmount();\n    this.removeAllListeners();\n  }\n  /**\n   * Check if the editor is already destroyed.\n   */\n  get isDestroyed() {\n    var _a, _b;\n    return (_b = (_a = this.editorView) == null ? void 0 : _a.isDestroyed) != null ? _b : true;\n  }\n  $node(selector, attributes) {\n    var _a;\n    return ((_a = this.$doc) == null ? void 0 : _a.querySelector(selector, attributes)) || null;\n  }\n  $nodes(selector, attributes) {\n    var _a;\n    return ((_a = this.$doc) == null ? void 0 : _a.querySelectorAll(selector, attributes)) || null;\n  }\n  $pos(pos) {\n    const $pos = this.state.doc.resolve(pos);\n    return new NodePos($pos, this);\n  }\n  get $doc() {\n    return this.$pos(0);\n  }\n};\n\n// src/inputRules/markInputRule.ts\nfunction markInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const { tr } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {\n          const excluded = item.mark.type.excluded;\n          return excluded.find((type) => type === config.type && type !== item.mark.type);\n        }).filter((item) => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        const markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    },\n    undoable: config.undoable\n  });\n}\n\n// src/inputRules/nodeInputRule.ts\nfunction nodeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n      const { tr } = state;\n      const start = range.from;\n      let end = range.to;\n      const newNode = config.type.create(attributes);\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        let matchStart = start + offset;\n        if (matchStart > end) {\n          matchStart = end;\n        } else {\n          end = matchStart + match[1].length;\n        }\n        const lastChar = match[0][match[0].length - 1];\n        tr.insertText(lastChar, start + match[0].length - 1);\n        tr.replaceWith(matchStart, end, newNode);\n      } else if (match[0]) {\n        const insertionStart = config.type.isInline ? start : start - 1;\n        tr.insert(insertionStart, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));\n      }\n      tr.scrollIntoView();\n    },\n    undoable: config.undoable\n  });\n}\n\n// src/inputRules/textblockTypeInputRule.ts\nfunction textblockTypeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const $start = state.doc.resolve(range.from);\n      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null;\n      }\n      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);\n    },\n    undoable: config.undoable\n  });\n}\n\n// src/inputRules/textInputRule.ts\nfunction textInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    },\n    undoable: config.undoable\n  });\n}\n\n// src/inputRules/wrappingInputRule.ts\n\nfunction wrappingInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match, chain }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n      const tr = state.tr.delete(range.from, range.to);\n      const $start = tr.doc.resolve(range.from);\n      const blockRange = $start.blockRange();\n      const wrapping = blockRange && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(blockRange, config.type, attributes);\n      if (!wrapping) {\n        return null;\n      }\n      tr.wrap(blockRange, wrapping);\n      if (config.keepMarks && config.editor) {\n        const { selection, storedMarks } = state;\n        const { splittableMarks } = config.editor.extensionManager;\n        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n        if (marks) {\n          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));\n          tr.ensureMarks(filteredMarks);\n        }\n      }\n      if (config.keepAttributes) {\n        const nodeType = config.type.name === \"bulletList\" || config.type.name === \"orderedList\" ? \"listItem\" : \"taskList\";\n        chain().updateAttributes(nodeType, attributes).run();\n      }\n      const before = tr.doc.resolve(range.from - 1).nodeBefore;\n      if (before && before.type === config.type && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {\n        tr.join(range.from - 1);\n      }\n    },\n    undoable: config.undoable\n  });\n}\n\n// src/jsx-runtime.ts\nfunction Fragment6(props) {\n  return props.children;\n}\nvar h = (tag, attributes) => {\n  if (tag === \"slot\") {\n    return 0;\n  }\n  if (tag instanceof Function) {\n    return tag(attributes);\n  }\n  const { children, ...rest } = attributes != null ? attributes : {};\n  if (tag === \"svg\") {\n    throw new Error(\"SVG elements are not supported in the JSX syntax, use the array syntax instead\");\n  }\n  return [tag, rest, children];\n};\n\n// src/lib/ResizableNodeView.ts\nvar isTouchEvent = (e) => {\n  return \"touches\" in e;\n};\nvar ResizableNodeView = class {\n  /**\n   * Creates a new ResizableNodeView instance.\n   *\n   * The constructor sets up the resize handles, applies initial sizing from\n   * node attributes, and configures all resize behavior options.\n   *\n   * @param options - Configuration options for the resizable node view\n   */\n  constructor(options) {\n    /** Active resize handle directions */\n    this.directions = [\"bottom-left\", \"bottom-right\", \"top-left\", \"top-right\"];\n    /** Minimum allowed dimensions */\n    this.minSize = {\n      height: 8,\n      width: 8\n    };\n    /** Whether to always preserve aspect ratio */\n    this.preserveAspectRatio = false;\n    /** CSS class names for elements */\n    this.classNames = {\n      container: \"\",\n      wrapper: \"\",\n      handle: \"\",\n      resizing: \"\"\n    };\n    /** Initial width of the element (for aspect ratio calculation) */\n    this.initialWidth = 0;\n    /** Initial height of the element (for aspect ratio calculation) */\n    this.initialHeight = 0;\n    /** Calculated aspect ratio (width / height) */\n    this.aspectRatio = 1;\n    /** Whether a resize operation is currently active */\n    this.isResizing = false;\n    /** The handle currently being dragged */\n    this.activeHandle = null;\n    /** Starting mouse X position when resize began */\n    this.startX = 0;\n    /** Starting mouse Y position when resize began */\n    this.startY = 0;\n    /** Element width when resize began */\n    this.startWidth = 0;\n    /** Element height when resize began */\n    this.startHeight = 0;\n    /** Whether Shift key is currently pressed (for temporary aspect ratio lock) */\n    this.isShiftKeyPressed = false;\n    /**\n     * Handles mouse movement during an active resize.\n     *\n     * Calculates the delta from the starting position, computes new dimensions\n     * based on the active handle direction, applies constraints and aspect ratio,\n     * then updates the element's style and calls the onResize callback.\n     *\n     * @param event - The mouse move event\n     */\n    this.handleMouseMove = (event) => {\n      if (!this.isResizing || !this.activeHandle) {\n        return;\n      }\n      const deltaX = event.clientX - this.startX;\n      const deltaY = event.clientY - this.startY;\n      this.handleResize(deltaX, deltaY);\n    };\n    this.handleTouchMove = (event) => {\n      if (!this.isResizing || !this.activeHandle) {\n        return;\n      }\n      const touch = event.touches[0];\n      if (!touch) {\n        return;\n      }\n      const deltaX = touch.clientX - this.startX;\n      const deltaY = touch.clientY - this.startY;\n      this.handleResize(deltaX, deltaY);\n    };\n    /**\n     * Completes the resize operation when the mouse button is released.\n     *\n     * Captures final dimensions, calls the onCommit callback to persist changes,\n     * removes the resizing state and class, and cleans up document-level listeners.\n     */\n    this.handleMouseUp = () => {\n      if (!this.isResizing) {\n        return;\n      }\n      const finalWidth = this.element.offsetWidth;\n      const finalHeight = this.element.offsetHeight;\n      this.onCommit(finalWidth, finalHeight);\n      this.isResizing = false;\n      this.activeHandle = null;\n      this.container.dataset.resizeState = \"false\";\n      if (this.classNames.resizing) {\n        this.container.classList.remove(this.classNames.resizing);\n      }\n      document.removeEventListener(\"mousemove\", this.handleMouseMove);\n      document.removeEventListener(\"mouseup\", this.handleMouseUp);\n      document.removeEventListener(\"keydown\", this.handleKeyDown);\n      document.removeEventListener(\"keyup\", this.handleKeyUp);\n    };\n    /**\n     * Tracks Shift key state to enable temporary aspect ratio locking.\n     *\n     * When Shift is pressed during resize, aspect ratio is preserved even if\n     * preserveAspectRatio is false.\n     *\n     * @param event - The keyboard event\n     */\n    this.handleKeyDown = (event) => {\n      if (event.key === \"Shift\") {\n        this.isShiftKeyPressed = true;\n      }\n    };\n    /**\n     * Tracks Shift key release to disable temporary aspect ratio locking.\n     *\n     * @param event - The keyboard event\n     */\n    this.handleKeyUp = (event) => {\n      if (event.key === \"Shift\") {\n        this.isShiftKeyPressed = false;\n      }\n    };\n    var _a, _b, _c, _d, _e;\n    this.node = options.node;\n    this.element = options.element;\n    this.contentElement = options.contentElement;\n    this.getPos = options.getPos;\n    this.onResize = options.onResize;\n    this.onCommit = options.onCommit;\n    this.onUpdate = options.onUpdate;\n    if ((_a = options.options) == null ? void 0 : _a.min) {\n      this.minSize = {\n        ...this.minSize,\n        ...options.options.min\n      };\n    }\n    if ((_b = options.options) == null ? void 0 : _b.max) {\n      this.maxSize = options.options.max;\n    }\n    if ((_c = options == null ? void 0 : options.options) == null ? void 0 : _c.directions) {\n      this.directions = options.options.directions;\n    }\n    if ((_d = options.options) == null ? void 0 : _d.preserveAspectRatio) {\n      this.preserveAspectRatio = options.options.preserveAspectRatio;\n    }\n    if ((_e = options.options) == null ? void 0 : _e.className) {\n      this.classNames = {\n        container: options.options.className.container || \"\",\n        wrapper: options.options.className.wrapper || \"\",\n        handle: options.options.className.handle || \"\",\n        resizing: options.options.className.resizing || \"\"\n      };\n    }\n    this.wrapper = this.createWrapper();\n    this.container = this.createContainer();\n    this.applyInitialSize();\n    this.attachHandles();\n  }\n  /**\n   * Returns the top-level DOM node that should be placed in the editor.\n   *\n   * This is required by the ProseMirror NodeView interface. The container\n   * includes the wrapper, handles, and the actual content element.\n   *\n   * @returns The container element to be inserted into the editor\n   */\n  get dom() {\n    return this.container;\n  }\n  get contentDOM() {\n    return this.contentElement;\n  }\n  /**\n   * Called when the node's content or attributes change.\n   *\n   * Updates the internal node reference. If a custom `onUpdate` callback\n   * was provided, it will be called to handle additional update logic.\n   *\n   * @param node - The new/updated node\n   * @param decorations - Node decorations\n   * @param innerDecorations - Inner decorations\n   * @returns `false` if the node type has changed (requires full rebuild), otherwise the result of `onUpdate` or `true`\n   */\n  update(node, decorations, innerDecorations) {\n    if (node.type !== this.node.type) {\n      return false;\n    }\n    this.node = node;\n    if (this.onUpdate) {\n      return this.onUpdate(node, decorations, innerDecorations);\n    }\n    return true;\n  }\n  /**\n   * Cleanup method called when the node view is being removed.\n   *\n   * Removes all event listeners to prevent memory leaks. This is required\n   * by the ProseMirror NodeView interface. If a resize is active when\n   * destroy is called, it will be properly cancelled.\n   */\n  destroy() {\n    if (this.isResizing) {\n      this.container.dataset.resizeState = \"false\";\n      if (this.classNames.resizing) {\n        this.container.classList.remove(this.classNames.resizing);\n      }\n      document.removeEventListener(\"mousemove\", this.handleMouseMove);\n      document.removeEventListener(\"mouseup\", this.handleMouseUp);\n      document.removeEventListener(\"keydown\", this.handleKeyDown);\n      document.removeEventListener(\"keyup\", this.handleKeyUp);\n      this.isResizing = false;\n      this.activeHandle = null;\n    }\n    this.container.remove();\n  }\n  /**\n   * Creates the outer container element.\n   *\n   * The container is the top-level element returned by the NodeView and\n   * wraps the entire resizable node. It's set up with flexbox to handle\n   * alignment and includes data attributes for styling and identification.\n   *\n   * @returns The container element\n   */\n  createContainer() {\n    const element = document.createElement(\"div\");\n    element.dataset.resizeContainer = \"\";\n    element.dataset.node = this.node.type.name;\n    element.style.display = \"flex\";\n    element.style.justifyContent = \"flex-start\";\n    element.style.alignItems = \"flex-start\";\n    if (this.classNames.container) {\n      element.className = this.classNames.container;\n    }\n    element.appendChild(this.wrapper);\n    return element;\n  }\n  /**\n   * Creates the wrapper element that contains the content and handles.\n   *\n   * The wrapper uses relative positioning so that resize handles can be\n   * positioned absolutely within it. This is the direct parent of the\n   * content element being made resizable.\n   *\n   * @returns The wrapper element\n   */\n  createWrapper() {\n    const element = document.createElement(\"div\");\n    element.style.position = \"relative\";\n    element.style.display = \"block\";\n    element.dataset.resizeWrapper = \"\";\n    if (this.classNames.wrapper) {\n      element.className = this.classNames.wrapper;\n    }\n    element.appendChild(this.element);\n    return element;\n  }\n  /**\n   * Creates a resize handle element for a specific direction.\n   *\n   * Each handle is absolutely positioned and includes a data attribute\n   * identifying its direction for styling purposes.\n   *\n   * @param direction - The resize direction for this handle\n   * @returns The handle element\n   */\n  createHandle(direction) {\n    const handle = document.createElement(\"div\");\n    handle.dataset.resizeHandle = direction;\n    handle.style.position = \"absolute\";\n    if (this.classNames.handle) {\n      handle.className = this.classNames.handle;\n    }\n    return handle;\n  }\n  /**\n   * Positions a handle element according to its direction.\n   *\n   * Corner handles (e.g., 'top-left') are positioned at the intersection\n   * of two edges. Edge handles (e.g., 'top') span the full width or height.\n   *\n   * @param handle - The handle element to position\n   * @param direction - The direction determining the position\n   */\n  positionHandle(handle, direction) {\n    const isTop = direction.includes(\"top\");\n    const isBottom = direction.includes(\"bottom\");\n    const isLeft = direction.includes(\"left\");\n    const isRight = direction.includes(\"right\");\n    if (isTop) {\n      handle.style.top = \"0\";\n    }\n    if (isBottom) {\n      handle.style.bottom = \"0\";\n    }\n    if (isLeft) {\n      handle.style.left = \"0\";\n    }\n    if (isRight) {\n      handle.style.right = \"0\";\n    }\n    if (direction === \"top\" || direction === \"bottom\") {\n      handle.style.left = \"0\";\n      handle.style.right = \"0\";\n    }\n    if (direction === \"left\" || direction === \"right\") {\n      handle.style.top = \"0\";\n      handle.style.bottom = \"0\";\n    }\n  }\n  /**\n   * Creates and attaches all resize handles to the wrapper.\n   *\n   * Iterates through the configured directions, creates a handle for each,\n   * positions it, attaches the mousedown listener, and appends it to the DOM.\n   */\n  attachHandles() {\n    this.directions.forEach((direction) => {\n      const handle = this.createHandle(direction);\n      this.positionHandle(handle, direction);\n      handle.addEventListener(\"mousedown\", (event) => this.handleResizeStart(event, direction));\n      handle.addEventListener(\"touchstart\", (event) => this.handleResizeStart(event, direction));\n      this.wrapper.appendChild(handle);\n    });\n  }\n  /**\n   * Applies initial sizing from node attributes to the element.\n   *\n   * If width/height attributes exist on the node, they're applied to the element.\n   * Otherwise, the element's natural/current dimensions are measured. The aspect\n   * ratio is calculated for later use in aspect-ratio-preserving resizes.\n   */\n  applyInitialSize() {\n    const width = this.node.attrs.width;\n    const height = this.node.attrs.height;\n    if (width) {\n      this.element.style.width = `${width}px`;\n      this.initialWidth = width;\n    } else {\n      this.initialWidth = this.element.offsetWidth;\n    }\n    if (height) {\n      this.element.style.height = `${height}px`;\n      this.initialHeight = height;\n    } else {\n      this.initialHeight = this.element.offsetHeight;\n    }\n    if (this.initialWidth > 0 && this.initialHeight > 0) {\n      this.aspectRatio = this.initialWidth / this.initialHeight;\n    }\n  }\n  /**\n   * Initiates a resize operation when a handle is clicked.\n   *\n   * Captures the starting mouse position and element dimensions, sets up\n   * the resize state, adds the resizing class and state attribute, and\n   * attaches document-level listeners for mouse movement and keyboard input.\n   *\n   * @param event - The mouse down event\n   * @param direction - The direction of the handle being dragged\n   */\n  handleResizeStart(event, direction) {\n    event.preventDefault();\n    event.stopPropagation();\n    this.isResizing = true;\n    this.activeHandle = direction;\n    if (isTouchEvent(event)) {\n      this.startX = event.touches[0].clientX;\n      this.startY = event.touches[0].clientY;\n    } else {\n      this.startX = event.clientX;\n      this.startY = event.clientY;\n    }\n    this.startWidth = this.element.offsetWidth;\n    this.startHeight = this.element.offsetHeight;\n    if (this.startWidth > 0 && this.startHeight > 0) {\n      this.aspectRatio = this.startWidth / this.startHeight;\n    }\n    const pos = this.getPos();\n    if (pos !== void 0) {\n    }\n    this.container.dataset.resizeState = \"true\";\n    if (this.classNames.resizing) {\n      this.container.classList.add(this.classNames.resizing);\n    }\n    document.addEventListener(\"mousemove\", this.handleMouseMove);\n    document.addEventListener(\"touchmove\", this.handleTouchMove);\n    document.addEventListener(\"mouseup\", this.handleMouseUp);\n    document.addEventListener(\"keydown\", this.handleKeyDown);\n    document.addEventListener(\"keyup\", this.handleKeyUp);\n  }\n  handleResize(deltaX, deltaY) {\n    if (!this.activeHandle) {\n      return;\n    }\n    const shouldPreserveAspectRatio = this.preserveAspectRatio || this.isShiftKeyPressed;\n    const { width, height } = this.calculateNewDimensions(this.activeHandle, deltaX, deltaY);\n    const constrained = this.applyConstraints(width, height, shouldPreserveAspectRatio);\n    this.element.style.width = `${constrained.width}px`;\n    this.element.style.height = `${constrained.height}px`;\n    if (this.onResize) {\n      this.onResize(constrained.width, constrained.height);\n    }\n  }\n  /**\n   * Calculates new dimensions based on mouse delta and resize direction.\n   *\n   * Takes the starting dimensions and applies the mouse movement delta\n   * according to the handle direction. For corner handles, both dimensions\n   * are affected. For edge handles, only one dimension changes. If aspect\n   * ratio should be preserved, delegates to applyAspectRatio.\n   *\n   * @param direction - The active resize handle direction\n   * @param deltaX - Horizontal mouse movement since resize start\n   * @param deltaY - Vertical mouse movement since resize start\n   * @returns The calculated width and height\n   */\n  calculateNewDimensions(direction, deltaX, deltaY) {\n    let newWidth = this.startWidth;\n    let newHeight = this.startHeight;\n    const isRight = direction.includes(\"right\");\n    const isLeft = direction.includes(\"left\");\n    const isBottom = direction.includes(\"bottom\");\n    const isTop = direction.includes(\"top\");\n    if (isRight) {\n      newWidth = this.startWidth + deltaX;\n    } else if (isLeft) {\n      newWidth = this.startWidth - deltaX;\n    }\n    if (isBottom) {\n      newHeight = this.startHeight + deltaY;\n    } else if (isTop) {\n      newHeight = this.startHeight - deltaY;\n    }\n    if (direction === \"right\" || direction === \"left\") {\n      newWidth = this.startWidth + (isRight ? deltaX : -deltaX);\n    }\n    if (direction === \"top\" || direction === \"bottom\") {\n      newHeight = this.startHeight + (isBottom ? deltaY : -deltaY);\n    }\n    const shouldPreserveAspectRatio = this.preserveAspectRatio || this.isShiftKeyPressed;\n    if (shouldPreserveAspectRatio) {\n      return this.applyAspectRatio(newWidth, newHeight, direction);\n    }\n    return { width: newWidth, height: newHeight };\n  }\n  /**\n   * Applies min/max constraints to dimensions.\n   *\n   * When aspect ratio is NOT preserved, constraints are applied independently\n   * to width and height. When aspect ratio IS preserved, constraints are\n   * applied while maintaining the aspect ratioif one dimension hits a limit,\n   * the other is recalculated proportionally.\n   *\n   * This ensures that aspect ratio is never broken when constrained.\n   *\n   * @param width - The unconstrained width\n   * @param height - The unconstrained height\n   * @param preserveAspectRatio - Whether to maintain aspect ratio while constraining\n   * @returns The constrained dimensions\n   */\n  applyConstraints(width, height, preserveAspectRatio) {\n    var _a, _b, _c, _d;\n    if (!preserveAspectRatio) {\n      let constrainedWidth2 = Math.max(this.minSize.width, width);\n      let constrainedHeight2 = Math.max(this.minSize.height, height);\n      if ((_a = this.maxSize) == null ? void 0 : _a.width) {\n        constrainedWidth2 = Math.min(this.maxSize.width, constrainedWidth2);\n      }\n      if ((_b = this.maxSize) == null ? void 0 : _b.height) {\n        constrainedHeight2 = Math.min(this.maxSize.height, constrainedHeight2);\n      }\n      return { width: constrainedWidth2, height: constrainedHeight2 };\n    }\n    let constrainedWidth = width;\n    let constrainedHeight = height;\n    if (constrainedWidth < this.minSize.width) {\n      constrainedWidth = this.minSize.width;\n      constrainedHeight = constrainedWidth / this.aspectRatio;\n    }\n    if (constrainedHeight < this.minSize.height) {\n      constrainedHeight = this.minSize.height;\n      constrainedWidth = constrainedHeight * this.aspectRatio;\n    }\n    if (((_c = this.maxSize) == null ? void 0 : _c.width) && constrainedWidth > this.maxSize.width) {\n      constrainedWidth = this.maxSize.width;\n      constrainedHeight = constrainedWidth / this.aspectRatio;\n    }\n    if (((_d = this.maxSize) == null ? void 0 : _d.height) && constrainedHeight > this.maxSize.height) {\n      constrainedHeight = this.maxSize.height;\n      constrainedWidth = constrainedHeight * this.aspectRatio;\n    }\n    return { width: constrainedWidth, height: constrainedHeight };\n  }\n  /**\n   * Adjusts dimensions to maintain the original aspect ratio.\n   *\n   * For horizontal handles (left/right), uses width as the primary dimension\n   * and calculates height from it. For vertical handles (top/bottom), uses\n   * height as primary and calculates width. For corner handles, uses width\n   * as the primary dimension.\n   *\n   * @param width - The new width\n   * @param height - The new height\n   * @param direction - The active resize direction\n   * @returns Dimensions adjusted to preserve aspect ratio\n   */\n  applyAspectRatio(width, height, direction) {\n    const isHorizontal = direction === \"left\" || direction === \"right\";\n    const isVertical = direction === \"top\" || direction === \"bottom\";\n    if (isHorizontal) {\n      return {\n        width,\n        height: width / this.aspectRatio\n      };\n    }\n    if (isVertical) {\n      return {\n        width: height * this.aspectRatio,\n        height\n      };\n    }\n    return {\n      width,\n      height: width / this.aspectRatio\n    };\n  }\n};\nvar ResizableNodeview = ResizableNodeView;\n\n// src/utilities/canInsertNode.ts\n\nfunction canInsertNode(state, nodeType) {\n  const { selection } = state;\n  const { $from } = selection;\n  if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection) {\n    const index = $from.index();\n    const parent = $from.parent;\n    return parent.canReplaceWith(index, index + 1, nodeType);\n  }\n  let depth = $from.depth;\n  while (depth >= 0) {\n    const index = $from.index(depth);\n    const parent = $from.node(depth);\n    const match = parent.contentMatchAt(index);\n    if (match.matchType(nodeType)) {\n      return true;\n    }\n    depth -= 1;\n  }\n  return false;\n}\n\n// src/utilities/escapeForRegEx.ts\nfunction escapeForRegEx(string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\n\n// src/utilities/isString.ts\nfunction isString(value) {\n  return typeof value === \"string\";\n}\n\n// src/utilities/markdown/index.ts\nvar markdown_exports = {};\n__export(markdown_exports, {\n  createAtomBlockMarkdownSpec: () => createAtomBlockMarkdownSpec,\n  createBlockMarkdownSpec: () => createBlockMarkdownSpec,\n  createInlineMarkdownSpec: () => createInlineMarkdownSpec,\n  parseAttributes: () => parseAttributes,\n  parseIndentedBlocks: () => parseIndentedBlocks,\n  renderNestedMarkdownContent: () => renderNestedMarkdownContent,\n  serializeAttributes: () => serializeAttributes\n});\n\n// src/utilities/markdown/attributeUtils.ts\nfunction parseAttributes(attrString) {\n  if (!(attrString == null ? void 0 : attrString.trim())) {\n    return {};\n  }\n  const attributes = {};\n  const quotedStrings = [];\n  const tempString = attrString.replace(/[\"']([^\"']*)[\"']/g, (match) => {\n    quotedStrings.push(match);\n    return `__QUOTED_${quotedStrings.length - 1}__`;\n  });\n  const classMatches = tempString.match(/(?:^|\\s)\\.([a-zA-Z][\\w-]*)/g);\n  if (classMatches) {\n    const classes = classMatches.map((match) => match.trim().slice(1));\n    attributes.class = classes.join(\" \");\n  }\n  const idMatch = tempString.match(/(?:^|\\s)#([a-zA-Z][\\w-]*)/);\n  if (idMatch) {\n    attributes.id = idMatch[1];\n  }\n  const kvRegex = /([a-zA-Z][\\w-]*)\\s*=\\s*(__QUOTED_\\d+__)/g;\n  const kvMatches = Array.from(tempString.matchAll(kvRegex));\n  kvMatches.forEach(([, key, quotedRef]) => {\n    var _a;\n    const quotedIndex = parseInt(((_a = quotedRef.match(/__QUOTED_(\\d+)__/)) == null ? void 0 : _a[1]) || \"0\", 10);\n    const quotedValue = quotedStrings[quotedIndex];\n    if (quotedValue) {\n      attributes[key] = quotedValue.slice(1, -1);\n    }\n  });\n  const cleanString = tempString.replace(/(?:^|\\s)\\.([a-zA-Z][\\w-]*)/g, \"\").replace(/(?:^|\\s)#([a-zA-Z][\\w-]*)/g, \"\").replace(/([a-zA-Z][\\w-]*)\\s*=\\s*__QUOTED_\\d+__/g, \"\").trim();\n  if (cleanString) {\n    const booleanAttrs = cleanString.split(/\\s+/).filter(Boolean);\n    booleanAttrs.forEach((attr) => {\n      if (attr.match(/^[a-zA-Z][\\w-]*$/)) {\n        attributes[attr] = true;\n      }\n    });\n  }\n  return attributes;\n}\nfunction serializeAttributes(attributes) {\n  if (!attributes || Object.keys(attributes).length === 0) {\n    return \"\";\n  }\n  const parts = [];\n  if (attributes.class) {\n    const classes = String(attributes.class).split(/\\s+/).filter(Boolean);\n    classes.forEach((cls) => parts.push(`.${cls}`));\n  }\n  if (attributes.id) {\n    parts.push(`#${attributes.id}`);\n  }\n  Object.entries(attributes).forEach(([key, value]) => {\n    if (key === \"class\" || key === \"id\") {\n      return;\n    }\n    if (value === true) {\n      parts.push(key);\n    } else if (value !== false && value != null) {\n      parts.push(`${key}=\"${String(value)}\"`);\n    }\n  });\n  return parts.join(\" \");\n}\n\n// src/utilities/markdown/createAtomBlockMarkdownSpec.ts\nfunction createAtomBlockMarkdownSpec(options) {\n  const {\n    nodeName,\n    name: markdownName,\n    parseAttributes: parseAttributes2 = parseAttributes,\n    serializeAttributes: serializeAttributes2 = serializeAttributes,\n    defaultAttributes = {},\n    requiredAttributes = [],\n    allowedAttributes\n  } = options;\n  const blockName = markdownName || nodeName;\n  const filterAttributes = (attrs) => {\n    if (!allowedAttributes) {\n      return attrs;\n    }\n    const filtered = {};\n    allowedAttributes.forEach((key) => {\n      if (key in attrs) {\n        filtered[key] = attrs[key];\n      }\n    });\n    return filtered;\n  };\n  return {\n    parseMarkdown: (token, h2) => {\n      const attrs = { ...defaultAttributes, ...token.attributes };\n      return h2.createNode(nodeName, attrs, []);\n    },\n    markdownTokenizer: {\n      name: nodeName,\n      level: \"block\",\n      start(src) {\n        var _a;\n        const regex = new RegExp(`^:::${blockName}(?:\\\\s|$)`, \"m\");\n        const index = (_a = src.match(regex)) == null ? void 0 : _a.index;\n        return index !== void 0 ? index : -1;\n      },\n      tokenize(src, _tokens, _lexer) {\n        const regex = new RegExp(`^:::${blockName}(?:\\\\s+\\\\{([^}]*)\\\\})?\\\\s*:::(?:\\\\n|$)`);\n        const match = src.match(regex);\n        if (!match) {\n          return void 0;\n        }\n        const attrString = match[1] || \"\";\n        const attributes = parseAttributes2(attrString);\n        const missingRequired = requiredAttributes.find((required) => !(required in attributes));\n        if (missingRequired) {\n          return void 0;\n        }\n        return {\n          type: nodeName,\n          raw: match[0],\n          attributes\n        };\n      }\n    },\n    renderMarkdown: (node) => {\n      const filteredAttrs = filterAttributes(node.attrs || {});\n      const attrs = serializeAttributes2(filteredAttrs);\n      const attrString = attrs ? ` {${attrs}}` : \"\";\n      return `:::${blockName}${attrString} :::`;\n    }\n  };\n}\n\n// src/utilities/markdown/createBlockMarkdownSpec.ts\nfunction createBlockMarkdownSpec(options) {\n  const {\n    nodeName,\n    name: markdownName,\n    getContent,\n    parseAttributes: parseAttributes2 = parseAttributes,\n    serializeAttributes: serializeAttributes2 = serializeAttributes,\n    defaultAttributes = {},\n    content = \"block\",\n    allowedAttributes\n  } = options;\n  const blockName = markdownName || nodeName;\n  const filterAttributes = (attrs) => {\n    if (!allowedAttributes) {\n      return attrs;\n    }\n    const filtered = {};\n    allowedAttributes.forEach((key) => {\n      if (key in attrs) {\n        filtered[key] = attrs[key];\n      }\n    });\n    return filtered;\n  };\n  return {\n    parseMarkdown: (token, h2) => {\n      let nodeContent;\n      if (getContent) {\n        const contentResult = getContent(token);\n        nodeContent = typeof contentResult === \"string\" ? [{ type: \"text\", text: contentResult }] : contentResult;\n      } else if (content === \"block\") {\n        nodeContent = h2.parseChildren(token.tokens || []);\n      } else {\n        nodeContent = h2.parseInline(token.tokens || []);\n      }\n      const attrs = { ...defaultAttributes, ...token.attributes };\n      return h2.createNode(nodeName, attrs, nodeContent);\n    },\n    markdownTokenizer: {\n      name: nodeName,\n      level: \"block\",\n      start(src) {\n        var _a;\n        const regex = new RegExp(`^:::${blockName}`, \"m\");\n        const index = (_a = src.match(regex)) == null ? void 0 : _a.index;\n        return index !== void 0 ? index : -1;\n      },\n      tokenize(src, _tokens, lexer) {\n        var _a;\n        const openingRegex = new RegExp(`^:::${blockName}(?:\\\\s+\\\\{([^}]*)\\\\})?\\\\s*\\\\n`);\n        const openingMatch = src.match(openingRegex);\n        if (!openingMatch) {\n          return void 0;\n        }\n        const [openingTag, attrString = \"\"] = openingMatch;\n        const attributes = parseAttributes2(attrString);\n        let level = 1;\n        const position = openingTag.length;\n        let matchedContent = \"\";\n        const blockPattern = /^:::([\\w-]*)(\\s.*)?/gm;\n        const remaining = src.slice(position);\n        blockPattern.lastIndex = 0;\n        for (; ; ) {\n          const match = blockPattern.exec(remaining);\n          if (match === null) {\n            break;\n          }\n          const matchPos = match.index;\n          const blockType = match[1];\n          if ((_a = match[2]) == null ? void 0 : _a.endsWith(\":::\")) {\n            continue;\n          }\n          if (blockType) {\n            level += 1;\n          } else {\n            level -= 1;\n            if (level === 0) {\n              const rawContent = remaining.slice(0, matchPos);\n              matchedContent = rawContent.trim();\n              const fullMatch = src.slice(0, position + matchPos + match[0].length);\n              let contentTokens = [];\n              if (matchedContent) {\n                if (content === \"block\") {\n                  contentTokens = lexer.blockTokens(rawContent);\n                  contentTokens.forEach((token) => {\n                    if (token.text && (!token.tokens || token.tokens.length === 0)) {\n                      token.tokens = lexer.inlineTokens(token.text);\n                    }\n                  });\n                  while (contentTokens.length > 0) {\n                    const lastToken = contentTokens[contentTokens.length - 1];\n                    if (lastToken.type === \"paragraph\" && (!lastToken.text || lastToken.text.trim() === \"\")) {\n                      contentTokens.pop();\n                    } else {\n                      break;\n                    }\n                  }\n                } else {\n                  contentTokens = lexer.inlineTokens(matchedContent);\n                }\n              }\n              return {\n                type: nodeName,\n                raw: fullMatch,\n                attributes,\n                content: matchedContent,\n                tokens: contentTokens\n              };\n            }\n          }\n        }\n        return void 0;\n      }\n    },\n    renderMarkdown: (node, h2) => {\n      const filteredAttrs = filterAttributes(node.attrs || {});\n      const attrs = serializeAttributes2(filteredAttrs);\n      const attrString = attrs ? ` {${attrs}}` : \"\";\n      const renderedContent = h2.renderChildren(node.content || [], \"\\n\\n\");\n      return `:::${blockName}${attrString}\n\n${renderedContent}\n\n:::`;\n    }\n  };\n}\n\n// src/utilities/markdown/createInlineMarkdownSpec.ts\nfunction parseShortcodeAttributes(attrString) {\n  if (!attrString.trim()) {\n    return {};\n  }\n  const attributes = {};\n  const regex = /(\\w+)=(?:\"([^\"]*)\"|'([^']*)')/g;\n  let match = regex.exec(attrString);\n  while (match !== null) {\n    const [, key, doubleQuoted, singleQuoted] = match;\n    attributes[key] = doubleQuoted || singleQuoted;\n    match = regex.exec(attrString);\n  }\n  return attributes;\n}\nfunction serializeShortcodeAttributes(attrs) {\n  return Object.entries(attrs).filter(([, value]) => value !== void 0 && value !== null).map(([key, value]) => `${key}=\"${value}\"`).join(\" \");\n}\nfunction createInlineMarkdownSpec(options) {\n  const {\n    nodeName,\n    name: shortcodeName,\n    getContent,\n    parseAttributes: parseAttributes2 = parseShortcodeAttributes,\n    serializeAttributes: serializeAttributes2 = serializeShortcodeAttributes,\n    defaultAttributes = {},\n    selfClosing = false,\n    allowedAttributes\n  } = options;\n  const shortcode = shortcodeName || nodeName;\n  const filterAttributes = (attrs) => {\n    if (!allowedAttributes) {\n      return attrs;\n    }\n    const filtered = {};\n    allowedAttributes.forEach((key) => {\n      if (key in attrs) {\n        filtered[key] = attrs[key];\n      }\n    });\n    return filtered;\n  };\n  const escapedShortcode = shortcode.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  return {\n    parseMarkdown: (token, h2) => {\n      const attrs = { ...defaultAttributes, ...token.attributes };\n      if (selfClosing) {\n        return h2.createNode(nodeName, attrs);\n      }\n      const content = getContent ? getContent(token) : token.content || \"\";\n      if (content) {\n        return h2.createNode(nodeName, attrs, [h2.createTextNode(content)]);\n      }\n      return h2.createNode(nodeName, attrs, []);\n    },\n    markdownTokenizer: {\n      name: nodeName,\n      level: \"inline\",\n      start(src) {\n        const startPattern = selfClosing ? new RegExp(`\\\\[${escapedShortcode}\\\\s*[^\\\\]]*\\\\]`) : new RegExp(`\\\\[${escapedShortcode}\\\\s*[^\\\\]]*\\\\][\\\\s\\\\S]*?\\\\[\\\\/${escapedShortcode}\\\\]`);\n        const match = src.match(startPattern);\n        const index = match == null ? void 0 : match.index;\n        return index !== void 0 ? index : -1;\n      },\n      tokenize(src, _tokens, _lexer) {\n        const tokenPattern = selfClosing ? new RegExp(`^\\\\[${escapedShortcode}\\\\s*([^\\\\]]*)\\\\]`) : new RegExp(`^\\\\[${escapedShortcode}\\\\s*([^\\\\]]*)\\\\]([\\\\s\\\\S]*?)\\\\[\\\\/${escapedShortcode}\\\\]`);\n        const match = src.match(tokenPattern);\n        if (!match) {\n          return void 0;\n        }\n        let content = \"\";\n        let attrString = \"\";\n        if (selfClosing) {\n          const [, attrs] = match;\n          attrString = attrs;\n        } else {\n          const [, attrs, contentMatch] = match;\n          attrString = attrs;\n          content = contentMatch || \"\";\n        }\n        const attributes = parseAttributes2(attrString.trim());\n        return {\n          type: nodeName,\n          raw: match[0],\n          content: content.trim(),\n          attributes\n        };\n      }\n    },\n    renderMarkdown: (node) => {\n      let content = \"\";\n      if (getContent) {\n        content = getContent(node);\n      } else if (node.content && node.content.length > 0) {\n        content = node.content.filter((child) => child.type === \"text\").map((child) => child.text).join(\"\");\n      }\n      const filteredAttrs = filterAttributes(node.attrs || {});\n      const attrs = serializeAttributes2(filteredAttrs);\n      const attrString = attrs ? ` ${attrs}` : \"\";\n      if (selfClosing) {\n        return `[${shortcode}${attrString}]`;\n      }\n      return `[${shortcode}${attrString}]${content}[/${shortcode}]`;\n    }\n  };\n}\n\n// src/utilities/markdown/parseIndentedBlocks.ts\nfunction parseIndentedBlocks(src, config, lexer) {\n  var _a, _b, _c, _d;\n  const lines = src.split(\"\\n\");\n  const items = [];\n  let totalRaw = \"\";\n  let i = 0;\n  const baseIndentSize = config.baseIndentSize || 2;\n  while (i < lines.length) {\n    const currentLine = lines[i];\n    const itemMatch = currentLine.match(config.itemPattern);\n    if (!itemMatch) {\n      if (items.length > 0) {\n        break;\n      } else if (currentLine.trim() === \"\") {\n        i += 1;\n        totalRaw = `${totalRaw}${currentLine}\n`;\n        continue;\n      } else {\n        return void 0;\n      }\n    }\n    const itemData = config.extractItemData(itemMatch);\n    const { indentLevel, mainContent } = itemData;\n    totalRaw = `${totalRaw}${currentLine}\n`;\n    const itemContent = [mainContent];\n    i += 1;\n    while (i < lines.length) {\n      const nextLine = lines[i];\n      if (nextLine.trim() === \"\") {\n        const nextNonEmptyIndex = lines.slice(i + 1).findIndex((l) => l.trim() !== \"\");\n        if (nextNonEmptyIndex === -1) {\n          break;\n        }\n        const nextNonEmpty = lines[i + 1 + nextNonEmptyIndex];\n        const nextIndent2 = ((_b = (_a = nextNonEmpty.match(/^(\\s*)/)) == null ? void 0 : _a[1]) == null ? void 0 : _b.length) || 0;\n        if (nextIndent2 > indentLevel) {\n          itemContent.push(nextLine);\n          totalRaw = `${totalRaw}${nextLine}\n`;\n          i += 1;\n          continue;\n        } else {\n          break;\n        }\n      }\n      const nextIndent = ((_d = (_c = nextLine.match(/^(\\s*)/)) == null ? void 0 : _c[1]) == null ? void 0 : _d.length) || 0;\n      if (nextIndent > indentLevel) {\n        itemContent.push(nextLine);\n        totalRaw = `${totalRaw}${nextLine}\n`;\n        i += 1;\n      } else {\n        break;\n      }\n    }\n    let nestedTokens;\n    const nestedContent = itemContent.slice(1);\n    if (nestedContent.length > 0) {\n      const dedentedNested = nestedContent.map((nestedLine) => nestedLine.slice(indentLevel + baseIndentSize)).join(\"\\n\");\n      if (dedentedNested.trim()) {\n        if (config.customNestedParser) {\n          nestedTokens = config.customNestedParser(dedentedNested);\n        } else {\n          nestedTokens = lexer.blockTokens(dedentedNested);\n        }\n      }\n    }\n    const token = config.createToken(itemData, nestedTokens);\n    items.push(token);\n  }\n  if (items.length === 0) {\n    return void 0;\n  }\n  return {\n    items,\n    raw: totalRaw\n  };\n}\n\n// src/utilities/markdown/renderNestedMarkdownContent.ts\nfunction renderNestedMarkdownContent(node, h2, prefixOrGenerator, ctx) {\n  if (!node || !Array.isArray(node.content)) {\n    return \"\";\n  }\n  const prefix = typeof prefixOrGenerator === \"function\" ? prefixOrGenerator(ctx) : prefixOrGenerator;\n  const [content, ...children] = node.content;\n  const mainContent = h2.renderChildren([content]);\n  const output = [`${prefix}${mainContent}`];\n  if (children && children.length > 0) {\n    children.forEach((child) => {\n      const childContent = h2.renderChildren([child]);\n      if (childContent) {\n        const indentedChild = childContent.split(\"\\n\").map((line) => line ? h2.indent(line) : \"\").join(\"\\n\");\n        output.push(indentedChild);\n      }\n    });\n  }\n  return output.join(\"\\n\");\n}\n\n// src/MarkView.ts\nfunction updateMarkViewAttributes(checkMark, editor, attrs = {}) {\n  const { state } = editor;\n  const { doc, tr } = state;\n  const thisMark = checkMark;\n  doc.descendants((node, pos) => {\n    const from = tr.mapping.map(pos);\n    const to = tr.mapping.map(pos) + node.nodeSize;\n    let foundMark = null;\n    node.marks.forEach((mark) => {\n      if (mark !== thisMark) {\n        return false;\n      }\n      foundMark = mark;\n    });\n    if (!foundMark) {\n      return;\n    }\n    let needsUpdate = false;\n    Object.keys(attrs).forEach((k) => {\n      if (attrs[k] !== foundMark.attrs[k]) {\n        needsUpdate = true;\n      }\n    });\n    if (needsUpdate) {\n      const updatedMark = checkMark.type.create({\n        ...checkMark.attrs,\n        ...attrs\n      });\n      tr.removeMark(from, to, checkMark.type);\n      tr.addMark(from, to, updatedMark);\n    }\n  });\n  if (tr.docChanged) {\n    editor.view.dispatch(tr);\n  }\n}\nvar MarkView = class {\n  constructor(component, props, options) {\n    this.component = component;\n    this.editor = props.editor;\n    this.options = { ...options };\n    this.mark = props.mark;\n    this.HTMLAttributes = props.HTMLAttributes;\n  }\n  get dom() {\n    return this.editor.view.dom;\n  }\n  get contentDOM() {\n    return null;\n  }\n  /**\n   * Update the attributes of the mark in the document.\n   * @param attrs The attributes to update.\n   */\n  updateAttributes(attrs, checkMark) {\n    updateMarkViewAttributes(checkMark || this.mark, this.editor, attrs);\n  }\n  ignoreMutation(mutation) {\n    if (!this.dom || !this.contentDOM) {\n      return true;\n    }\n    if (typeof this.options.ignoreMutation === \"function\") {\n      return this.options.ignoreMutation({ mutation });\n    }\n    if (mutation.type === \"selection\") {\n      return false;\n    }\n    if (this.dom.contains(mutation.target) && mutation.type === \"childList\" && (isiOS() || isAndroid()) && this.editor.isFocused) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];\n      if (changedNodes.every((node) => node.isContentEditable)) {\n        return false;\n      }\n    }\n    if (this.contentDOM === mutation.target && mutation.type === \"attributes\") {\n      return true;\n    }\n    if (this.contentDOM.contains(mutation.target)) {\n      return false;\n    }\n    return true;\n  }\n};\n\n// src/Node.ts\nvar Node3 = class _Node extends Extendable {\n  constructor() {\n    super(...arguments);\n    this.type = \"node\";\n  }\n  /**\n   * Create a new Node instance\n   * @param config - Node configuration object or a function that returns a configuration object\n   */\n  static create(config = {}) {\n    const resolvedConfig = typeof config === \"function\" ? config() : config;\n    return new _Node(resolvedConfig);\n  }\n  configure(options) {\n    return super.configure(options);\n  }\n  extend(extendedConfig) {\n    const resolvedConfig = typeof extendedConfig === \"function\" ? extendedConfig() : extendedConfig;\n    return super.extend(resolvedConfig);\n  }\n};\n\n// src/NodeView.ts\n\nvar NodeView = class {\n  constructor(component, props, options) {\n    this.isDragging = false;\n    this.component = component;\n    this.editor = props.editor;\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options\n    };\n    this.extension = props.extension;\n    this.node = props.node;\n    this.decorations = props.decorations;\n    this.innerDecorations = props.innerDecorations;\n    this.view = props.view;\n    this.HTMLAttributes = props.HTMLAttributes;\n    this.getPos = props.getPos;\n    this.mount();\n  }\n  mount() {\n    return;\n  }\n  get dom() {\n    return this.editor.view.dom;\n  }\n  get contentDOM() {\n    return null;\n  }\n  onDragStart(event) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const { view } = this.editor;\n    const target = event.target;\n    const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) == null ? void 0 : _a.closest(\"[data-drag-handle]\") : target.closest(\"[data-drag-handle]\");\n    if (!this.dom || ((_b = this.contentDOM) == null ? void 0 : _b.contains(target)) || !dragHandle) {\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect();\n      const handleBox = dragHandle.getBoundingClientRect();\n      const offsetX = (_d = event.offsetX) != null ? _d : (_c = event.nativeEvent) == null ? void 0 : _c.offsetX;\n      const offsetY = (_f = event.offsetY) != null ? _f : (_e = event.nativeEvent) == null ? void 0 : _e.offsetY;\n      x = handleBox.x - domBox.x + offsetX;\n      y = handleBox.y - domBox.y + offsetY;\n    }\n    const clonedNode = this.dom.cloneNode(true);\n    try {\n      const domBox = this.dom.getBoundingClientRect();\n      clonedNode.style.width = `${Math.round(domBox.width)}px`;\n      clonedNode.style.height = `${Math.round(domBox.height)}px`;\n      clonedNode.style.boxSizing = \"border-box\";\n      clonedNode.style.pointerEvents = \"none\";\n    } catch {\n    }\n    let dragImageWrapper = null;\n    try {\n      dragImageWrapper = document.createElement(\"div\");\n      dragImageWrapper.style.position = \"absolute\";\n      dragImageWrapper.style.top = \"-9999px\";\n      dragImageWrapper.style.left = \"-9999px\";\n      dragImageWrapper.style.pointerEvents = \"none\";\n      dragImageWrapper.appendChild(clonedNode);\n      document.body.appendChild(dragImageWrapper);\n      (_g = event.dataTransfer) == null ? void 0 : _g.setDragImage(clonedNode, x, y);\n    } finally {\n      if (dragImageWrapper) {\n        setTimeout(() => {\n          try {\n            dragImageWrapper == null ? void 0 : dragImageWrapper.remove();\n          } catch {\n          }\n        }, 0);\n      }\n    }\n    const pos = this.getPos();\n    if (typeof pos !== \"number\") {\n      return;\n    }\n    const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(view.state.doc, pos);\n    const transaction = view.state.tr.setSelection(selection);\n    view.dispatch(transaction);\n  }\n  stopEvent(event) {\n    var _a;\n    if (!this.dom) {\n      return false;\n    }\n    if (typeof this.options.stopEvent === \"function\") {\n      return this.options.stopEvent({ event });\n    }\n    const target = event.target;\n    const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) == null ? void 0 : _a.contains(target));\n    if (!isInElement) {\n      return false;\n    }\n    const isDragEvent = event.type.startsWith(\"drag\");\n    const isDropEvent = event.type === \"drop\";\n    const isInput = [\"INPUT\", \"BUTTON\", \"SELECT\", \"TEXTAREA\"].includes(target.tagName) || target.isContentEditable;\n    if (isInput && !isDropEvent && !isDragEvent) {\n      return true;\n    }\n    const { isEditable } = this.editor;\n    const { isDragging } = this;\n    const isDraggable = !!this.node.type.spec.draggable;\n    const isSelectable = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(this.node);\n    const isCopyEvent = event.type === \"copy\";\n    const isPasteEvent = event.type === \"paste\";\n    const isCutEvent = event.type === \"cut\";\n    const isClickEvent = event.type === \"mousedown\";\n    if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {\n      event.preventDefault();\n    }\n    if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {\n      event.preventDefault();\n      return false;\n    }\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest(\"[data-drag-handle]\");\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n      if (isValidDragHandle) {\n        this.isDragging = true;\n        document.addEventListener(\n          \"dragend\",\n          () => {\n            this.isDragging = false;\n          },\n          { once: true }\n        );\n        document.addEventListener(\n          \"drop\",\n          () => {\n            this.isDragging = false;\n          },\n          { once: true }\n        );\n        document.addEventListener(\n          \"mouseup\",\n          () => {\n            this.isDragging = false;\n          },\n          { once: true }\n        );\n      }\n    }\n    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.\n   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation\n   * @return `true` if it can safely be ignored.\n   */\n  ignoreMutation(mutation) {\n    if (!this.dom || !this.contentDOM) {\n      return true;\n    }\n    if (typeof this.options.ignoreMutation === \"function\") {\n      return this.options.ignoreMutation({ mutation });\n    }\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true;\n    }\n    if (mutation.type === \"selection\") {\n      return false;\n    }\n    if (this.dom.contains(mutation.target) && mutation.type === \"childList\" && (isiOS() || isAndroid()) && this.editor.isFocused) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];\n      if (changedNodes.every((node) => node.isContentEditable)) {\n        return false;\n      }\n    }\n    if (this.contentDOM === mutation.target && mutation.type === \"attributes\") {\n      return true;\n    }\n    if (this.contentDOM.contains(mutation.target)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Update the attributes of the prosemirror node.\n   */\n  updateAttributes(attributes) {\n    this.editor.commands.command(({ tr }) => {\n      const pos = this.getPos();\n      if (typeof pos !== \"number\") {\n        return false;\n      }\n      tr.setNodeMarkup(pos, void 0, {\n        ...this.node.attrs,\n        ...attributes\n      });\n      return true;\n    });\n  }\n  /**\n   * Delete the node.\n   */\n  deleteNode() {\n    const from = this.getPos();\n    if (typeof from !== \"number\") {\n      return;\n    }\n    const to = from + this.node.nodeSize;\n    this.editor.commands.deleteRange({ from, to });\n  }\n};\n\n// src/pasteRules/markPasteRule.ts\nfunction markPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match, pasteEvent }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const { tr } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      let markEnd = range.to;\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {\n          const excluded = item.mark.type.excluded;\n          return excluded.find((type) => type === config.type && type !== item.mark.type);\n        }).filter((item) => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n\n// src/pasteRules/nodePasteRule.ts\nfunction nodePasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler({ match, chain, range, pasteEvent }) {\n      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);\n      const content = callOrReturn(config.getContent, void 0, attributes);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const node = { type: config.type.name, attrs: attributes };\n      if (content) {\n        node.content = content;\n      }\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, node);\n      }\n    }\n  });\n}\n\n// src/pasteRules/textPasteRule.ts\nfunction textPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\n\n// src/Tracker.ts\nvar Tracker = class {\n  constructor(transaction) {\n    this.transaction = transaction;\n    this.currentStep = this.transaction.steps.length;\n  }\n  map(position) {\n    let deleted = false;\n    const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {\n      const mapResult = step.getMap().mapResult(newPosition);\n      if (mapResult.deleted) {\n        deleted = true;\n      }\n      return mapResult.pos;\n    }, position);\n    return {\n      position: mappedPosition,\n      deleted\n    };\n  }\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBLFVBQVUscUJBQXFCO0FBQy9CLFFBQVEsWUFBWTtBQUNwQixRQUFRLE1BQU07QUFDZCxRQUFRLGNBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDLFlBQVksT0FBTztBQUNuQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QyxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw0QkFBNEI7QUFDbkYsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZELG1DQUFtQyxZQUFZO0FBQy9DOztBQUVBO0FBQ2tEO0FBQ2xELDBCQUEwQixxQkFBcUI7QUFDL0MsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0VBQVU7QUFDeEM7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3lGO0FBQ3pGLG1DQUFtQyxpQkFBaUI7QUFDcEQsU0FBUyx3RUFBMkI7QUFDcEM7O0FBRUE7QUFDaUQ7QUFDakQseUNBQXlDLFlBQVk7QUFDckQsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFhO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQyxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QyxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNpRjtBQUNqRiwrQkFBK0IsaUJBQWlCO0FBQ2hELFNBQVMsb0VBQXVCO0FBQ2hDOztBQUVBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTs7QUFFQTtBQUNtRTtBQUNuRSx3QkFBd0IsaUJBQWlCO0FBQ3pDLFNBQVMsNkRBQWdCO0FBQ3pCOztBQUVBO0FBQ21FOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxjQUFjO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxRQUFRLHFCQUFxQjtBQUMvRTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCLFVBQVUsa0JBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyREFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ21FO0FBQ25FO0FBQ0EsMEJBQTBCLDJEQUFjO0FBQ3hDOztBQUVBO0FBQzhFOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVEQUFTO0FBQ3BDLHlCQUF5Qix1REFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJEQUFjO0FBQ3pCO0FBQ0EsU0FBUywyREFBYztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFFBQVEsNEJBQTRCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRTs7QUFFQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pELG9DQUFvQyw4Q0FBOEM7QUFDbEY7O0FBRUE7QUFDeUQ7O0FBRXpEO0FBQ3dGOztBQUV4RjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsa0RBQWUsdUJBQXVCLHNEQUFRO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtFQUFrRSxjQUFjO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvREFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxRQUFRLHVEQUFTO0FBQ2pCLFFBQVE7QUFDUixRQUFRLHVEQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxlQUFlO0FBQ3BFLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJEO0FBQ1c7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZEQUFXLG9CQUFvQixtRUFBaUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0IsdURBQVU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsc0JBQXNCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVcsbUNBQW1DLCtCQUErQixJQUFJO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEIsc0RBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdCQUF3QjtBQUM5RDtBQUNBO0FBQ0Esc0NBQXNDLHdCQUF3QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQU02QjtBQUM3QixzQkFBc0IsaUJBQWlCO0FBQ3ZDLFNBQVMsMkRBQWM7QUFDdkI7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLFNBQVMsNkRBQWdCO0FBQ3pCO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QyxTQUFTLGlFQUFvQjtBQUM3QjtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUMsU0FBUyxnRUFBbUI7QUFDNUI7O0FBRUE7QUFDaUQ7QUFDakQsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBLGtCQUFrQiwrREFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUMrRDtBQUMvRCwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0Esa0JBQWtCLCtEQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQytFO0FBQy9FLHFDQUFxQyxpQkFBaUI7QUFDdEQsU0FBUywwRUFBZTtBQUN4Qjs7QUFFQTtBQUMrRTtBQUMvRSxvQ0FBb0MsaUJBQWlCO0FBQ3JELFNBQVMseUVBQWdCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ04scURBQXFELElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUMyRDs7QUFFM0Q7QUFDQSx3REFBd0Q7QUFDeEQsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDJFQUEyRSxlQUFlO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxRQUFRLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBWTtBQUNyQjs7QUFFQTtBQUMrRTtBQUMvRSw4QkFBOEIsaUJBQWlCO0FBQy9DLFNBQVMsbUVBQXNCO0FBQy9COztBQUVBO0FBQzhFO0FBQzlFLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQSxTQUFTLG9FQUFvQjtBQUM3Qjs7QUFFQTtBQUM2RTtBQUM3RSw2QkFBNkIsaUJBQWlCO0FBQzlDLFNBQVMsa0VBQXFCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBLHFEQUFxRCxxQkFBcUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDZ0Q7QUFDaEQseUJBQXlCLGNBQWM7QUFDdkM7QUFDQSwwQkFBMEIsMERBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDdUY7QUFDdkYsa0NBQWtDLGlCQUFpQjtBQUNuRCxTQUFTLHVFQUEwQjtBQUNuQzs7QUFFQTtBQUNxRjtBQUNyRixpQ0FBaUMsaUJBQWlCO0FBQ2xELFNBQVMsc0VBQXlCO0FBQ2xDOztBQUVBO0FBQ21GO0FBQ25GLGdDQUFnQyxpQkFBaUI7QUFDakQsU0FBUyxxRUFBd0I7QUFDakM7O0FBRUE7QUFDdUY7QUFDdkYsa0NBQWtDLGlCQUFpQjtBQUNuRCxTQUFTLHVFQUEwQjtBQUNuQzs7QUFFQTtBQUMyRjtBQUMzRixvQ0FBb0MsaUJBQWlCO0FBQ3JELFNBQVMseUVBQTRCO0FBQ3JDOztBQUVBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSw2QkFBNkIsOERBQThELElBQUksUUFBUSxnQ0FBZ0M7QUFDdkksVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtCQUErQjtBQUNuRTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDaUQ7QUFDakQ7QUFDQSx3QkFBd0IsMkRBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDd0M7O0FBRXhDO0FBQ2lEO0FBQ2pEO0FBQ0EsMkJBQTJCLDJEQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZ0RBQWdEO0FBQ2hELHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkZBQTJGLFNBQVMsSUFBSSxJQUFJLFdBQVc7QUFDdkgsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDhFQUE4RTtBQUNqRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWCxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK01BQStNO0FBQy9NO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLG9EQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrQ0FBa0MsS0FBSyxlQUFlO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtEQUFJO0FBQzFCO0FBQ0E7O0FBRUE7QUFDMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1REFBVTtBQUNuQjs7QUFFQTtBQUNpRDs7QUFFakQ7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQixVQUFVLGdEQUFnRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsZ0RBQWdEO0FBQzFEO0FBQ0Esc0JBQXNCLGtEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUIsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEMsT0FBTztBQUNQO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RCxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMERBQTBELGVBQWU7QUFDOUU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywyRUFBMkUsZUFBZTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUNBQWlDO0FBQ3JFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDaUQ7QUFDakQ7QUFDQSwwQkFBMEIsMkRBQWE7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQ0FBMEMsUUFBUSxxQkFBcUI7QUFDdkUsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDbUQ7QUFDbkQsMENBQTBDLFFBQVEsd0JBQXdCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDLHdCQUF3QixpRUFBWSxTQUFTLG9DQUFvQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsYUFBYSxxQkFBcUI7QUFDckMsV0FBVyxpRUFBWSxTQUFTLG9DQUFvQztBQUNwRSxHQUFHO0FBQ0g7O0FBRUE7QUFDbUU7QUFDbkUsd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxzQkFBc0IsMkRBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQscUJBQXFCO0FBQ3hFLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ21FO0FBQ25FLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksV0FBVyxtQ0FBbUMsK0JBQStCO0FBQ3pGLG1CQUFtQiwyREFBYztBQUNqQyxtQkFBbUIsMkRBQWM7QUFDakM7QUFDQTtBQUNBLHNCQUFzQiwyREFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4RTtBQUM5RSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0EsU0FBUyxvRUFBb0I7QUFDN0I7O0FBRUE7QUFDb0c7QUFDcEQ7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CLElBQUksUUFBUSw2QkFBNkI7QUFDaEYsVUFBVSxpQkFBaUI7QUFDM0IsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQSwyQkFBMkIsMkRBQWM7QUFDekMsZ0NBQWdDLDhEQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQVE7QUFDcEIsd0JBQXdCLDhEQUFRLGtEQUFrRCxhQUFhO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJEQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNnRTtBQUNHO0FBQ047QUFDN0QsbURBQW1ELFFBQVEsNkJBQTZCO0FBQ3hGO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzREFBUztBQUMxQjtBQUNBLDhDQUE4QyxzQkFBc0I7QUFDcEUsZUFBZSxzREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzREFBUztBQUNsQztBQUNBLHNEQUFzRCxtREFBSztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0JBQXdCLDJEQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnQ0FBZ0M7QUFDdEMsTUFBTTtBQUNOLFNBQVMsZ0NBQWdDO0FBQ3pDLE9BQU8sOERBQVM7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsNkRBQU87QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsNkRBQU87QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFFBQVEsbURBQW1EO0FBQ3ZJLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQyxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsNkNBQTZDLGNBQWMsUUFBUSxpQkFBaUI7QUFDcEYsVUFBVSwrQkFBK0I7QUFDekM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0QsUUFBUSxpQkFBaUI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DO0FBQ3RFOztBQUVBO0FBQ0EsNkNBQTZDLFFBQVEsaUJBQWlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0MsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsUUFBUSxxQkFBcUI7QUFDdEU7QUFDQSxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLFlBQVk7QUFDdEI7QUFDQSxVQUFVLHVCQUF1QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLHFCQUFxQjtBQUMvRCxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsUUFBUSxxQkFBcUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDK0Q7QUFDL0QseUNBQXlDLFFBQVEsaUJBQWlCO0FBQ2xFO0FBQ0EsU0FBUywyREFBYztBQUN2Qjs7QUFFQTtBQUMwRTtBQUMxRSw2Q0FBNkMsUUFBUSxpQkFBaUI7QUFDdEU7QUFDQSxTQUFTLGtFQUFrQjtBQUMzQjs7QUFFQTtBQUMrQztBQUNGOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMkM7O0FBRTNDO0FBQ3lEO0FBQ2Y7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3Q0FBd0M7QUFDbEQsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCLHFCQUFxQixvREFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLGNBQWM7QUFDZCx5Q0FBeUMsc0RBQVM7QUFDbEQ7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDZDQUE2QyxtQ0FBbUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3lEO0FBQ0o7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSx1REFBdUQ7QUFDakUsVUFBVSx1QkFBdUI7QUFDakM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9EQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsd0NBQXdDO0FBQ3ZHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLFlBQVk7QUFDWix1Q0FBdUMsc0RBQVM7QUFDaEQ7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx5QkFBeUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRCxXQUFXO0FBQ1g7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSwyQkFBMkIseURBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxvREFBTztBQUNqQixpQkFBaUIsdURBQVM7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLG9CQUFvQixnQkFBZ0I7QUFDcEMsb0JBQW9CLGlCQUFpQjtBQUNyQyxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0REFBNEQsOENBQThDLElBQUk7QUFDOUc7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNzRDtBQUN0RDtBQUNBO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdFQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQzhFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBTztBQUNqQixpQkFBaUIsdURBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUM4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQU87QUFDakIsaUJBQWlCLHVEQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUM4RTtBQUM5RSwrQkFBK0IsdURBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsVUFBVSxvREFBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE9BQU87QUFDNUU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0VBQW9FLE9BQU87QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUN1RztBQUN2RztBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsVUFBVTtBQUMxRTtBQUNBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEMsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCx1REFBVTtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxVQUFVO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9EQUFPO0FBQ2pCLGlCQUFpQix1REFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDLDBCQUEwQix1REFBVTtBQUNwQyx5QkFBeUIsdURBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQzhFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBTztBQUNqQixpQkFBaUIsdURBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9EQUFPO0FBQ2pCLGlCQUFpQix1REFBVTtBQUMzQjtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxvREFBUTtBQUNsQixpQkFBaUIsdURBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixXQUFXLEtBQUssU0FBUztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQixFQUFFLHdCQUF3QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFnRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ3lFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0VBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekMsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDZEQUFRO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNO0FBQzFDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF1SEU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2thbmJhbnByby8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvZGlzdC9pbmRleC5qcz8xMjczIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy9oZWxwZXJzL2NyZWF0ZUNoYWluYWJsZVN0YXRlLnRzXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVTdGF0ZShjb25maWcpIHtcbiAgY29uc3QgeyBzdGF0ZSwgdHJhbnNhY3Rpb24gfSA9IGNvbmZpZztcbiAgbGV0IHsgc2VsZWN0aW9uIH0gPSB0cmFuc2FjdGlvbjtcbiAgbGV0IHsgZG9jIH0gPSB0cmFuc2FjdGlvbjtcbiAgbGV0IHsgc3RvcmVkTWFya3MgfSA9IHRyYW5zYWN0aW9uO1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGFwcGx5OiBzdGF0ZS5hcHBseS5iaW5kKHN0YXRlKSxcbiAgICBhcHBseVRyYW5zYWN0aW9uOiBzdGF0ZS5hcHBseVRyYW5zYWN0aW9uLmJpbmQoc3RhdGUpLFxuICAgIHBsdWdpbnM6IHN0YXRlLnBsdWdpbnMsXG4gICAgc2NoZW1hOiBzdGF0ZS5zY2hlbWEsXG4gICAgcmVjb25maWd1cmU6IHN0YXRlLnJlY29uZmlndXJlLmJpbmQoc3RhdGUpLFxuICAgIHRvSlNPTjogc3RhdGUudG9KU09OLmJpbmQoc3RhdGUpLFxuICAgIGdldCBzdG9yZWRNYXJrcygpIHtcbiAgICAgIHJldHVybiBzdG9yZWRNYXJrcztcbiAgICB9LFxuICAgIGdldCBzZWxlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH0sXG4gICAgZ2V0IGRvYygpIHtcbiAgICAgIHJldHVybiBkb2M7XG4gICAgfSxcbiAgICBnZXQgdHIoKSB7XG4gICAgICBzZWxlY3Rpb24gPSB0cmFuc2FjdGlvbi5zZWxlY3Rpb247XG4gICAgICBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gICAgICBzdG9yZWRNYXJrcyA9IHRyYW5zYWN0aW9uLnN0b3JlZE1hcmtzO1xuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL0NvbW1hbmRNYW5hZ2VyLnRzXG52YXIgQ29tbWFuZE1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgdGhpcy5lZGl0b3IgPSBwcm9wcy5lZGl0b3I7XG4gICAgdGhpcy5yYXdDb21tYW5kcyA9IHRoaXMuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuY29tbWFuZHM7XG4gICAgdGhpcy5jdXN0b21TdGF0ZSA9IHByb3BzLnN0YXRlO1xuICB9XG4gIGdldCBoYXNDdXN0b21TdGF0ZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLmN1c3RvbVN0YXRlO1xuICB9XG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXN0b21TdGF0ZSB8fCB0aGlzLmVkaXRvci5zdGF0ZTtcbiAgfVxuICBnZXQgY29tbWFuZHMoKSB7XG4gICAgY29uc3QgeyByYXdDb21tYW5kcywgZWRpdG9yLCBzdGF0ZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcbiAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZTtcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0cik7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kMl0pID0+IHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNvbW1hbmQyKC4uLmFyZ3MpKHByb3BzKTtcbiAgICAgICAgICBpZiAoIXRyLmdldE1ldGEoXCJwcmV2ZW50RGlzcGF0Y2hcIikgJiYgIXRoaXMuaGFzQ3VzdG9tU3RhdGUpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBbbmFtZSwgbWV0aG9kXTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBnZXQgY2hhaW4oKSB7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4oKTtcbiAgfVxuICBnZXQgY2FuKCkge1xuICAgIHJldHVybiAoKSA9PiB0aGlzLmNyZWF0ZUNhbigpO1xuICB9XG4gIGNyZWF0ZUNoYWluKHN0YXJ0VHIsIHNob3VsZERpc3BhdGNoID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3I7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gW107XG4gICAgY29uc3QgaGFzU3RhcnRUcmFuc2FjdGlvbiA9ICEhc3RhcnRUcjtcbiAgICBjb25zdCB0ciA9IHN0YXJ0VHIgfHwgc3RhdGUudHI7XG4gICAgY29uc3QgcnVuMyA9ICgpID0+IHtcbiAgICAgIGlmICghaGFzU3RhcnRUcmFuc2FjdGlvbiAmJiBzaG91bGREaXNwYXRjaCAmJiAhdHIuZ2V0TWV0YShcInByZXZlbnREaXNwYXRjaFwiKSAmJiAhdGhpcy5oYXNDdXN0b21TdGF0ZSkge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxsYmFja3MuZXZlcnkoKGNhbGxiYWNrKSA9PiBjYWxsYmFjayA9PT0gdHJ1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBjaGFpbiA9IHtcbiAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmQyXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNoYWluZWRDb21tYW5kID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyLCBzaG91bGREaXNwYXRjaCk7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNvbW1hbmQyKC4uLmFyZ3MpKHByb3BzKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBbbmFtZSwgY2hhaW5lZENvbW1hbmRdO1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIHJ1bjogcnVuM1xuICAgIH07XG4gICAgcmV0dXJuIGNoYWluO1xuICB9XG4gIGNyZWF0ZUNhbihzdGFydFRyKSB7XG4gICAgY29uc3QgeyByYXdDb21tYW5kcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgY29uc3QgZGlzcGF0Y2ggPSBmYWxzZTtcbiAgICBjb25zdCB0ciA9IHN0YXJ0VHIgfHwgc3RhdGUudHI7XG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIsIGRpc3BhdGNoKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRDb21tYW5kcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kMl0pID0+IHtcbiAgICAgICAgcmV0dXJuIFtuYW1lLCAoLi4uYXJncykgPT4gY29tbWFuZDIoLi4uYXJncykoeyAuLi5wcm9wcywgZGlzcGF0Y2g6IHZvaWQgMCB9KV07XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZvcm1hdHRlZENvbW1hbmRzLFxuICAgICAgY2hhaW46ICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4odHIsIGRpc3BhdGNoKVxuICAgIH07XG4gIH1cbiAgYnVpbGRQcm9wcyh0ciwgc2hvdWxkRGlzcGF0Y2ggPSB0cnVlKSB7XG4gICAgY29uc3QgeyByYXdDb21tYW5kcywgZWRpdG9yLCBzdGF0ZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIHRyLFxuICAgICAgZWRpdG9yLFxuICAgICAgdmlldyxcbiAgICAgIHN0YXRlOiBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICB0cmFuc2FjdGlvbjogdHJcbiAgICAgIH0pLFxuICAgICAgZGlzcGF0Y2g6IHNob3VsZERpc3BhdGNoID8gKCkgPT4gdm9pZCAwIDogdm9pZCAwLFxuICAgICAgY2hhaW46ICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4odHIsIHNob3VsZERpc3BhdGNoKSxcbiAgICAgIGNhbjogKCkgPT4gdGhpcy5jcmVhdGVDYW4odHIpLFxuICAgICAgZ2V0IGNvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kMl0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbbmFtZSwgKC4uLmFyZ3MpID0+IGNvbW1hbmQyKC4uLmFyZ3MpKHByb3BzKV07XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBwcm9wcztcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1hbmRzL2luZGV4LnRzXG52YXIgY29tbWFuZHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY29tbWFuZHNfZXhwb3J0cywge1xuICBibHVyOiAoKSA9PiBibHVyLFxuICBjbGVhckNvbnRlbnQ6ICgpID0+IGNsZWFyQ29udGVudCxcbiAgY2xlYXJOb2RlczogKCkgPT4gY2xlYXJOb2RlcyxcbiAgY29tbWFuZDogKCkgPT4gY29tbWFuZCxcbiAgY3JlYXRlUGFyYWdyYXBoTmVhcjogKCkgPT4gY3JlYXRlUGFyYWdyYXBoTmVhcixcbiAgY3V0OiAoKSA9PiBjdXQsXG4gIGRlbGV0ZUN1cnJlbnROb2RlOiAoKSA9PiBkZWxldGVDdXJyZW50Tm9kZSxcbiAgZGVsZXRlTm9kZTogKCkgPT4gZGVsZXRlTm9kZSxcbiAgZGVsZXRlUmFuZ2U6ICgpID0+IGRlbGV0ZVJhbmdlLFxuICBkZWxldGVTZWxlY3Rpb246ICgpID0+IGRlbGV0ZVNlbGVjdGlvbixcbiAgZW50ZXI6ICgpID0+IGVudGVyLFxuICBleGl0Q29kZTogKCkgPT4gZXhpdENvZGUsXG4gIGV4dGVuZE1hcmtSYW5nZTogKCkgPT4gZXh0ZW5kTWFya1JhbmdlLFxuICBmaXJzdDogKCkgPT4gZmlyc3QsXG4gIGZvY3VzOiAoKSA9PiBmb2N1cyxcbiAgZm9yRWFjaDogKCkgPT4gZm9yRWFjaCxcbiAgaW5zZXJ0Q29udGVudDogKCkgPT4gaW5zZXJ0Q29udGVudCxcbiAgaW5zZXJ0Q29udGVudEF0OiAoKSA9PiBpbnNlcnRDb250ZW50QXQsXG4gIGpvaW5CYWNrd2FyZDogKCkgPT4gam9pbkJhY2t3YXJkLFxuICBqb2luRG93bjogKCkgPT4gam9pbkRvd24sXG4gIGpvaW5Gb3J3YXJkOiAoKSA9PiBqb2luRm9yd2FyZCxcbiAgam9pbkl0ZW1CYWNrd2FyZDogKCkgPT4gam9pbkl0ZW1CYWNrd2FyZCxcbiAgam9pbkl0ZW1Gb3J3YXJkOiAoKSA9PiBqb2luSXRlbUZvcndhcmQsXG4gIGpvaW5UZXh0YmxvY2tCYWNrd2FyZDogKCkgPT4gam9pblRleHRibG9ja0JhY2t3YXJkLFxuICBqb2luVGV4dGJsb2NrRm9yd2FyZDogKCkgPT4gam9pblRleHRibG9ja0ZvcndhcmQsXG4gIGpvaW5VcDogKCkgPT4gam9pblVwLFxuICBrZXlib2FyZFNob3J0Y3V0OiAoKSA9PiBrZXlib2FyZFNob3J0Y3V0LFxuICBsaWZ0OiAoKSA9PiBsaWZ0LFxuICBsaWZ0RW1wdHlCbG9jazogKCkgPT4gbGlmdEVtcHR5QmxvY2ssXG4gIGxpZnRMaXN0SXRlbTogKCkgPT4gbGlmdExpc3RJdGVtLFxuICBuZXdsaW5lSW5Db2RlOiAoKSA9PiBuZXdsaW5lSW5Db2RlLFxuICByZXNldEF0dHJpYnV0ZXM6ICgpID0+IHJlc2V0QXR0cmlidXRlcyxcbiAgc2Nyb2xsSW50b1ZpZXc6ICgpID0+IHNjcm9sbEludG9WaWV3LFxuICBzZWxlY3RBbGw6ICgpID0+IHNlbGVjdEFsbCxcbiAgc2VsZWN0Tm9kZUJhY2t3YXJkOiAoKSA9PiBzZWxlY3ROb2RlQmFja3dhcmQsXG4gIHNlbGVjdE5vZGVGb3J3YXJkOiAoKSA9PiBzZWxlY3ROb2RlRm9yd2FyZCxcbiAgc2VsZWN0UGFyZW50Tm9kZTogKCkgPT4gc2VsZWN0UGFyZW50Tm9kZSxcbiAgc2VsZWN0VGV4dGJsb2NrRW5kOiAoKSA9PiBzZWxlY3RUZXh0YmxvY2tFbmQsXG4gIHNlbGVjdFRleHRibG9ja1N0YXJ0OiAoKSA9PiBzZWxlY3RUZXh0YmxvY2tTdGFydCxcbiAgc2V0Q29udGVudDogKCkgPT4gc2V0Q29udGVudCxcbiAgc2V0TWFyazogKCkgPT4gc2V0TWFyayxcbiAgc2V0TWV0YTogKCkgPT4gc2V0TWV0YSxcbiAgc2V0Tm9kZTogKCkgPT4gc2V0Tm9kZSxcbiAgc2V0Tm9kZVNlbGVjdGlvbjogKCkgPT4gc2V0Tm9kZVNlbGVjdGlvbixcbiAgc2V0VGV4dERpcmVjdGlvbjogKCkgPT4gc2V0VGV4dERpcmVjdGlvbixcbiAgc2V0VGV4dFNlbGVjdGlvbjogKCkgPT4gc2V0VGV4dFNlbGVjdGlvbixcbiAgc2lua0xpc3RJdGVtOiAoKSA9PiBzaW5rTGlzdEl0ZW0sXG4gIHNwbGl0QmxvY2s6ICgpID0+IHNwbGl0QmxvY2ssXG4gIHNwbGl0TGlzdEl0ZW06ICgpID0+IHNwbGl0TGlzdEl0ZW0sXG4gIHRvZ2dsZUxpc3Q6ICgpID0+IHRvZ2dsZUxpc3QsXG4gIHRvZ2dsZU1hcms6ICgpID0+IHRvZ2dsZU1hcmssXG4gIHRvZ2dsZU5vZGU6ICgpID0+IHRvZ2dsZU5vZGUsXG4gIHRvZ2dsZVdyYXA6ICgpID0+IHRvZ2dsZVdyYXAsXG4gIHVuZG9JbnB1dFJ1bGU6ICgpID0+IHVuZG9JbnB1dFJ1bGUsXG4gIHVuc2V0QWxsTWFya3M6ICgpID0+IHVuc2V0QWxsTWFya3MsXG4gIHVuc2V0TWFyazogKCkgPT4gdW5zZXRNYXJrLFxuICB1bnNldFRleHREaXJlY3Rpb246ICgpID0+IHVuc2V0VGV4dERpcmVjdGlvbixcbiAgdXBkYXRlQXR0cmlidXRlczogKCkgPT4gdXBkYXRlQXR0cmlidXRlcyxcbiAgd3JhcEluOiAoKSA9PiB3cmFwSW4sXG4gIHdyYXBJbkxpc3Q6ICgpID0+IHdyYXBJbkxpc3Rcbn0pO1xuXG4vLyBzcmMvY29tbWFuZHMvYmx1ci50c1xudmFyIGJsdXIgPSAoKSA9PiAoeyBlZGl0b3IsIHZpZXcgfSkgPT4ge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgO1xuICAgICAgdmlldy5kb20uYmx1cigpO1xuICAgICAgKF9hID0gd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jbGVhckNvbnRlbnQudHNcbnZhciBjbGVhckNvbnRlbnQgPSAoZW1pdFVwZGF0ZSA9IHRydWUpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLnNldENvbnRlbnQoXCJcIiwgeyBlbWl0VXBkYXRlIH0pO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2NsZWFyTm9kZXMudHNcbmltcG9ydCB7IGxpZnRUYXJnZXQgfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbnZhciBjbGVhck5vZGVzID0gKCkgPT4gKHsgc3RhdGUsIHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgaWYgKCFkaXNwYXRjaCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAobm9kZS50eXBlLmlzVGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IGRvYywgbWFwcGluZyB9ID0gdHI7XG4gICAgICBjb25zdCAkbWFwcGVkRnJvbSA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHBvcykpO1xuICAgICAgY29uc3QgJG1hcHBlZFRvID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zICsgbm9kZS5ub2RlU2l6ZSkpO1xuICAgICAgY29uc3Qgbm9kZVJhbmdlID0gJG1hcHBlZEZyb20uYmxvY2tSYW5nZSgkbWFwcGVkVG8pO1xuICAgICAgaWYgKCFub2RlUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0TGlmdERlcHRoID0gbGlmdFRhcmdldChub2RlUmFuZ2UpO1xuICAgICAgaWYgKG5vZGUudHlwZS5pc1RleHRibG9jaykge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRUeXBlIH0gPSAkbWFwcGVkRnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJG1hcHBlZEZyb20uaW5kZXgoKSk7XG4gICAgICAgIHRyLnNldE5vZGVNYXJrdXAobm9kZVJhbmdlLnN0YXJ0LCBkZWZhdWx0VHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0TGlmdERlcHRoIHx8IHRhcmdldExpZnREZXB0aCA9PT0gMCkge1xuICAgICAgICB0ci5saWZ0KG5vZGVSYW5nZSwgdGFyZ2V0TGlmdERlcHRoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2NvbW1hbmQudHNcbnZhciBjb21tYW5kID0gKGZuKSA9PiAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGZuKHByb3BzKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jcmVhdGVQYXJhZ3JhcGhOZWFyLnRzXG5pbXBvcnQgeyBjcmVhdGVQYXJhZ3JhcGhOZWFyIGFzIG9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhciB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgY3JlYXRlUGFyYWdyYXBoTmVhciA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbENyZWF0ZVBhcmFncmFwaE5lYXIoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jdXQudHNcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIGN1dCA9IChvcmlnaW5SYW5nZSwgdGFyZ2V0UG9zKSA9PiAoeyBlZGl0b3IsIHRyIH0pID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yO1xuICBjb25zdCBjb250ZW50U2xpY2UgPSBzdGF0ZS5kb2Muc2xpY2Uob3JpZ2luUmFuZ2UuZnJvbSwgb3JpZ2luUmFuZ2UudG8pO1xuICB0ci5kZWxldGVSYW5nZShvcmlnaW5SYW5nZS5mcm9tLCBvcmlnaW5SYW5nZS50byk7XG4gIGNvbnN0IG5ld1BvcyA9IHRyLm1hcHBpbmcubWFwKHRhcmdldFBvcyk7XG4gIHRyLmluc2VydChuZXdQb3MsIGNvbnRlbnRTbGljZS5jb250ZW50KTtcbiAgdHIuc2V0U2VsZWN0aW9uKG5ldyBUZXh0U2VsZWN0aW9uKHRyLmRvYy5yZXNvbHZlKE1hdGgubWF4KG5ld1BvcyAtIDEsIDApKSkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9kZWxldGVDdXJyZW50Tm9kZS50c1xudmFyIGRlbGV0ZUN1cnJlbnROb2RlID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuICBjb25zdCBjdXJyZW50Tm9kZSA9IHNlbGVjdGlvbi4kYW5jaG9yLm5vZGUoKTtcbiAgaWYgKGN1cnJlbnROb2RlLmNvbnRlbnQuc2l6ZSA+IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yO1xuICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGggLT0gMSkge1xuICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoZGVwdGgpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IGN1cnJlbnROb2RlLnR5cGUpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCBmcm9tID0gJHBvcy5iZWZvcmUoZGVwdGgpO1xuICAgICAgICBjb25zdCB0byA9ICRwb3MuYWZ0ZXIoZGVwdGgpO1xuICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gc3JjL2hlbHBlcnMvZ2V0Tm9kZVR5cGUudHNcbmZ1bmN0aW9uIGdldE5vZGVUeXBlKG5hbWVPclR5cGUsIHNjaGVtYSkge1xuICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoIXNjaGVtYS5ub2Rlc1tuYW1lT3JUeXBlXSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFRoZXJlIGlzIG5vIG5vZGUgdHlwZSBuYW1lZCAnJHtuYW1lT3JUeXBlfScuIE1heWJlIHlvdSBmb3Jnb3QgdG8gYWRkIHRoZSBleHRlbnNpb24/YCk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWEubm9kZXNbbmFtZU9yVHlwZV07XG4gIH1cbiAgcmV0dXJuIG5hbWVPclR5cGU7XG59XG5cbi8vIHNyYy9jb21tYW5kcy9kZWxldGVOb2RlLnRzXG52YXIgZGVsZXRlTm9kZSA9ICh0eXBlT3JOYW1lKSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0ICRwb3MgPSB0ci5zZWxlY3Rpb24uJGFuY2hvcjtcbiAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcbiAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKTtcbiAgICBpZiAobm9kZS50eXBlID09PSB0eXBlKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKTtcbiAgICAgICAgY29uc3QgdG8gPSAkcG9zLmFmdGVyKGRlcHRoKTtcbiAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9kZWxldGVSYW5nZS50c1xudmFyIGRlbGV0ZVJhbmdlID0gKHJhbmdlKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIuZGVsZXRlKGZyb20sIHRvKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9kZWxldGVTZWxlY3Rpb24udHNcbmltcG9ydCB7IGRlbGV0ZVNlbGVjdGlvbiBhcyBvcmlnaW5hbERlbGV0ZVNlbGVjdGlvbiB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgZGVsZXRlU2VsZWN0aW9uID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsRGVsZXRlU2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvZW50ZXIudHNcbnZhciBlbnRlciA9ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLmtleWJvYXJkU2hvcnRjdXQoXCJFbnRlclwiKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9leGl0Q29kZS50c1xuaW1wb3J0IHsgZXhpdENvZGUgYXMgb3JpZ2luYWxFeGl0Q29kZSB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgZXhpdENvZGUgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxFeGl0Q29kZShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2V4dGVuZE1hcmtSYW5nZS50c1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uMiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5cbi8vIHNyYy91dGlsaXRpZXMvaXNSZWdFeHAudHNcbmZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgUmVnRXhwXVwiO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL29iamVjdEluY2x1ZGVzLnRzXG5mdW5jdGlvbiBvYmplY3RJbmNsdWRlcyhvYmplY3QxLCBvYmplY3QyLCBvcHRpb25zID0geyBzdHJpY3Q6IHRydWUgfSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0Mik7XG4gIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4ga2V5cy5ldmVyeSgoa2V5KSA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV07XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cChvYmplY3QyW2tleV0pKSB7XG4gICAgICByZXR1cm4gb2JqZWN0MltrZXldLnRlc3Qob2JqZWN0MVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDJba2V5XSA9PT0gb2JqZWN0MVtrZXldO1xuICB9KTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0TWFya1JhbmdlLnRzXG5mdW5jdGlvbiBmaW5kTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgcmV0dXJuIG1hcmtzLmZpbmQoKGl0ZW0pID0+IHtcbiAgICByZXR1cm4gaXRlbS50eXBlID09PSB0eXBlICYmIG9iamVjdEluY2x1ZGVzKFxuICAgICAgLy8gT25seSBjaGVjayBlcXVhbGl0eSBmb3IgdGhlIGF0dHJpYnV0ZXMgdGhhdCBhcmUgcHJvdmlkZWRcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5tYXAoKGspID0+IFtrLCBpdGVtLmF0dHJzW2tdXSkpLFxuICAgICAgYXR0cmlidXRlc1xuICAgICk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNNYXJrSW5TZXQobWFya3MsIHR5cGUsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICByZXR1cm4gISFmaW5kTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbn1cbmZ1bmN0aW9uIGdldE1hcmtSYW5nZSgkcG9zLCB0eXBlLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBfYTtcbiAgaWYgKCEkcG9zIHx8ICF0eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFydCA9ICRwb3MucGFyZW50LmNoaWxkQWZ0ZXIoJHBvcy5wYXJlbnRPZmZzZXQpO1xuICBpZiAoIXN0YXJ0Lm5vZGUgfHwgIXN0YXJ0Lm5vZGUubWFya3Muc29tZSgobWFyazIpID0+IG1hcmsyLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgc3RhcnQgPSAkcG9zLnBhcmVudC5jaGlsZEJlZm9yZSgkcG9zLnBhcmVudE9mZnNldCk7XG4gIH1cbiAgaWYgKCFzdGFydC5ub2RlIHx8ICFzdGFydC5ub2RlLm1hcmtzLnNvbWUoKG1hcmsyKSA9PiBtYXJrMi50eXBlID09PSB0eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCAoKF9hID0gc3RhcnQubm9kZS5tYXJrc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmF0dHJzKTtcbiAgY29uc3QgbWFyayA9IGZpbmRNYXJrSW5TZXQoWy4uLnN0YXJ0Lm5vZGUubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKCFtYXJrKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaW5kZXg7XG4gIGxldCBzdGFydFBvcyA9ICRwb3Muc3RhcnQoKSArIHN0YXJ0Lm9mZnNldDtcbiAgbGV0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIDE7XG4gIGxldCBlbmRQb3MgPSBzdGFydFBvcyArIHN0YXJ0Lm5vZGUubm9kZVNpemU7XG4gIHdoaWxlIChzdGFydEluZGV4ID4gMCAmJiBpc01hcmtJblNldChbLi4uJHBvcy5wYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcykpIHtcbiAgICBzdGFydEluZGV4IC09IDE7XG4gICAgc3RhcnRQb3MgLT0gJHBvcy5wYXJlbnQuY2hpbGQoc3RhcnRJbmRleCkubm9kZVNpemU7XG4gIH1cbiAgd2hpbGUgKGVuZEluZGV4IDwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCAmJiBpc01hcmtJblNldChbLi4uJHBvcy5wYXJlbnQuY2hpbGQoZW5kSW5kZXgpLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcykpIHtcbiAgICBlbmRQb3MgKz0gJHBvcy5wYXJlbnQuY2hpbGQoZW5kSW5kZXgpLm5vZGVTaXplO1xuICAgIGVuZEluZGV4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmcm9tOiBzdGFydFBvcyxcbiAgICB0bzogZW5kUG9zXG4gIH07XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldE1hcmtUeXBlLnRzXG5mdW5jdGlvbiBnZXRNYXJrVHlwZShuYW1lT3JUeXBlLCBzY2hlbWEpIHtcbiAgaWYgKHR5cGVvZiBuYW1lT3JUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKCFzY2hlbWEubWFya3NbbmFtZU9yVHlwZV0pIHtcbiAgICAgIHRocm93IEVycm9yKGBUaGVyZSBpcyBubyBtYXJrIHR5cGUgbmFtZWQgJyR7bmFtZU9yVHlwZX0nLiBNYXliZSB5b3UgZm9yZ290IHRvIGFkZCB0aGUgZXh0ZW5zaW9uP2ApO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hLm1hcmtzW25hbWVPclR5cGVdO1xuICB9XG4gIHJldHVybiBuYW1lT3JUeXBlO1xufVxuXG4vLyBzcmMvY29tbWFuZHMvZXh0ZW5kTWFya1JhbmdlLnRzXG52YXIgZXh0ZW5kTWFya1JhbmdlID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSB0cjtcbiAgY29uc3QgeyAkZnJvbSwgZnJvbSwgdG8gfSA9IHNlbGVjdGlvbjtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJGZyb20sIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgIGlmIChyYW5nZSAmJiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8pIHtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IFRleHRTZWxlY3Rpb24yLmNyZWF0ZShkb2MsIHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcbiAgICAgIHRyLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9maXJzdC50c1xudmFyIGZpcnN0ID0gKGNvbW1hbmRzKSA9PiAocHJvcHMpID0+IHtcbiAgY29uc3QgaXRlbXMgPSB0eXBlb2YgY29tbWFuZHMgPT09IFwiZnVuY3Rpb25cIiA/IGNvbW1hbmRzKHByb3BzKSA6IGNvbW1hbmRzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGl0ZW1zW2ldKHByb3BzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIHNyYy9oZWxwZXJzL2lzVGV4dFNlbGVjdGlvbi50c1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uMyB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5mdW5jdGlvbiBpc1RleHRTZWxlY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbjM7XG59XG5cbi8vIHNyYy9oZWxwZXJzL3Jlc29sdmVGb2N1c1Bvc2l0aW9uLnRzXG5pbXBvcnQgeyBTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvbjQgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuXG4vLyBzcmMvdXRpbGl0aWVzL21pbk1heC50c1xuZnVuY3Rpb24gbWluTWF4KHZhbHVlID0gMCwgbWluID0gMCwgbWF4ID0gMCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL3Jlc29sdmVGb2N1c1Bvc2l0aW9uLnRzXG5mdW5jdGlvbiByZXNvbHZlRm9jdXNQb3NpdGlvbihkb2MsIHBvc2l0aW9uID0gbnVsbCkge1xuICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc2VsZWN0aW9uQXRTdGFydCA9IFNlbGVjdGlvbi5hdFN0YXJ0KGRvYyk7XG4gIGNvbnN0IHNlbGVjdGlvbkF0RW5kID0gU2VsZWN0aW9uLmF0RW5kKGRvYyk7XG4gIGlmIChwb3NpdGlvbiA9PT0gXCJzdGFydFwiIHx8IHBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbkF0U3RhcnQ7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSBcImVuZFwiKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbkF0RW5kO1xuICB9XG4gIGNvbnN0IG1pblBvcyA9IHNlbGVjdGlvbkF0U3RhcnQuZnJvbTtcbiAgY29uc3QgbWF4UG9zID0gc2VsZWN0aW9uQXRFbmQudG87XG4gIGlmIChwb3NpdGlvbiA9PT0gXCJhbGxcIikge1xuICAgIHJldHVybiBUZXh0U2VsZWN0aW9uNC5jcmVhdGUoZG9jLCBtaW5NYXgoMCwgbWluUG9zLCBtYXhQb3MpLCBtaW5NYXgoZG9jLmNvbnRlbnQuc2l6ZSwgbWluUG9zLCBtYXhQb3MpKTtcbiAgfVxuICByZXR1cm4gVGV4dFNlbGVjdGlvbjQuY3JlYXRlKGRvYywgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcyksIG1pbk1heChwb3NpdGlvbiwgbWluUG9zLCBtYXhQb3MpKTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9pc0FuZHJvaWQudHNcbmZ1bmN0aW9uIGlzQW5kcm9pZCgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gXCJBbmRyb2lkXCIgfHwgL2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2lzaU9TLnRzXG5mdW5jdGlvbiBpc2lPUygpIHtcbiAgcmV0dXJuIFtcImlQYWQgU2ltdWxhdG9yXCIsIFwiaVBob25lIFNpbXVsYXRvclwiLCBcImlQb2QgU2ltdWxhdG9yXCIsIFwiaVBhZFwiLCBcImlQaG9uZVwiLCBcImlQb2RcIl0uaW5jbHVkZXMobmF2aWdhdG9yLnBsYXRmb3JtKSB8fCAvLyBpUGFkIG9uIGlPUyAxMyBkZXRlY3Rpb25cbiAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIk1hY1wiKSAmJiBcIm9udG91Y2hlbmRcIiBpbiBkb2N1bWVudDtcbn1cblxuLy8gc3JjL2NvbW1hbmRzL2ZvY3VzLnRzXG52YXIgZm9jdXMgPSAocG9zaXRpb24gPSBudWxsLCBvcHRpb25zID0ge30pID0+ICh7IGVkaXRvciwgdmlldywgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgb3B0aW9ucyA9IHtcbiAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IGRlbGF5ZWRGb2N1cyA9ICgpID0+IHtcbiAgICBpZiAoaXNpT1MoKSB8fCBpc0FuZHJvaWQoKSkge1xuICAgICAgO1xuICAgICAgdmlldy5kb20uZm9jdXMoKTtcbiAgICB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICBlZGl0b3IuY29tbWFuZHMuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBpZiAodmlldy5oYXNGb2N1cygpICYmIHBvc2l0aW9uID09PSBudWxsIHx8IHBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChkaXNwYXRjaCAmJiBwb3NpdGlvbiA9PT0gbnVsbCAmJiAhaXNUZXh0U2VsZWN0aW9uKGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24pKSB7XG4gICAgZGVsYXllZEZvY3VzKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qgc2VsZWN0aW9uID0gcmVzb2x2ZUZvY3VzUG9zaXRpb24odHIuZG9jLCBwb3NpdGlvbikgfHwgZWRpdG9yLnN0YXRlLnNlbGVjdGlvbjtcbiAgY29uc3QgaXNTYW1lU2VsZWN0aW9uID0gZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5lcShzZWxlY3Rpb24pO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBpZiAoIWlzU2FtZVNlbGVjdGlvbikge1xuICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgfVxuICAgIGlmIChpc1NhbWVTZWxlY3Rpb24gJiYgdHIuc3RvcmVkTWFya3MpIHtcbiAgICAgIHRyLnNldFN0b3JlZE1hcmtzKHRyLnN0b3JlZE1hcmtzKTtcbiAgICB9XG4gICAgZGVsYXllZEZvY3VzKCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvZm9yRWFjaC50c1xudmFyIGZvckVhY2ggPSAoaXRlbXMsIGZuKSA9PiAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGl0ZW1zLmV2ZXJ5KChpdGVtLCBpbmRleCkgPT4gZm4oaXRlbSwgeyAuLi5wcm9wcywgaW5kZXggfSkpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2luc2VydENvbnRlbnQudHNcbnZhciBpbnNlcnRDb250ZW50ID0gKHZhbHVlLCBvcHRpb25zKSA9PiAoeyB0ciwgY29tbWFuZHMgfSkgPT4ge1xuICByZXR1cm4gY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KHsgZnJvbTogdHIuc2VsZWN0aW9uLmZyb20sIHRvOiB0ci5zZWxlY3Rpb24udG8gfSwgdmFsdWUsIG9wdGlvbnMpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2luc2VydENvbnRlbnRBdC50c1xuaW1wb3J0IHsgRnJhZ21lbnQgYXMgRnJhZ21lbnQyIH0gZnJvbSBcIkB0aXB0YXAvcG0vbW9kZWxcIjtcblxuLy8gc3JjL2hlbHBlcnMvY3JlYXRlTm9kZUZyb21Db250ZW50LnRzXG5pbXBvcnQgeyBET01QYXJzZXIsIEZyYWdtZW50LCBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgU2NoZW1hIH0gZnJvbSBcIkB0aXB0YXAvcG0vbW9kZWxcIjtcblxuLy8gc3JjL3V0aWxpdGllcy9lbGVtZW50RnJvbVN0cmluZy50c1xudmFyIHJlbW92ZVdoaXRlc3BhY2VzID0gKG5vZGUpID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAzICYmIGNoaWxkLm5vZGVWYWx1ZSAmJiAvXihcXG5cXHNcXHN8XFxuKSQvLnRlc3QoY2hpbGQubm9kZVZhbHVlKSkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgcmVtb3ZlV2hpdGVzcGFjZXMoY2hpbGQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn07XG5mdW5jdGlvbiBlbGVtZW50RnJvbVN0cmluZyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlt0aXB0YXAgZXJyb3JdOiB0aGVyZSBpcyBubyB3aW5kb3cgb2JqZWN0IGF2YWlsYWJsZSwgc28gdGhpcyBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZFwiKTtcbiAgfVxuICBjb25zdCB3cmFwcGVkVmFsdWUgPSBgPGJvZHk+JHt2YWx1ZX08L2JvZHk+YDtcbiAgY29uc3QgaHRtbCA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHdyYXBwZWRWYWx1ZSwgXCJ0ZXh0L2h0bWxcIikuYm9keTtcbiAgcmV0dXJuIHJlbW92ZVdoaXRlc3BhY2VzKGh0bWwpO1xufVxuXG4vLyBzcmMvaGVscGVycy9jcmVhdGVOb2RlRnJvbUNvbnRlbnQudHNcbmZ1bmN0aW9uIGNyZWF0ZU5vZGVGcm9tQ29udGVudChjb250ZW50LCBzY2hlbWEsIG9wdGlvbnMpIHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBQcm9zZU1pcnJvck5vZGUgfHwgY29udGVudCBpbnN0YW5jZW9mIEZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgb3B0aW9ucyA9IHtcbiAgICBzbGljZTogdHJ1ZSxcbiAgICBwYXJzZU9wdGlvbnM6IHt9LFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3QgaXNKU09OQ29udGVudCA9IHR5cGVvZiBjb250ZW50ID09PSBcIm9iamVjdFwiICYmIGNvbnRlbnQgIT09IG51bGw7XG4gIGNvbnN0IGlzVGV4dENvbnRlbnQgPSB0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIjtcbiAgaWYgKGlzSlNPTkNvbnRlbnQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaXNBcnJheUNvbnRlbnQgPSBBcnJheS5pc0FycmF5KGNvbnRlbnQpICYmIGNvbnRlbnQubGVuZ3RoID4gMDtcbiAgICAgIGlmIChpc0FycmF5Q29udGVudCkge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbUFycmF5KGNvbnRlbnQubWFwKChpdGVtKSA9PiBzY2hlbWEubm9kZUZyb21KU09OKGl0ZW0pKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gc2NoZW1hLm5vZGVGcm9tSlNPTihjb250ZW50KTtcbiAgICAgIGlmIChvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCkge1xuICAgICAgICBub2RlLmNoZWNrKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlt0aXB0YXAgZXJyb3JdOiBJbnZhbGlkIEpTT04gY29udGVudFwiLCB7IGNhdXNlOiBlcnJvciB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIlt0aXB0YXAgd2Fybl06IEludmFsaWQgY29udGVudC5cIiwgXCJQYXNzZWQgdmFsdWU6XCIsIGNvbnRlbnQsIFwiRXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoXCJcIiwgc2NoZW1hLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVGV4dENvbnRlbnQpIHtcbiAgICBpZiAob3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpIHtcbiAgICAgIGxldCBoYXNJbnZhbGlkQ29udGVudCA9IGZhbHNlO1xuICAgICAgbGV0IGludmFsaWRDb250ZW50ID0gXCJcIjtcbiAgICAgIGNvbnN0IGNvbnRlbnRDaGVja1NjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICAgICAgICB0b3BOb2RlOiBzY2hlbWEuc3BlYy50b3BOb2RlLFxuICAgICAgICBtYXJrczogc2NoZW1hLnNwZWMubWFya3MsXG4gICAgICAgIC8vIFByb3NlbWlycm9yJ3Mgc2NoZW1hcyBhcmUgZXhlY3V0ZWQgc3VjaCB0aGF0OiB0aGUgbGFzdCB0byBleGVjdXRlLCBtYXRjaGVzIGxhc3RcbiAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHdlIGNhbiBhZGQgYSBjYXRjaC1hbGwgbm9kZSBhdCB0aGUgZW5kIG9mIHRoZSBzY2hlbWEgdG8gY2F0Y2ggYW55IGNvbnRlbnQgdGhhdCB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGVcbiAgICAgICAgbm9kZXM6IHNjaGVtYS5zcGVjLm5vZGVzLmFwcGVuZCh7XG4gICAgICAgICAgX190aXB0YXBfX3ByaXZhdGVfX3Vua25vd25fX2NhdGNoX19hbGxfX25vZGU6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICAgICAgICAgICAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6IFwiKlwiLFxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaGFzSW52YWxpZENvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgaW52YWxpZENvbnRlbnQgPSB0eXBlb2YgZSA9PT0gXCJzdHJpbmdcIiA/IGUgOiBlLm91dGVySFRNTDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKG9wdGlvbnMuc2xpY2UpIHtcbiAgICAgICAgRE9NUGFyc2VyLmZyb21TY2hlbWEoY29udGVudENoZWNrU2NoZW1hKS5wYXJzZVNsaWNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBET01QYXJzZXIuZnJvbVNjaGVtYShjb250ZW50Q2hlY2tTY2hlbWEpLnBhcnNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQgJiYgaGFzSW52YWxpZENvbnRlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSFRNTCBjb250ZW50XCIsIHtcbiAgICAgICAgICBjYXVzZTogbmV3IEVycm9yKGBJbnZhbGlkIGVsZW1lbnQgZm91bmQ6ICR7aW52YWxpZENvbnRlbnR9YClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlciA9IERPTVBhcnNlci5mcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgaWYgKG9wdGlvbnMuc2xpY2UpIHtcbiAgICAgIHJldHVybiBwYXJzZXIucGFyc2VTbGljZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpLmNvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIucGFyc2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KFwiXCIsIHNjaGVtYSwgb3B0aW9ucyk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL3NlbGVjdGlvblRvSW5zZXJ0aW9uRW5kLnRzXG5pbXBvcnQgeyBTZWxlY3Rpb24gYXMgU2VsZWN0aW9uMiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5pbXBvcnQgeyBSZXBsYWNlQXJvdW5kU3RlcCwgUmVwbGFjZVN0ZXAgfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbmZ1bmN0aW9uIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBzdGFydExlbiwgYmlhcykge1xuICBjb25zdCBsYXN0ID0gdHIuc3RlcHMubGVuZ3RoIC0gMTtcbiAgaWYgKGxhc3QgPCBzdGFydExlbikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdGVwID0gdHIuc3RlcHNbbGFzdF07XG4gIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCB8fCBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZUFyb3VuZFN0ZXApKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1hcCA9IHRyLm1hcHBpbmcubWFwc1tsYXN0XTtcbiAgbGV0IGVuZCA9IDA7XG4gIG1hcC5mb3JFYWNoKChfZnJvbSwgX3RvLCBfbmV3RnJvbSwgbmV3VG8pID0+IHtcbiAgICBpZiAoZW5kID09PSAwKSB7XG4gICAgICBlbmQgPSBuZXdUbztcbiAgICB9XG4gIH0pO1xuICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uMi5uZWFyKHRyLmRvYy5yZXNvbHZlKGVuZCksIGJpYXMpKTtcbn1cblxuLy8gc3JjL2NvbW1hbmRzL2luc2VydENvbnRlbnRBdC50c1xudmFyIGlzRnJhZ21lbnQgPSAobm9kZU9yRnJhZ21lbnQpID0+IHtcbiAgcmV0dXJuICEoXCJ0eXBlXCIgaW4gbm9kZU9yRnJhZ21lbnQpO1xufTtcbnZhciBpbnNlcnRDb250ZW50QXQgPSAocG9zaXRpb24sIHZhbHVlLCBvcHRpb25zKSA9PiAoeyB0ciwgZGlzcGF0Y2gsIGVkaXRvciB9KSA9PiB7XG4gIHZhciBfYTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHBhcnNlT3B0aW9uczogZWRpdG9yLm9wdGlvbnMucGFyc2VPcHRpb25zLFxuICAgICAgdXBkYXRlU2VsZWN0aW9uOiB0cnVlLFxuICAgICAgYXBwbHlJbnB1dFJ1bGVzOiBmYWxzZSxcbiAgICAgIGFwcGx5UGFzdGVSdWxlczogZmFsc2UsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBsZXQgY29udGVudDtcbiAgICBjb25zdCBlbWl0Q29udGVudEVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBlZGl0b3IuZW1pdChcImNvbnRlbnRFcnJvclwiLCB7XG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGRpc2FibGVDb2xsYWJvcmF0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKFwiY29sbGFib3JhdGlvblwiIGluIGVkaXRvci5zdG9yYWdlICYmIHR5cGVvZiBlZGl0b3Iuc3RvcmFnZS5jb2xsYWJvcmF0aW9uID09PSBcIm9iamVjdFwiICYmIGVkaXRvci5zdG9yYWdlLmNvbGxhYm9yYXRpb24pIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGVkaXRvci5zdG9yYWdlLmNvbGxhYm9yYXRpb24uaXNEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHBhcnNlT3B0aW9ucyA9IHtcbiAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogXCJmdWxsXCIsXG4gICAgICAuLi5vcHRpb25zLnBhcnNlT3B0aW9uc1xuICAgIH07XG4gICAgaWYgKCFvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCAmJiAhZWRpdG9yLm9wdGlvbnMuZW5hYmxlQ29udGVudENoZWNrICYmIGVkaXRvci5vcHRpb25zLmVtaXRDb250ZW50RXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNyZWF0ZU5vZGVGcm9tQ29udGVudCh2YWx1ZSwgZWRpdG9yLnNjaGVtYSwge1xuICAgICAgICAgIHBhcnNlT3B0aW9ucyxcbiAgICAgICAgICBlcnJvck9uSW52YWxpZENvbnRlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVtaXRDb250ZW50RXJyb3IoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb250ZW50ID0gY3JlYXRlTm9kZUZyb21Db250ZW50KHZhbHVlLCBlZGl0b3Iuc2NoZW1hLCB7XG4gICAgICAgIHBhcnNlT3B0aW9ucyxcbiAgICAgICAgZXJyb3JPbkludmFsaWRDb250ZW50OiAoX2EgPSBvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCkgIT0gbnVsbCA/IF9hIDogZWRpdG9yLm9wdGlvbnMuZW5hYmxlQ29udGVudENoZWNrXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlbWl0Q29udGVudEVycm9yKGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgeyBmcm9tLCB0byB9ID0gdHlwZW9mIHBvc2l0aW9uID09PSBcIm51bWJlclwiID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiB7IGZyb206IHBvc2l0aW9uLmZyb20sIHRvOiBwb3NpdGlvbi50byB9O1xuICAgIGxldCBpc09ubHlUZXh0Q29udGVudCA9IHRydWU7XG4gICAgbGV0IGlzT25seUJsb2NrQ29udGVudCA9IHRydWU7XG4gICAgY29uc3Qgbm9kZXMgPSBpc0ZyYWdtZW50KGNvbnRlbnQpID8gY29udGVudCA6IFtjb250ZW50XTtcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBub2RlLmNoZWNrKCk7XG4gICAgICBpc09ubHlUZXh0Q29udGVudCA9IGlzT25seVRleHRDb250ZW50ID8gbm9kZS5pc1RleHQgJiYgbm9kZS5tYXJrcy5sZW5ndGggPT09IDAgOiBmYWxzZTtcbiAgICAgIGlzT25seUJsb2NrQ29udGVudCA9IGlzT25seUJsb2NrQ29udGVudCA/IG5vZGUuaXNCbG9jayA6IGZhbHNlO1xuICAgIH0pO1xuICAgIGlmIChmcm9tID09PSB0byAmJiBpc09ubHlCbG9ja0NvbnRlbnQpIHtcbiAgICAgIGNvbnN0IHsgcGFyZW50IH0gPSB0ci5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICAgIGNvbnN0IGlzRW1wdHlUZXh0QmxvY2sgPSBwYXJlbnQuaXNUZXh0YmxvY2sgJiYgIXBhcmVudC50eXBlLnNwZWMuY29kZSAmJiAhcGFyZW50LmNoaWxkQ291bnQ7XG4gICAgICBpZiAoaXNFbXB0eVRleHRCbG9jaykge1xuICAgICAgICBmcm9tIC09IDE7XG4gICAgICAgIHRvICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBuZXdDb250ZW50O1xuICAgIGlmIChpc09ubHlUZXh0Q29udGVudCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZS5tYXAoKHYpID0+IHYudGV4dCB8fCBcIlwiKS5qb2luKFwiXCIpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZyYWdtZW50Mikge1xuICAgICAgICBsZXQgdGV4dCA9IFwiXCI7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICBpZiAobm9kZS50ZXh0KSB7XG4gICAgICAgICAgICB0ZXh0ICs9IG5vZGUudGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBuZXdDb250ZW50ID0gdGV4dDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICEhdmFsdWUgJiYgISF2YWx1ZS50ZXh0KSB7XG4gICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZS50ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3Q29udGVudCA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgdHIuaW5zZXJ0VGV4dChuZXdDb250ZW50LCBmcm9tLCB0byk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgY29uc3QgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICAgIGNvbnN0ICRmcm9tTm9kZSA9ICRmcm9tLm5vZGUoKTtcbiAgICAgIGNvbnN0IGZyb21TZWxlY3Rpb25BdFN0YXJ0ID0gJGZyb20ucGFyZW50T2Zmc2V0ID09PSAwO1xuICAgICAgY29uc3QgaXNUZXh0U2VsZWN0aW9uMiA9ICRmcm9tTm9kZS5pc1RleHQgfHwgJGZyb21Ob2RlLmlzVGV4dGJsb2NrO1xuICAgICAgY29uc3QgaGFzQ29udGVudCA9ICRmcm9tTm9kZS5jb250ZW50LnNpemUgPiAwO1xuICAgICAgaWYgKGZyb21TZWxlY3Rpb25BdFN0YXJ0ICYmIGlzVGV4dFNlbGVjdGlvbjIgJiYgaGFzQ29udGVudCkge1xuICAgICAgICBmcm9tID0gTWF0aC5tYXgoMCwgZnJvbSAtIDEpO1xuICAgICAgfVxuICAgICAgdHIucmVwbGFjZVdpdGgoZnJvbSwgdG8sIG5ld0NvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy51cGRhdGVTZWxlY3Rpb24pIHtcbiAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCB0ci5zdGVwcy5sZW5ndGggLSAxLCAtMSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFwcGx5SW5wdXRSdWxlcykge1xuICAgICAgdHIuc2V0TWV0YShcImFwcGx5SW5wdXRSdWxlc1wiLCB7IGZyb20sIHRleHQ6IG5ld0NvbnRlbnQgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFwcGx5UGFzdGVSdWxlcykge1xuICAgICAgdHIuc2V0TWV0YShcImFwcGx5UGFzdGVSdWxlc1wiLCB7IGZyb20sIHRleHQ6IG5ld0NvbnRlbnQgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2pvaW4udHNcbmltcG9ydCB7XG4gIGpvaW5CYWNrd2FyZCBhcyBvcmlnaW5hbEpvaW5CYWNrd2FyZCxcbiAgam9pbkRvd24gYXMgb3JpZ2luYWxKb2luRG93bixcbiAgam9pbkZvcndhcmQgYXMgb3JpZ2luYWxKb2luRm9yd2FyZCxcbiAgam9pblVwIGFzIG9yaWdpbmFsSm9pblVwXG59IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgam9pblVwID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pblVwKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xudmFyIGpvaW5Eb3duID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pbkRvd24oc3RhdGUsIGRpc3BhdGNoKTtcbn07XG52YXIgam9pbkJhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pbkJhY2t3YXJkKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xudmFyIGpvaW5Gb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pbkZvcndhcmQoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9qb2luSXRlbUJhY2t3YXJkLnRzXG5pbXBvcnQgeyBqb2luUG9pbnQgfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbnZhciBqb2luSXRlbUJhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCB0ciB9KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ucG9zLCAtMSk7XG4gICAgaWYgKHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHIuam9pbihwb2ludCwgMik7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBkaXNwYXRjaCh0cik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tYW5kcy9qb2luSXRlbUZvcndhcmQudHNcbmltcG9ydCB7IGpvaW5Qb2ludCBhcyBqb2luUG9pbnQyIH0gZnJvbSBcIkB0aXB0YXAvcG0vdHJhbnNmb3JtXCI7XG52YXIgam9pbkl0ZW1Gb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCB0ciB9KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcG9pbnQgPSBqb2luUG9pbnQyKHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgMSk7XG4gICAgaWYgKHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHIuam9pbihwb2ludCwgMik7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBkaXNwYXRjaCh0cik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tYW5kcy9qb2luVGV4dGJsb2NrQmFja3dhcmQudHNcbmltcG9ydCB7IGpvaW5UZXh0YmxvY2tCYWNrd2FyZCBhcyBvcmlnaW5hbENvbW1hbmQgfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIGpvaW5UZXh0YmxvY2tCYWNrd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbENvbW1hbmQoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9qb2luVGV4dGJsb2NrRm9yd2FyZC50c1xuaW1wb3J0IHsgam9pblRleHRibG9ja0ZvcndhcmQgYXMgb3JpZ2luYWxDb21tYW5kMiB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgam9pblRleHRibG9ja0ZvcndhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxDb21tYW5kMihzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL3V0aWxpdGllcy9pc01hY09TLnRzXG5mdW5jdGlvbiBpc01hY09TKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiA/IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSA6IGZhbHNlO1xufVxuXG4vLyBzcmMvY29tbWFuZHMva2V5Ym9hcmRTaG9ydGN1dC50c1xuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XG4gIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyk7XG4gIGxldCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgaWYgKHJlc3VsdCA9PT0gXCJTcGFjZVwiKSB7XG4gICAgcmVzdWx0ID0gXCIgXCI7XG4gIH1cbiAgbGV0IGFsdDtcbiAgbGV0IGN0cmw7XG4gIGxldCBzaGlmdDtcbiAgbGV0IG1ldGE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgY29uc3QgbW9kID0gcGFydHNbaV07XG4gICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSkge1xuICAgICAgbWV0YSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGFsdCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKSB7XG4gICAgICBjdHJsID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKSB7XG4gICAgICBzaGlmdCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGlmIChpc2lPUygpIHx8IGlzTWFjT1MoKSkge1xuICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiAke21vZH1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKGFsdCkge1xuICAgIHJlc3VsdCA9IGBBbHQtJHtyZXN1bHR9YDtcbiAgfVxuICBpZiAoY3RybCkge1xuICAgIHJlc3VsdCA9IGBDdHJsLSR7cmVzdWx0fWA7XG4gIH1cbiAgaWYgKG1ldGEpIHtcbiAgICByZXN1bHQgPSBgTWV0YS0ke3Jlc3VsdH1gO1xuICB9XG4gIGlmIChzaGlmdCkge1xuICAgIHJlc3VsdCA9IGBTaGlmdC0ke3Jlc3VsdH1gO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIga2V5Ym9hcmRTaG9ydGN1dCA9IChuYW1lKSA9PiAoeyBlZGl0b3IsIHZpZXcsIHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IGtleXMgPSBub3JtYWxpemVLZXlOYW1lKG5hbWUpLnNwbGl0KC8tKD8hJCkvKTtcbiAgY29uc3Qga2V5ID0ga2V5cy5maW5kKChpdGVtKSA9PiAhW1wiQWx0XCIsIFwiQ3RybFwiLCBcIk1ldGFcIiwgXCJTaGlmdFwiXS5pbmNsdWRlcyhpdGVtKSk7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXlkb3duXCIsIHtcbiAgICBrZXk6IGtleSA9PT0gXCJTcGFjZVwiID8gXCIgXCIgOiBrZXksXG4gICAgYWx0S2V5OiBrZXlzLmluY2x1ZGVzKFwiQWx0XCIpLFxuICAgIGN0cmxLZXk6IGtleXMuaW5jbHVkZXMoXCJDdHJsXCIpLFxuICAgIG1ldGFLZXk6IGtleXMuaW5jbHVkZXMoXCJNZXRhXCIpLFxuICAgIHNoaWZ0S2V5OiBrZXlzLmluY2x1ZGVzKFwiU2hpZnRcIiksXG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlXG4gIH0pO1xuICBjb25zdCBjYXB0dXJlZFRyYW5zYWN0aW9uID0gZWRpdG9yLmNhcHR1cmVUcmFuc2FjdGlvbigoKSA9PiB7XG4gICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgKGYpID0+IGYodmlldywgZXZlbnQpKTtcbiAgfSk7XG4gIGNhcHR1cmVkVHJhbnNhY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNhcHR1cmVkVHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaCgoc3RlcCkgPT4ge1xuICAgIGNvbnN0IG5ld1N0ZXAgPSBzdGVwLm1hcCh0ci5tYXBwaW5nKTtcbiAgICBpZiAobmV3U3RlcCAmJiBkaXNwYXRjaCkge1xuICAgICAgdHIubWF5YmVTdGVwKG5ld1N0ZXApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2xpZnQudHNcbmltcG9ydCB7IGxpZnQgYXMgb3JpZ2luYWxMaWZ0IH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcblxuLy8gc3JjL2hlbHBlcnMvaXNOb2RlQWN0aXZlLnRzXG5mdW5jdGlvbiBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICBjb25zdCB7IGZyb20sIHRvLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsO1xuICBjb25zdCBub2RlUmFuZ2VzID0gW107XG4gIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVsYXRpdmVGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKTtcbiAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgIG5vZGVSYW5nZXMucHVzaCh7XG4gICAgICBub2RlLFxuICAgICAgZnJvbTogcmVsYXRpdmVGcm9tLFxuICAgICAgdG86IHJlbGF0aXZlVG9cbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IHNlbGVjdGlvblJhbmdlID0gdG8gLSBmcm9tO1xuICBjb25zdCBtYXRjaGVkTm9kZVJhbmdlcyA9IG5vZGVSYW5nZXMuZmlsdGVyKChub2RlUmFuZ2UpID0+IHtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZS5uYW1lID09PSBub2RlUmFuZ2Uubm9kZS50eXBlLm5hbWU7XG4gIH0pLmZpbHRlcigobm9kZVJhbmdlKSA9PiBvYmplY3RJbmNsdWRlcyhub2RlUmFuZ2Uubm9kZS5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKTtcbiAgaWYgKGVtcHR5KSB7XG4gICAgcmV0dXJuICEhbWF0Y2hlZE5vZGVSYW5nZXMubGVuZ3RoO1xuICB9XG4gIGNvbnN0IHJhbmdlID0gbWF0Y2hlZE5vZGVSYW5nZXMucmVkdWNlKChzdW0sIG5vZGVSYW5nZSkgPT4gc3VtICsgbm9kZVJhbmdlLnRvIC0gbm9kZVJhbmdlLmZyb20sIDApO1xuICByZXR1cm4gcmFuZ2UgPj0gc2VsZWN0aW9uUmFuZ2U7XG59XG5cbi8vIHNyYy9jb21tYW5kcy9saWZ0LnRzXG52YXIgbGlmdCA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCBpc0FjdGl2ZTIgPSBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICBpZiAoIWlzQWN0aXZlMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3JpZ2luYWxMaWZ0KHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvbGlmdEVtcHR5QmxvY2sudHNcbmltcG9ydCB7IGxpZnRFbXB0eUJsb2NrIGFzIG9yaWdpbmFsTGlmdEVtcHR5QmxvY2sgfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIGxpZnRFbXB0eUJsb2NrID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsTGlmdEVtcHR5QmxvY2soc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9saWZ0TGlzdEl0ZW0udHNcbmltcG9ydCB7IGxpZnRMaXN0SXRlbSBhcyBvcmlnaW5hbExpZnRMaXN0SXRlbSB9IGZyb20gXCJAdGlwdGFwL3BtL3NjaGVtYS1saXN0XCI7XG52YXIgbGlmdExpc3RJdGVtID0gKHR5cGVPck5hbWUpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICByZXR1cm4gb3JpZ2luYWxMaWZ0TGlzdEl0ZW0odHlwZSkoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9uZXdsaW5lSW5Db2RlLnRzXG5pbXBvcnQgeyBuZXdsaW5lSW5Db2RlIGFzIG9yaWdpbmFsTmV3bGluZUluQ29kZSB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgbmV3bGluZUluQ29kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbE5ld2xpbmVJbkNvZGUoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9oZWxwZXJzL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLnRzXG5mdW5jdGlvbiBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lLCBzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS5ub2Rlc1tuYW1lXSkge1xuICAgIHJldHVybiBcIm5vZGVcIjtcbiAgfVxuICBpZiAoc2NoZW1hLm1hcmtzW25hbWVdKSB7XG4gICAgcmV0dXJuIFwibWFya1wiO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2RlbGV0ZVByb3BzLnRzXG5mdW5jdGlvbiBkZWxldGVQcm9wcyhvYmosIHByb3BPclByb3BzKSB7XG4gIGNvbnN0IHByb3BzID0gdHlwZW9mIHByb3BPclByb3BzID09PSBcInN0cmluZ1wiID8gW3Byb3BPclByb3BzXSA6IHByb3BPclByb3BzO1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKG5ld09iaiwgcHJvcCkgPT4ge1xuICAgIGlmICghcHJvcHMuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgIG5ld09ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld09iajtcbiAgfSwge30pO1xufVxuXG4vLyBzcmMvY29tbWFuZHMvcmVzZXRBdHRyaWJ1dGVzLnRzXG52YXIgcmVzZXRBdHRyaWJ1dGVzID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMpID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBsZXQgbm9kZVR5cGUgPSBudWxsO1xuICBsZXQgbWFya1R5cGUgPSBudWxsO1xuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUoXG4gICAgdHlwZW9mIHR5cGVPck5hbWUgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLFxuICAgIHN0YXRlLnNjaGVtYVxuICApO1xuICBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNjaGVtYVR5cGUgPT09IFwibm9kZVwiKSB7XG4gICAgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICB9XG4gIGlmIChzY2hlbWFUeXBlID09PSBcIm1hcmtcIikge1xuICAgIG1hcmtUeXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgfVxuICBsZXQgY2FuUmVzZXQgPSBmYWxzZTtcbiAgdHIuc2VsZWN0aW9uLnJhbmdlcy5mb3JFYWNoKChyYW5nZSkgPT4ge1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4ocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICBjYW5SZXNldCA9IHRydWU7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB2b2lkIDAsIGRlbGV0ZVByb3BzKG5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgIG5vZGUubWFya3MuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICBjYW5SZXNldCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgdHIuYWRkTWFyayhwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIG1hcmtUeXBlLmNyZWF0ZShkZWxldGVQcm9wcyhtYXJrLmF0dHJzLCBhdHRyaWJ1dGVzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gY2FuUmVzZXQ7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc2Nyb2xsSW50b1ZpZXcudHNcbnZhciBzY3JvbGxJbnRvVmlldyA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc2VsZWN0QWxsLnRzXG5pbXBvcnQgeyBBbGxTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIHNlbGVjdEFsbCA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IG5ldyBBbGxTZWxlY3Rpb24odHIuZG9jKTtcbiAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZWxlY3ROb2RlQmFja3dhcmQudHNcbmltcG9ydCB7IHNlbGVjdE5vZGVCYWNrd2FyZCBhcyBvcmlnaW5hbFNlbGVjdE5vZGVCYWNrd2FyZCB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgc2VsZWN0Tm9kZUJhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0Tm9kZUJhY2t3YXJkKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc2VsZWN0Tm9kZUZvcndhcmQudHNcbmltcG9ydCB7IHNlbGVjdE5vZGVGb3J3YXJkIGFzIG9yaWdpbmFsU2VsZWN0Tm9kZUZvcndhcmQgfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIHNlbGVjdE5vZGVGb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0Tm9kZUZvcndhcmQoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZWxlY3RQYXJlbnROb2RlLnRzXG5pbXBvcnQgeyBzZWxlY3RQYXJlbnROb2RlIGFzIG9yaWdpbmFsU2VsZWN0UGFyZW50Tm9kZSB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgc2VsZWN0UGFyZW50Tm9kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbFNlbGVjdFBhcmVudE5vZGUoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZWxlY3RUZXh0YmxvY2tFbmQudHNcbmltcG9ydCB7IHNlbGVjdFRleHRibG9ja0VuZCBhcyBvcmlnaW5hbFNlbGVjdFRleHRibG9ja0VuZCB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgc2VsZWN0VGV4dGJsb2NrRW5kID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrRW5kKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc2VsZWN0VGV4dGJsb2NrU3RhcnQudHNcbmltcG9ydCB7IHNlbGVjdFRleHRibG9ja1N0YXJ0IGFzIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrU3RhcnQgfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIHNlbGVjdFRleHRibG9ja1N0YXJ0ID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrU3RhcnQoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9oZWxwZXJzL2NyZWF0ZURvY3VtZW50LnRzXG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudChjb250ZW50LCBzY2hlbWEsIHBhcnNlT3B0aW9ucyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudChjb250ZW50LCBzY2hlbWEsIHtcbiAgICBzbGljZTogZmFsc2UsXG4gICAgcGFyc2VPcHRpb25zLFxuICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnRcbiAgfSk7XG59XG5cbi8vIHNyYy9jb21tYW5kcy9zZXRDb250ZW50LnRzXG52YXIgc2V0Q29udGVudCA9IChjb250ZW50LCB7IGVycm9yT25JbnZhbGlkQ29udGVudCwgZW1pdFVwZGF0ZSA9IHRydWUsIHBhcnNlT3B0aW9ucyA9IHt9IH0gPSB7fSkgPT4gKHsgZWRpdG9yLCB0ciwgZGlzcGF0Y2gsIGNvbW1hbmRzIH0pID0+IHtcbiAgY29uc3QgeyBkb2MgfSA9IHRyO1xuICBpZiAocGFyc2VPcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gXCJmdWxsXCIpIHtcbiAgICBjb25zdCBkb2N1bWVudDIgPSBjcmVhdGVEb2N1bWVudChjb250ZW50LCBlZGl0b3Iuc2NoZW1hLCBwYXJzZU9wdGlvbnMsIHtcbiAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogZXJyb3JPbkludmFsaWRDb250ZW50ICE9IG51bGwgPyBlcnJvck9uSW52YWxpZENvbnRlbnQgOiBlZGl0b3Iub3B0aW9ucy5lbmFibGVDb250ZW50Q2hlY2tcbiAgICB9KTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIHRyLnJlcGxhY2VXaXRoKDAsIGRvYy5jb250ZW50LnNpemUsIGRvY3VtZW50Mikuc2V0TWV0YShcInByZXZlbnRVcGRhdGVcIiwgIWVtaXRVcGRhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5zZXRNZXRhKFwicHJldmVudFVwZGF0ZVwiLCAhZW1pdFVwZGF0ZSk7XG4gIH1cbiAgcmV0dXJuIGNvbW1hbmRzLmluc2VydENvbnRlbnRBdCh7IGZyb206IDAsIHRvOiBkb2MuY29udGVudC5zaXplIH0sIGNvbnRlbnQsIHtcbiAgICBwYXJzZU9wdGlvbnMsXG4gICAgZXJyb3JPbkludmFsaWRDb250ZW50OiBlcnJvck9uSW52YWxpZENvbnRlbnQgIT0gbnVsbCA/IGVycm9yT25JbnZhbGlkQ29udGVudCA6IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVja1xuICB9KTtcbn07XG5cbi8vIHNyYy9oZWxwZXJzL2dldE1hcmtBdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSkge1xuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgeyBmcm9tLCB0bywgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgY29uc3QgbWFya3MgPSBbXTtcbiAgaWYgKGVtcHR5KSB7XG4gICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzKSB7XG4gICAgICBtYXJrcy5wdXNoKC4uLnN0YXRlLnN0b3JlZE1hcmtzKTtcbiAgICB9XG4gICAgbWFya3MucHVzaCguLi5zdGF0ZS5zZWxlY3Rpb24uJGhlYWQubWFya3MoKSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUpID0+IHtcbiAgICAgIG1hcmtzLnB1c2goLi4ubm9kZS5tYXJrcyk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWFyayA9IG1hcmtzLmZpbmQoKG1hcmtJdGVtKSA9PiBtYXJrSXRlbS50eXBlLm5hbWUgPT09IHR5cGUubmFtZSk7XG4gIGlmICghbWFyaykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4geyAuLi5tYXJrLmF0dHJzIH07XG59XG5cbi8vIHNyYy9oZWxwZXJzL2NvbWJpbmVUcmFuc2FjdGlvblN0ZXBzLnRzXG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbmZ1bmN0aW9uIGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKG9sZERvYywgdHJhbnNhY3Rpb25zKSB7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0ob2xkRG9jKTtcbiAgdHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgdHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaCgoc3RlcCkgPT4ge1xuICAgICAgdHJhbnNmb3JtLnN0ZXAoc3RlcCk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG4vLyBzcmMvaGVscGVycy9kZWZhdWx0QmxvY2tBdC50c1xuZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2gpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkgKz0gMSkge1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gbWF0Y2guZWRnZShpKTtcbiAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZmluZENoaWxkcmVuLnRzXG5mdW5jdGlvbiBmaW5kQ2hpbGRyZW4obm9kZSwgcHJlZGljYXRlKSB7XG4gIGNvbnN0IG5vZGVzV2l0aFBvcyA9IFtdO1xuICBub2RlLmRlc2NlbmRhbnRzKChjaGlsZCwgcG9zKSA9PiB7XG4gICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIHBvc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5vZGVzV2l0aFBvcztcbn1cblxuLy8gc3JjL2hlbHBlcnMvZmluZENoaWxkcmVuSW5SYW5nZS50c1xuZnVuY3Rpb24gZmluZENoaWxkcmVuSW5SYW5nZShub2RlLCByYW5nZSwgcHJlZGljYXRlKSB7XG4gIGNvbnN0IG5vZGVzV2l0aFBvcyA9IFtdO1xuICBub2RlLm5vZGVzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgKGNoaWxkLCBwb3MpID0+IHtcbiAgICBpZiAocHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgcG9zXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbm9kZXNXaXRoUG9zO1xufVxuXG4vLyBzcmMvaGVscGVycy9maW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1Bvcy50c1xuZnVuY3Rpb24gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MoJHBvcywgcHJlZGljYXRlKSB7XG4gIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShpKTtcbiAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IGkgPiAwID8gJHBvcy5iZWZvcmUoaSkgOiAwLFxuICAgICAgICBzdGFydDogJHBvcy5zdGFydChpKSxcbiAgICAgICAgZGVwdGg6IGksXG4gICAgICAgIG5vZGVcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9oZWxwZXJzL2ZpbmRQYXJlbnROb2RlLnRzXG5mdW5jdGlvbiBmaW5kUGFyZW50Tm9kZShwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIChzZWxlY3Rpb24pID0+IGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zKHNlbGVjdGlvbi4kZnJvbSwgcHJlZGljYXRlKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQudHNcbmZ1bmN0aW9uIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgZmllbGQsIGNvbnRleHQpIHtcbiAgaWYgKGV4dGVuc2lvbi5jb25maWdbZmllbGRdID09PSB2b2lkIDAgJiYgZXh0ZW5zaW9uLnBhcmVudCkge1xuICAgIHJldHVybiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBleHRlbnNpb24uY29uZmlnW2ZpZWxkXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb24uY29uZmlnW2ZpZWxkXS5iaW5kKHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBwYXJlbnQ6IGV4dGVuc2lvbi5wYXJlbnQgPyBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dCkgOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBleHRlbnNpb24uY29uZmlnW2ZpZWxkXTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZmxhdHRlbkV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIGZsYXR0ZW5FeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIGV4dGVuc2lvbnMubWFwKChleHRlbnNpb24pID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlXG4gICAgfTtcbiAgICBjb25zdCBhZGRFeHRlbnNpb25zID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZEV4dGVuc2lvbnNcIiwgY29udGV4dCk7XG4gICAgaWYgKGFkZEV4dGVuc2lvbnMpIHtcbiAgICAgIHJldHVybiBbZXh0ZW5zaW9uLCAuLi5mbGF0dGVuRXh0ZW5zaW9ucyhhZGRFeHRlbnNpb25zKCkpXTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgfSkuZmxhdCgxMCk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dlbmVyYXRlSFRNTC50c1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gXCJAdGlwdGFwL3BtL21vZGVsXCI7XG5cbi8vIHNyYy9oZWxwZXJzL2dldEhUTUxGcm9tRnJhZ21lbnQudHNcbmltcG9ydCB7IERPTVNlcmlhbGl6ZXIgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuZnVuY3Rpb24gZ2V0SFRNTEZyb21GcmFnbWVudChmcmFnbWVudCwgc2NoZW1hKSB7XG4gIGNvbnN0IGRvY3VtZW50RnJhZ21lbnQgPSBET01TZXJpYWxpemVyLmZyb21TY2hlbWEoc2NoZW1hKS5zZXJpYWxpemVGcmFnbWVudChmcmFnbWVudCk7XG4gIGNvbnN0IHRlbXBvcmFyeURvY3VtZW50ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XG4gIGNvbnN0IGNvbnRhaW5lciA9IHRlbXBvcmFyeURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudEZyYWdtZW50KTtcbiAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zLnRzXG5pbXBvcnQgeyBTY2hlbWEgYXMgU2NoZW1hMiB9IGZyb20gXCJAdGlwdGFwL3BtL21vZGVsXCI7XG5cbi8vIHNyYy91dGlsaXRpZXMvaXNGdW5jdGlvbi50c1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLnRzXG5mdW5jdGlvbiBjYWxsT3JSZXR1cm4odmFsdWUsIGNvbnRleHQgPSB2b2lkIDAsIC4uLnByb3BzKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdmFsdWUuYmluZChjb250ZXh0KSguLi5wcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSguLi5wcm9wcyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2lzRW1wdHlPYmplY3QudHNcbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3QodmFsdWUgPSB7fSkge1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuXG4vLyBzcmMvaGVscGVycy9zcGxpdEV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gIGNvbnN0IGJhc2VFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLnR5cGUgPT09IFwiZXh0ZW5zaW9uXCIpO1xuICBjb25zdCBub2RlRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKChleHRlbnNpb24pID0+IGV4dGVuc2lvbi50eXBlID09PSBcIm5vZGVcIik7XG4gIGNvbnN0IG1hcmtFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLnR5cGUgPT09IFwibWFya1wiKTtcbiAgcmV0dXJuIHtcbiAgICBiYXNlRXh0ZW5zaW9ucyxcbiAgICBub2RlRXh0ZW5zaW9ucyxcbiAgICBtYXJrRXh0ZW5zaW9uc1xuICB9O1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBbXTtcbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgY29uc3Qgbm9kZUFuZE1hcmtFeHRlbnNpb25zID0gWy4uLm5vZGVFeHRlbnNpb25zLCAuLi5tYXJrRXh0ZW5zaW9uc107XG4gIGNvbnN0IGRlZmF1bHRBdHRyaWJ1dGUgPSB7XG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICB2YWxpZGF0ZTogdm9pZCAwLFxuICAgIHJlbmRlcmVkOiB0cnVlLFxuICAgIHJlbmRlckhUTUw6IG51bGwsXG4gICAgcGFyc2VIVE1MOiBudWxsLFxuICAgIGtlZXBPblNwbGl0OiB0cnVlLFxuICAgIGlzUmVxdWlyZWQ6IGZhbHNlXG4gIH07XG4gIGV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgIGV4dGVuc2lvbnM6IG5vZGVBbmRNYXJrRXh0ZW5zaW9uc1xuICAgIH07XG4gICAgY29uc3QgYWRkR2xvYmFsQXR0cmlidXRlcyA9IGdldEV4dGVuc2lvbkZpZWxkKFxuICAgICAgZXh0ZW5zaW9uLFxuICAgICAgXCJhZGRHbG9iYWxBdHRyaWJ1dGVzXCIsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICBpZiAoIWFkZEdsb2JhbEF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ2xvYmFsQXR0cmlidXRlcyA9IGFkZEdsb2JhbEF0dHJpYnV0ZXMoKTtcbiAgICBnbG9iYWxBdHRyaWJ1dGVzLmZvckVhY2goKGdsb2JhbEF0dHJpYnV0ZSkgPT4ge1xuICAgICAgZ2xvYmFsQXR0cmlidXRlLnR5cGVzLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZ2xvYmFsQXR0cmlidXRlLmF0dHJpYnV0ZXMpLmZvckVhY2goKFtuYW1lLCBhdHRyaWJ1dGVdKSA9PiB7XG4gICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYXR0cmlidXRlOiB7XG4gICAgICAgICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgbm9kZUFuZE1hcmtFeHRlbnNpb25zLmZvckVhY2goKGV4dGVuc2lvbikgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2VcbiAgICB9O1xuICAgIGNvbnN0IGFkZEF0dHJpYnV0ZXMgPSBnZXRFeHRlbnNpb25GaWVsZChcbiAgICAgIGV4dGVuc2lvbixcbiAgICAgIFwiYWRkQXR0cmlidXRlc1wiLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgaWYgKCFhZGRBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhZGRBdHRyaWJ1dGVzKCk7XG4gICAgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgIGNvbnN0IG1lcmdlZEF0dHIgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGUsXG4gICAgICAgIC4uLmF0dHJpYnV0ZVxuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2YgKG1lcmdlZEF0dHIgPT0gbnVsbCA/IHZvaWQgMCA6IG1lcmdlZEF0dHIuZGVmYXVsdCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBtZXJnZWRBdHRyLmRlZmF1bHQgPSBtZXJnZWRBdHRyLmRlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGlmICgobWVyZ2VkQXR0ciA9PSBudWxsID8gdm9pZCAwIDogbWVyZ2VkQXR0ci5pc1JlcXVpcmVkKSAmJiAobWVyZ2VkQXR0ciA9PSBudWxsID8gdm9pZCAwIDogbWVyZ2VkQXR0ci5kZWZhdWx0KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlbGV0ZSBtZXJnZWRBdHRyLmRlZmF1bHQ7XG4gICAgICB9XG4gICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXR0cmlidXRlOiBtZXJnZWRBdHRyXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGVzO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL21lcmdlQXR0cmlidXRlcy50c1xuZnVuY3Rpb24gbWVyZ2VBdHRyaWJ1dGVzKC4uLm9iamVjdHMpIHtcbiAgcmV0dXJuIG9iamVjdHMuZmlsdGVyKChpdGVtKSA9PiAhIWl0ZW0pLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGVzID0geyAuLi5pdGVtcyB9O1xuICAgIE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldO1xuICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgICAgICBjb25zdCB2YWx1ZUNsYXNzZXMgPSB2YWx1ZSA/IFN0cmluZyh2YWx1ZSkuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2xhc3NlcyA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA/IG1lcmdlZEF0dHJpYnV0ZXNba2V5XS5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgY29uc3QgaW5zZXJ0Q2xhc3NlcyA9IHZhbHVlQ2xhc3Nlcy5maWx0ZXIoKHZhbHVlQ2xhc3MpID0+ICFleGlzdGluZ0NsYXNzZXMuaW5jbHVkZXModmFsdWVDbGFzcykpO1xuICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSBbLi4uZXhpc3RpbmdDbGFzc2VzLCAuLi5pbnNlcnRDbGFzc2VzXS5qb2luKFwiIFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgY29uc3QgbmV3U3R5bGVzID0gdmFsdWUgPyB2YWx1ZS5zcGxpdChcIjtcIikubWFwKChzdHlsZTIpID0+IHN0eWxlMi50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBjb25zdCBleGlzdGluZ1N0eWxlcyA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA/IG1lcmdlZEF0dHJpYnV0ZXNba2V5XS5zcGxpdChcIjtcIikubWFwKChzdHlsZTIpID0+IHN0eWxlMi50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBjb25zdCBzdHlsZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGV4aXN0aW5nU3R5bGVzLmZvckVhY2goKHN0eWxlMikgPT4ge1xuICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eSwgdmFsXSA9IHN0eWxlMi5zcGxpdChcIjpcIikubWFwKChwYXJ0KSA9PiBwYXJ0LnRyaW0oKSk7XG4gICAgICAgICAgc3R5bGVNYXAuc2V0KHByb3BlcnR5LCB2YWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgbmV3U3R5bGVzLmZvckVhY2goKHN0eWxlMikgPT4ge1xuICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eSwgdmFsXSA9IHN0eWxlMi5zcGxpdChcIjpcIikubWFwKChwYXJ0KSA9PiBwYXJ0LnRyaW0oKSk7XG4gICAgICAgICAgc3R5bGVNYXAuc2V0KHByb3BlcnR5LCB2YWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gQXJyYXkuZnJvbShzdHlsZU1hcC5lbnRyaWVzKCkpLm1hcCgoW3Byb3BlcnR5LCB2YWxdKSA9PiBgJHtwcm9wZXJ0eX06ICR7dmFsfWApLmpvaW4oXCI7IFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXJnZWRBdHRyaWJ1dGVzO1xuICB9LCB7fSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldFJlbmRlcmVkQXR0cmlidXRlcy50c1xuZnVuY3Rpb24gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGVPck1hcmssIGV4dGVuc2lvbkF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZXMuZmlsdGVyKChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS50eXBlID09PSBub2RlT3JNYXJrLnR5cGUubmFtZSkuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJlZCkubWFwKChpdGVtKSA9PiB7XG4gICAgaWYgKCFpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbaXRlbS5uYW1lXTogbm9kZU9yTWFyay5hdHRyc1tpdGVtLm5hbWVdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gaXRlbS5hdHRyaWJ1dGUucmVuZGVySFRNTChub2RlT3JNYXJrLmF0dHJzKSB8fCB7fTtcbiAgfSkucmVkdWNlKChhdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpID0+IG1lcmdlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpLCB7fSk7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvZnJvbVN0cmluZy50c1xuZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZS5tYXRjaCgvXlsrLV0/KD86XFxkKlxcLik/XFxkKyQvKSkge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2luamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZS50c1xuZnVuY3Rpb24gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykge1xuICBpZiAoXCJzdHlsZVwiIGluIHBhcnNlUnVsZSkge1xuICAgIHJldHVybiBwYXJzZVJ1bGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJzZVJ1bGUsXG4gICAgZ2V0QXR0cnM6IChub2RlKSA9PiB7XG4gICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gcGFyc2VSdWxlLmdldEF0dHJzID8gcGFyc2VSdWxlLmdldEF0dHJzKG5vZGUpIDogcGFyc2VSdWxlLmF0dHJzO1xuICAgICAgaWYgKG9sZEF0dHJpYnV0ZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBleHRlbnNpb25BdHRyaWJ1dGVzLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUwgPyBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUwobm9kZSkgOiBmcm9tU3RyaW5nKG5vZGUuZ2V0QXR0cmlidXRlKGl0ZW0ubmFtZSkpO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLml0ZW1zLFxuICAgICAgICAgIFtpdGVtLm5hbWVdOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSwge30pO1xuICAgICAgcmV0dXJuIHsgLi4ub2xkQXR0cmlidXRlcywgLi4ubmV3QXR0cmlidXRlcyB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIGNsZWFuVXBTY2hlbWFJdGVtKGRhdGEpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZmlsdGVyKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChrZXkgPT09IFwiYXR0cnNcIiAmJiBpc0VtcHR5T2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMDtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gYnVpbGRBdHRyaWJ1dGVTcGVjKGV4dGVuc2lvbkF0dHJpYnV0ZSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBzcGVjID0ge307XG4gIGlmICghKChfYSA9IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PSBudWxsID8gdm9pZCAwIDogZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmlzUmVxdWlyZWQpICYmIFwiZGVmYXVsdFwiIGluICgoZXh0ZW5zaW9uQXR0cmlidXRlID09IG51bGwgPyB2b2lkIDAgOiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlKSB8fCB7fSkpIHtcbiAgICBzcGVjLmRlZmF1bHQgPSBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlLmRlZmF1bHQ7XG4gIH1cbiAgaWYgKCgoX2IgPSBleHRlbnNpb25BdHRyaWJ1dGUgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi52YWxpZGF0ZSkgIT09IHZvaWQgMCkge1xuICAgIHNwZWMudmFsaWRhdGUgPSBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlLnZhbGlkYXRlO1xuICB9XG4gIHJldHVybiBbZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsIHNwZWNdO1xufVxuZnVuY3Rpb24gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMoZXh0ZW5zaW9ucywgZWRpdG9yKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgYWxsQXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgY29uc3QgdG9wTm9kZSA9IChfYSA9IG5vZGVFeHRlbnNpb25zLmZpbmQoKGV4dGVuc2lvbikgPT4gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcInRvcE5vZGVcIikpKSA9PSBudWxsID8gdm9pZCAwIDogX2EubmFtZTtcbiAgY29uc3Qgbm9kZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgbm9kZUV4dGVuc2lvbnMubWFwKChleHRlbnNpb24pID0+IHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLmZpbHRlcigoYXR0cmlidXRlKSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9O1xuICAgICAgY29uc3QgZXh0cmFOb2RlRmllbGRzID0gZXh0ZW5zaW9ucy5yZWR1Y2UoKGZpZWxkcywgZSkgPT4ge1xuICAgICAgICBjb25zdCBleHRlbmROb2RlU2NoZW1hID0gZ2V0RXh0ZW5zaW9uRmllbGQoZSwgXCJleHRlbmROb2RlU2NoZW1hXCIsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAuLi5leHRlbmROb2RlU2NoZW1hID8gZXh0ZW5kTm9kZVNjaGVtYShleHRlbnNpb24pIDoge31cbiAgICAgICAgfTtcbiAgICAgIH0sIHt9KTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IGNsZWFuVXBTY2hlbWFJdGVtKHtcbiAgICAgICAgLi4uZXh0cmFOb2RlRmllbGRzLFxuICAgICAgICBjb250ZW50OiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImNvbnRlbnRcIiwgY29udGV4dCkpLFxuICAgICAgICBtYXJrczogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJtYXJrc1wiLCBjb250ZXh0KSksXG4gICAgICAgIGdyb3VwOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImdyb3VwXCIsIGNvbnRleHQpKSxcbiAgICAgICAgaW5saW5lOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImlubGluZVwiLCBjb250ZXh0KSksXG4gICAgICAgIGF0b206IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiYXRvbVwiLCBjb250ZXh0KSksXG4gICAgICAgIHNlbGVjdGFibGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwic2VsZWN0YWJsZVwiLCBjb250ZXh0KSksXG4gICAgICAgIGRyYWdnYWJsZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJkcmFnZ2FibGVcIiwgY29udGV4dCkpLFxuICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImNvZGVcIiwgY29udGV4dCkpLFxuICAgICAgICB3aGl0ZXNwYWNlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcIndoaXRlc3BhY2VcIiwgY29udGV4dCkpLFxuICAgICAgICBsaW5lYnJlYWtSZXBsYWNlbWVudDogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJsaW5lYnJlYWtSZXBsYWNlbWVudFwiLCBjb250ZXh0KVxuICAgICAgICApLFxuICAgICAgICBkZWZpbmluZzogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJkZWZpbmluZ1wiLCBjb250ZXh0KSksXG4gICAgICAgIGlzb2xhdGluZzogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJpc29sYXRpbmdcIiwgY29udGV4dCkpLFxuICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKGJ1aWxkQXR0cmlidXRlU3BlYykpXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhcnNlSFRNTCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwicGFyc2VIVE1MXCIsIGNvbnRleHQpKTtcbiAgICAgIGlmIChwYXJzZUhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChcbiAgICAgICAgICAocGFyc2VSdWxlKSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJyZW5kZXJIVE1MXCIsIGNvbnRleHQpO1xuICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnRvRE9NID0gKG5vZGUpID0+IHJlbmRlckhUTUwoe1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbmRlclRleHQgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwicmVuZGVyVGV4dFwiLCBjb250ZXh0KTtcbiAgICAgIGlmIChyZW5kZXJUZXh0KSB7XG4gICAgICAgIHNjaGVtYS50b1RleHQgPSByZW5kZXJUZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgc2NoZW1hXTtcbiAgICB9KVxuICApO1xuICBjb25zdCBtYXJrcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBtYXJrRXh0ZW5zaW9ucy5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMuZmlsdGVyKChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSk7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICBlZGl0b3JcbiAgICAgIH07XG4gICAgICBjb25zdCBleHRyYU1hcmtGaWVsZHMgPSBleHRlbnNpb25zLnJlZHVjZSgoZmllbGRzLCBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuZE1hcmtTY2hlbWEgPSBnZXRFeHRlbnNpb25GaWVsZChlLCBcImV4dGVuZE1hcmtTY2hlbWFcIiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgIC4uLmV4dGVuZE1hcmtTY2hlbWEgPyBleHRlbmRNYXJrU2NoZW1hKGV4dGVuc2lvbikgOiB7fVxuICAgICAgICB9O1xuICAgICAgfSwge30pO1xuICAgICAgY29uc3Qgc2NoZW1hID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xuICAgICAgICAuLi5leHRyYU1hcmtGaWVsZHMsXG4gICAgICAgIGluY2x1c2l2ZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJpbmNsdXNpdmVcIiwgY29udGV4dCkpLFxuICAgICAgICBleGNsdWRlczogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJleGNsdWRlc1wiLCBjb250ZXh0KSksXG4gICAgICAgIGdyb3VwOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImdyb3VwXCIsIGNvbnRleHQpKSxcbiAgICAgICAgc3Bhbm5pbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwic3Bhbm5pbmdcIiwgY29udGV4dCkpLFxuICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImNvZGVcIiwgY29udGV4dCkpLFxuICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKGJ1aWxkQXR0cmlidXRlU3BlYykpXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhcnNlSFRNTCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwicGFyc2VIVE1MXCIsIGNvbnRleHQpKTtcbiAgICAgIGlmIChwYXJzZUhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChcbiAgICAgICAgICAocGFyc2VSdWxlKSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJyZW5kZXJIVE1MXCIsIGNvbnRleHQpO1xuICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnRvRE9NID0gKG1hcmspID0+IHJlbmRlckhUTUwoe1xuICAgICAgICAgIG1hcmssXG4gICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhtYXJrLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV07XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIG5ldyBTY2hlbWEyKHtcbiAgICB0b3BOb2RlLFxuICAgIG5vZGVzLFxuICAgIG1hcmtzXG4gIH0pO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2ZpbmREdXBsaWNhdGVzLnRzXG5mdW5jdGlvbiBmaW5kRHVwbGljYXRlcyhpdGVtcykge1xuICBjb25zdCBmaWx0ZXJlZCA9IGl0ZW1zLmZpbHRlcigoZWwsIGluZGV4KSA9PiBpdGVtcy5pbmRleE9mKGVsKSAhPT0gaW5kZXgpO1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGZpbHRlcmVkKSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL3NvcnRFeHRlbnNpb25zLnRzXG5mdW5jdGlvbiBzb3J0RXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gIGNvbnN0IGRlZmF1bHRQcmlvcml0eSA9IDEwMDtcbiAgcmV0dXJuIGV4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHByaW9yaXR5QSA9IGdldEV4dGVuc2lvbkZpZWxkKGEsIFwicHJpb3JpdHlcIikgfHwgZGVmYXVsdFByaW9yaXR5O1xuICAgIGNvbnN0IHByaW9yaXR5QiA9IGdldEV4dGVuc2lvbkZpZWxkKGIsIFwicHJpb3JpdHlcIikgfHwgZGVmYXVsdFByaW9yaXR5O1xuICAgIGlmIChwcmlvcml0eUEgPiBwcmlvcml0eUIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKHByaW9yaXR5QSA8IHByaW9yaXR5Qikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9KTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvcmVzb2x2ZUV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIHJlc29sdmVFeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gc29ydEV4dGVuc2lvbnMoZmxhdHRlbkV4dGVuc2lvbnMoZXh0ZW5zaW9ucykpO1xuICBjb25zdCBkdXBsaWNhdGVkTmFtZXMgPSBmaW5kRHVwbGljYXRlcyhyZXNvbHZlZEV4dGVuc2lvbnMubWFwKChleHRlbnNpb24pID0+IGV4dGVuc2lvbi5uYW1lKSk7XG4gIGlmIChkdXBsaWNhdGVkTmFtZXMubGVuZ3RoKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYFt0aXB0YXAgd2Fybl06IER1cGxpY2F0ZSBleHRlbnNpb24gbmFtZXMgZm91bmQ6IFske2R1cGxpY2F0ZWROYW1lcy5tYXAoKGl0ZW0pID0+IGAnJHtpdGVtfSdgKS5qb2luKFwiLCBcIil9XS4gVGhpcyBjYW4gbGVhZCB0byBpc3N1ZXMuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkRXh0ZW5zaW9ucztcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0U2NoZW1hLnRzXG5mdW5jdGlvbiBnZXRTY2hlbWEoZXh0ZW5zaW9ucywgZWRpdG9yKSB7XG4gIGNvbnN0IHJlc29sdmVkRXh0ZW5zaW9ucyA9IHJlc29sdmVFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xuICByZXR1cm4gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMocmVzb2x2ZWRFeHRlbnNpb25zLCBlZGl0b3IpO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZW5lcmF0ZUhUTUwudHNcbmZ1bmN0aW9uIGdlbmVyYXRlSFRNTChkb2MsIGV4dGVuc2lvbnMpIHtcbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpO1xuICBjb25zdCBjb250ZW50Tm9kZSA9IE5vZGUuZnJvbUpTT04oc2NoZW1hLCBkb2MpO1xuICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudChjb250ZW50Tm9kZS5jb250ZW50LCBzY2hlbWEpO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZW5lcmF0ZUpTT04udHNcbmltcG9ydCB7IERPTVBhcnNlciBhcyBET01QYXJzZXIyIH0gZnJvbSBcIkB0aXB0YXAvcG0vbW9kZWxcIjtcbmZ1bmN0aW9uIGdlbmVyYXRlSlNPTihodG1sLCBleHRlbnNpb25zKSB7XG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcbiAgY29uc3QgZG9tID0gZWxlbWVudEZyb21TdHJpbmcoaHRtbCk7XG4gIHJldHVybiBET01QYXJzZXIyLmZyb21TY2hlbWEoc2NoZW1hKS5wYXJzZShkb20pLnRvSlNPTigpO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZW5lcmF0ZVRleHQudHNcbmltcG9ydCB7IE5vZGUgYXMgTm9kZTIgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuXG4vLyBzcmMvaGVscGVycy9nZXRUZXh0QmV0d2Vlbi50c1xuZnVuY3Rpb24gZ2V0VGV4dEJldHdlZW4oc3RhcnROb2RlLCByYW5nZSwgb3B0aW9ucykge1xuICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZTtcbiAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9IFwiXFxuXFxuXCIsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgdGV4dCA9IFwiXCI7XG4gIHN0YXJ0Tm9kZS5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MsIHBhcmVudCwgaW5kZXgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG5vZGUuaXNCbG9jayAmJiBwb3MgPiBmcm9tKSB7XG4gICAgICB0ZXh0ICs9IGJsb2NrU2VwYXJhdG9yO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0U2VyaWFsaXplciA9IHRleHRTZXJpYWxpemVycyA9PSBudWxsID8gdm9pZCAwIDogdGV4dFNlcmlhbGl6ZXJzW25vZGUudHlwZS5uYW1lXTtcbiAgICBpZiAodGV4dFNlcmlhbGl6ZXIpIHtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdGV4dCArPSB0ZXh0U2VyaWFsaXplcih7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwb3MsXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHJhbmdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgIHRleHQgKz0gKF9hID0gbm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2xpY2UoTWF0aC5tYXgoZnJvbSwgcG9zKSAtIHBvcywgdG8gLSBwb3MpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0ZXh0O1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRUZXh0LnRzXG5mdW5jdGlvbiBnZXRUZXh0KG5vZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmFuZ2UgPSB7XG4gICAgZnJvbTogMCxcbiAgICB0bzogbm9kZS5jb250ZW50LnNpemVcbiAgfTtcbiAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKG5vZGUsIHJhbmdlLCBvcHRpb25zKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYS50c1xuZnVuY3Rpb24gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhzY2hlbWEubm9kZXMpLmZpbHRlcigoWywgbm9kZV0pID0+IG5vZGUuc3BlYy50b1RleHQpLm1hcCgoW25hbWUsIG5vZGVdKSA9PiBbbmFtZSwgbm9kZS5zcGVjLnRvVGV4dF0pXG4gICk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dlbmVyYXRlVGV4dC50c1xuZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KGRvYywgZXh0ZW5zaW9ucywgb3B0aW9ucykge1xuICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gXCJcXG5cXG5cIiwgdGV4dFNlcmlhbGl6ZXJzID0ge30gfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcbiAgY29uc3QgY29udGVudE5vZGUgPSBOb2RlMi5mcm9tSlNPTihzY2hlbWEsIGRvYyk7XG4gIHJldHVybiBnZXRUZXh0KGNvbnRlbnROb2RlLCB7XG4gICAgYmxvY2tTZXBhcmF0b3IsXG4gICAgdGV4dFNlcmlhbGl6ZXJzOiB7XG4gICAgICAuLi5nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHNjaGVtYSksXG4gICAgICAuLi50ZXh0U2VyaWFsaXplcnNcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXROb2RlQXR0cmlidXRlcy50c1xuZnVuY3Rpb24gZ2V0Tm9kZUF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpIHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUyKSA9PiB7XG4gICAgbm9kZXMucHVzaChub2RlMik7XG4gIH0pO1xuICBjb25zdCBub2RlID0gbm9kZXMucmV2ZXJzZSgpLmZpbmQoKG5vZGVJdGVtKSA9PiBub2RlSXRlbS50eXBlLm5hbWUgPT09IHR5cGUubmFtZSk7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4geyAuLi5ub2RlLmF0dHJzIH07XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldEF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpIHtcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKFxuICAgIHR5cGVvZiB0eXBlT3JOYW1lID09PSBcInN0cmluZ1wiID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSxcbiAgICBzdGF0ZS5zY2hlbWFcbiAgKTtcbiAgaWYgKHNjaGVtYVR5cGUgPT09IFwibm9kZVwiKSB7XG4gICAgcmV0dXJuIGdldE5vZGVBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKTtcbiAgfVxuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJtYXJrXCIpIHtcbiAgICByZXR1cm4gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpO1xuICB9XG4gIHJldHVybiB7fTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9yZW1vdmVEdXBsaWNhdGVzLnRzXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVzKGFycmF5LCBieSA9IEpTT04uc3RyaW5naWZ5KSB7XG4gIGNvbnN0IHNlZW4gPSB7fTtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcigoaXRlbSkgPT4ge1xuICAgIGNvbnN0IGtleSA9IGJ5KGl0ZW0pO1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2Vlbiwga2V5KSA/IGZhbHNlIDogc2VlbltrZXldID0gdHJ1ZTtcbiAgfSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldENoYW5nZWRSYW5nZXMudHNcbmZ1bmN0aW9uIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzKSB7XG4gIGNvbnN0IHVuaXF1ZUNoYW5nZXMgPSByZW1vdmVEdXBsaWNhdGVzKGNoYW5nZXMpO1xuICByZXR1cm4gdW5pcXVlQ2hhbmdlcy5sZW5ndGggPT09IDEgPyB1bmlxdWVDaGFuZ2VzIDogdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKGNoYW5nZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCByZXN0ID0gdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKF8sIGkpID0+IGkgIT09IGluZGV4KTtcbiAgICByZXR1cm4gIXJlc3Quc29tZSgob3RoZXJDaGFuZ2UpID0+IHtcbiAgICAgIHJldHVybiBjaGFuZ2Uub2xkUmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5vbGRSYW5nZS5mcm9tICYmIGNoYW5nZS5vbGRSYW5nZS50byA8PSBvdGhlckNoYW5nZS5vbGRSYW5nZS50byAmJiBjaGFuZ2UubmV3UmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5uZXdSYW5nZS5mcm9tICYmIGNoYW5nZS5uZXdSYW5nZS50byA8PSBvdGhlckNoYW5nZS5uZXdSYW5nZS50bztcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRDaGFuZ2VkUmFuZ2VzKHRyYW5zZm9ybSkge1xuICBjb25zdCB7IG1hcHBpbmcsIHN0ZXBzIH0gPSB0cmFuc2Zvcm07XG4gIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgbWFwcGluZy5tYXBzLmZvckVhY2goKHN0ZXBNYXAsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcmFuZ2VzID0gW107XG4gICAgaWYgKCFzdGVwTWFwLnJhbmdlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0ZXBzW2luZGV4XTtcbiAgICAgIGlmIChmcm9tID09PSB2b2lkIDAgfHwgdG8gPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGVwTWFwLmZvckVhY2goKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmFuZ2VzLmZvckVhY2goKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAoZnJvbSwgLTEpO1xuICAgICAgY29uc3QgbmV3RW5kID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKHRvKTtcbiAgICAgIGNvbnN0IG9sZFN0YXJ0ID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3U3RhcnQsIC0xKTtcbiAgICAgIGNvbnN0IG9sZEVuZCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld0VuZCk7XG4gICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICBvbGRSYW5nZToge1xuICAgICAgICAgIGZyb206IG9sZFN0YXJ0LFxuICAgICAgICAgIHRvOiBvbGRFbmRcbiAgICAgICAgfSxcbiAgICAgICAgbmV3UmFuZ2U6IHtcbiAgICAgICAgICBmcm9tOiBuZXdTdGFydCxcbiAgICAgICAgICB0bzogbmV3RW5kXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0RGVidWdKU09OLnRzXG5mdW5jdGlvbiBnZXREZWJ1Z0pTT04obm9kZSwgc3RhcnRPZmZzZXQgPSAwKSB7XG4gIGNvbnN0IGlzVG9wTm9kZSA9IG5vZGUudHlwZSA9PT0gbm9kZS50eXBlLnNjaGVtYS50b3BOb2RlVHlwZTtcbiAgY29uc3QgaW5jcmVtZW50ID0gaXNUb3BOb2RlID8gMCA6IDE7XG4gIGNvbnN0IGZyb20gPSBzdGFydE9mZnNldDtcbiAgY29uc3QgdG8gPSBmcm9tICsgbm9kZS5ub2RlU2l6ZTtcbiAgY29uc3QgbWFya3MgPSBub2RlLm1hcmtzLm1hcCgobWFyaykgPT4ge1xuICAgIGNvbnN0IG91dHB1dDIgPSB7XG4gICAgICB0eXBlOiBtYXJrLnR5cGUubmFtZVxuICAgIH07XG4gICAgaWYgKE9iamVjdC5rZXlzKG1hcmsuYXR0cnMpLmxlbmd0aCkge1xuICAgICAgb3V0cHV0Mi5hdHRycyA9IHsgLi4ubWFyay5hdHRycyB9O1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0MjtcbiAgfSk7XG4gIGNvbnN0IGF0dHJzID0geyAuLi5ub2RlLmF0dHJzIH07XG4gIGNvbnN0IG91dHB1dCA9IHtcbiAgICB0eXBlOiBub2RlLnR5cGUubmFtZSxcbiAgICBmcm9tLFxuICAgIHRvXG4gIH07XG4gIGlmIChPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoKSB7XG4gICAgb3V0cHV0LmF0dHJzID0gYXR0cnM7XG4gIH1cbiAgaWYgKG1hcmtzLmxlbmd0aCkge1xuICAgIG91dHB1dC5tYXJrcyA9IG1hcmtzO1xuICB9XG4gIGlmIChub2RlLmNvbnRlbnQuY2hpbGRDb3VudCkge1xuICAgIG91dHB1dC5jb250ZW50ID0gW107XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZCwgb2Zmc2V0KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBvdXRwdXQuY29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnB1c2goZ2V0RGVidWdKU09OKGNoaWxkLCBzdGFydE9mZnNldCArIG9mZnNldCArIGluY3JlbWVudCkpO1xuICAgIH0pO1xuICB9XG4gIGlmIChub2RlLnRleHQpIHtcbiAgICBvdXRwdXQudGV4dCA9IG5vZGUudGV4dDtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRNYXJrc0JldHdlZW4udHNcbmZ1bmN0aW9uIGdldE1hcmtzQmV0d2Vlbihmcm9tLCB0bywgZG9jKSB7XG4gIGNvbnN0IG1hcmtzID0gW107XG4gIGlmIChmcm9tID09PSB0bykge1xuICAgIGRvYy5yZXNvbHZlKGZyb20pLm1hcmtzKCkuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgICAgY29uc3QgJHBvcyA9IGRvYy5yZXNvbHZlKGZyb20pO1xuICAgICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJHBvcywgbWFyay50eXBlKTtcbiAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgIG1hcmssXG4gICAgICAgIC4uLnJhbmdlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAoIW5vZGUgfHwgKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUubm9kZVNpemUpID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWFya3MucHVzaChcbiAgICAgICAgLi4ubm9kZS5tYXJrcy5tYXAoKG1hcmspID0+ICh7XG4gICAgICAgICAgZnJvbTogcG9zLFxuICAgICAgICAgIHRvOiBwb3MgKyBub2RlLm5vZGVTaXplLFxuICAgICAgICAgIG1hcmtcbiAgICAgICAgfSkpXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBtYXJrcztcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0Tm9kZUF0UG9zaXRpb24udHNcbnZhciBnZXROb2RlQXRQb3NpdGlvbiA9IChzdGF0ZSwgdHlwZU9yTmFtZSwgcG9zLCBtYXhEZXB0aCA9IDIwKSA9PiB7XG4gIGNvbnN0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xuICBsZXQgY3VycmVudERlcHRoID0gbWF4RGVwdGg7XG4gIGxldCBub2RlID0gbnVsbDtcbiAgd2hpbGUgKGN1cnJlbnREZXB0aCA+IDAgJiYgbm9kZSA9PT0gbnVsbCkge1xuICAgIGNvbnN0IGN1cnJlbnROb2RlID0gJHBvcy5ub2RlKGN1cnJlbnREZXB0aCk7XG4gICAgaWYgKChjdXJyZW50Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudE5vZGUudHlwZS5uYW1lKSA9PT0gdHlwZU9yTmFtZSkge1xuICAgICAgbm9kZSA9IGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50RGVwdGggLT0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtub2RlLCBjdXJyZW50RGVwdGhdO1xufTtcblxuLy8gc3JjL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZUJ5TmFtZS50c1xuZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZUJ5TmFtZShuYW1lLCBzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYS5ub2Rlc1tuYW1lXSB8fCBzY2hlbWEubWFya3NbbmFtZV0gfHwgbnVsbDtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgdHlwZU5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5maWx0ZXIoKFtuYW1lXSkgPT4ge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlID0gZXh0ZW5zaW9uQXR0cmlidXRlcy5maW5kKChpdGVtKSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGVOYW1lICYmIGl0ZW0ubmFtZSA9PT0gbmFtZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFleHRlbnNpb25BdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUua2VlcE9uU3BsaXQ7XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMudHNcbnZhciBnZXRUZXh0Q29udGVudEZyb21Ob2RlcyA9ICgkZnJvbSwgbWF4TWF0Y2ggPSA1MDApID0+IHtcbiAgbGV0IHRleHRCZWZvcmUgPSBcIlwiO1xuICBjb25zdCBzbGljZUVuZFBvcyA9ICRmcm9tLnBhcmVudE9mZnNldDtcbiAgJGZyb20ucGFyZW50Lm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIG1heE1hdGNoKSwgc2xpY2VFbmRQb3MsIChub2RlLCBwb3MsIHBhcmVudCwgaW5kZXgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGNodW5rID0gKChfYiA9IChfYSA9IG5vZGUudHlwZS5zcGVjKS50b1RleHQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgICBub2RlLFxuICAgICAgcG9zLFxuICAgICAgcGFyZW50LFxuICAgICAgaW5kZXhcbiAgICB9KSkgfHwgbm9kZS50ZXh0Q29udGVudCB8fCBcIiVsZWFmJVwiO1xuICAgIHRleHRCZWZvcmUgKz0gbm9kZS5pc0F0b20gJiYgIW5vZGUuaXNUZXh0ID8gY2h1bmsgOiBjaHVuay5zbGljZSgwLCBNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIHBvcykpO1xuICB9KTtcbiAgcmV0dXJuIHRleHRCZWZvcmU7XG59O1xuXG4vLyBzcmMvaGVscGVycy9pc01hcmtBY3RpdmUudHNcbmZ1bmN0aW9uIGlzTWFya0FjdGl2ZShzdGF0ZSwgdHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSB7XG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsO1xuICBpZiAoZW1wdHkpIHtcbiAgICByZXR1cm4gISEoc3RhdGUuc3RvcmVkTWFya3MgfHwgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpLmZpbHRlcigobWFyaykgPT4ge1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbWFyay50eXBlLm5hbWU7XG4gICAgfSkuZmluZCgobWFyaykgPT4gb2JqZWN0SW5jbHVkZXMobWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKTtcbiAgfVxuICBsZXQgc2VsZWN0aW9uUmFuZ2UgPSAwO1xuICBjb25zdCBtYXJrUmFuZ2VzID0gW107XG4gIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIGNvbnN0IGZyb20gPSAkZnJvbS5wb3M7XG4gICAgY29uc3QgdG8gPSAkdG8ucG9zO1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmICghbm9kZS5pc1RleHQgJiYgIW5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbGF0aXZlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyk7XG4gICAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgICAgY29uc3QgcmFuZ2UyID0gcmVsYXRpdmVUbyAtIHJlbGF0aXZlRnJvbTtcbiAgICAgIHNlbGVjdGlvblJhbmdlICs9IHJhbmdlMjtcbiAgICAgIG1hcmtSYW5nZXMucHVzaChcbiAgICAgICAgLi4ubm9kZS5tYXJrcy5tYXAoKG1hcmspID0+ICh7XG4gICAgICAgICAgbWFyayxcbiAgICAgICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXG4gICAgICAgICAgdG86IHJlbGF0aXZlVG9cbiAgICAgICAgfSkpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbiAgaWYgKHNlbGVjdGlvblJhbmdlID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG1hdGNoZWRSYW5nZSA9IG1hcmtSYW5nZXMuZmlsdGVyKChtYXJrUmFuZ2UpID0+IHtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZS5uYW1lID09PSBtYXJrUmFuZ2UubWFyay50eXBlLm5hbWU7XG4gIH0pLmZpbHRlcigobWFya1JhbmdlKSA9PiBvYmplY3RJbmNsdWRlcyhtYXJrUmFuZ2UubWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKS5yZWR1Y2UoKHN1bSwgbWFya1JhbmdlKSA9PiBzdW0gKyBtYXJrUmFuZ2UudG8gLSBtYXJrUmFuZ2UuZnJvbSwgMCk7XG4gIGNvbnN0IGV4Y2x1ZGVkUmFuZ2UgPSBtYXJrUmFuZ2VzLmZpbHRlcigobWFya1JhbmdlKSA9PiB7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtSYW5nZS5tYXJrLnR5cGUgIT09IHR5cGUgJiYgbWFya1JhbmdlLm1hcmsudHlwZS5leGNsdWRlcyh0eXBlKTtcbiAgfSkucmVkdWNlKChzdW0sIG1hcmtSYW5nZSkgPT4gc3VtICsgbWFya1JhbmdlLnRvIC0gbWFya1JhbmdlLmZyb20sIDApO1xuICBjb25zdCByYW5nZSA9IG1hdGNoZWRSYW5nZSA+IDAgPyBtYXRjaGVkUmFuZ2UgKyBleGNsdWRlZFJhbmdlIDogbWF0Y2hlZFJhbmdlO1xuICByZXR1cm4gcmFuZ2UgPj0gc2VsZWN0aW9uUmFuZ2U7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2lzQWN0aXZlLnRzXG5mdW5jdGlvbiBpc0FjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyA9IHt9KSB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG51bGwsIGF0dHJpYnV0ZXMpIHx8IGlzTWFya0FjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcyk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKG5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGlmIChzY2hlbWFUeXBlID09PSBcIm5vZGVcIikge1xuICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpO1xuICB9XG4gIGlmIChzY2hlbWFUeXBlID09PSBcIm1hcmtcIikge1xuICAgIHJldHVybiBpc01hcmtBY3RpdmUoc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvaXNBdEVuZE9mTm9kZS50c1xudmFyIGlzQXRFbmRPZk5vZGUgPSAoc3RhdGUsIG5vZGVUeXBlKSA9PiB7XG4gIGNvbnN0IHsgJGZyb20sICR0bywgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBpZiAobm9kZVR5cGUpIHtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gZmluZFBhcmVudE5vZGUoKG5vZGUpID0+IG5vZGUudHlwZS5uYW1lID09PSBub2RlVHlwZSkoc3RhdGUuc2VsZWN0aW9uKTtcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgJHBhcmVudFBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBhcmVudE5vZGUucG9zICsgMSk7XG4gICAgaWYgKCRhbmNob3IucG9zICsgMSA9PT0gJHBhcmVudFBvcy5lbmQoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoJHRvLnBhcmVudE9mZnNldCA8ICR0by5wYXJlbnQubm9kZVNpemUgLSAyIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9oZWxwZXJzL2lzQXRTdGFydE9mTm9kZS50c1xudmFyIGlzQXRTdGFydE9mTm9kZSA9IChzdGF0ZSkgPT4ge1xuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgaWYgKCRmcm9tLnBhcmVudE9mZnNldCA+IDAgfHwgJGZyb20ucG9zICE9PSAkdG8ucG9zKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2hlbHBlcnMvaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQudHNcbmZ1bmN0aW9uIGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZW5hYmxlZCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlbmFibGVkKSkge1xuICAgIHJldHVybiBlbmFibGVkLnNvbWUoKGVuYWJsZWRFeHRlbnNpb24pID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgZW5hYmxlZEV4dGVuc2lvbiA9PT0gXCJzdHJpbmdcIiA/IGVuYWJsZWRFeHRlbnNpb24gOiBlbmFibGVkRXh0ZW5zaW9uLm5hbWU7XG4gICAgICByZXR1cm4gbmFtZSA9PT0gZXh0ZW5zaW9uLm5hbWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuYWJsZWQ7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2lzTGlzdC50c1xuZnVuY3Rpb24gaXNMaXN0KG5hbWUsIGV4dGVuc2lvbnMpIHtcbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xuICBjb25zdCBleHRlbnNpb24gPSBub2RlRXh0ZW5zaW9ucy5maW5kKChpdGVtKSA9PiBpdGVtLm5hbWUgPT09IG5hbWUpO1xuICBpZiAoIWV4dGVuc2lvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlXG4gIH07XG4gIGNvbnN0IGdyb3VwID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJncm91cFwiLCBjb250ZXh0KSk7XG4gIGlmICh0eXBlb2YgZ3JvdXAgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdyb3VwLnNwbGl0KFwiIFwiKS5pbmNsdWRlcyhcImxpc3RcIik7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2lzTm9kZUVtcHR5LnRzXG5mdW5jdGlvbiBpc05vZGVFbXB0eShub2RlLCB7XG4gIGNoZWNrQ2hpbGRyZW4gPSB0cnVlLFxuICBpZ25vcmVXaGl0ZXNwYWNlID0gZmFsc2Vcbn0gPSB7fSkge1xuICB2YXIgX2E7XG4gIGlmIChpZ25vcmVXaGl0ZXNwYWNlKSB7XG4gICAgaWYgKG5vZGUudHlwZS5uYW1lID09PSBcImhhcmRCcmVha1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICByZXR1cm4gL15cXHMqJC9tLnRlc3QoKF9hID0gbm9kZS50ZXh0KSAhPSBudWxsID8gX2EgOiBcIlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgcmV0dXJuICFub2RlLnRleHQ7XG4gIH1cbiAgaWYgKG5vZGUuaXNBdG9tIHx8IG5vZGUuaXNMZWFmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChub2RlLmNvbnRlbnQuY2hpbGRDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjaGVja0NoaWxkcmVuKSB7XG4gICAgbGV0IGlzQ29udGVudEVtcHR5ID0gdHJ1ZTtcbiAgICBub2RlLmNvbnRlbnQuZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgICBpZiAoaXNDb250ZW50RW1wdHkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNOb2RlRW1wdHkoY2hpbGROb2RlLCB7IGlnbm9yZVdoaXRlc3BhY2UsIGNoZWNrQ2hpbGRyZW4gfSkpIHtcbiAgICAgICAgaXNDb250ZW50RW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXNDb250ZW50RW1wdHk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcmMvaGVscGVycy9pc05vZGVTZWxlY3Rpb24udHNcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuZnVuY3Rpb24gaXNOb2RlU2VsZWN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb247XG59XG5cbi8vIHNyYy9oZWxwZXJzL01hcHBhYmxlUG9zaXRpb24udHNcbnZhciBNYXBwYWJsZVBvc2l0aW9uID0gY2xhc3MgX01hcHBhYmxlUG9zaXRpb24ge1xuICBjb25zdHJ1Y3Rvcihwb3NpdGlvbikge1xuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIE1hcHBhYmxlUG9zaXRpb24gZnJvbSBhIEpTT04gb2JqZWN0LlxuICAgKi9cbiAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICByZXR1cm4gbmV3IF9NYXBwYWJsZVBvc2l0aW9uKGpzb24ucG9zaXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgTWFwcGFibGVQb3NpdGlvbiB0byBhIEpTT04gb2JqZWN0LlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogdGhpcy5wb3NpdGlvblxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRVcGRhdGVkUG9zaXRpb24ocG9zaXRpb24sIHRyYW5zYWN0aW9uKSB7XG4gIGNvbnN0IG1hcFJlc3VsdCA9IHRyYW5zYWN0aW9uLm1hcHBpbmcubWFwUmVzdWx0KHBvc2l0aW9uLnBvc2l0aW9uKTtcbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogbmV3IE1hcHBhYmxlUG9zaXRpb24obWFwUmVzdWx0LnBvcyksXG4gICAgbWFwUmVzdWx0XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVNYXBwYWJsZVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gIHJldHVybiBuZXcgTWFwcGFibGVQb3NpdGlvbihwb3NpdGlvbik7XG59XG5cbi8vIHNyYy9oZWxwZXJzL3Bvc1RvRE9NUmVjdC50c1xuZnVuY3Rpb24gcG9zVG9ET01SZWN0KHZpZXcsIGZyb20sIHRvKSB7XG4gIGNvbnN0IG1pblBvcyA9IDA7XG4gIGNvbnN0IG1heFBvcyA9IHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZTtcbiAgY29uc3QgcmVzb2x2ZWRGcm9tID0gbWluTWF4KGZyb20sIG1pblBvcywgbWF4UG9zKTtcbiAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKTtcbiAgY29uc3Qgc3RhcnQgPSB2aWV3LmNvb3Jkc0F0UG9zKHJlc29sdmVkRnJvbSk7XG4gIGNvbnN0IGVuZCA9IHZpZXcuY29vcmRzQXRQb3MocmVzb2x2ZWRFbmQsIC0xKTtcbiAgY29uc3QgdG9wID0gTWF0aC5taW4oc3RhcnQudG9wLCBlbmQudG9wKTtcbiAgY29uc3QgYm90dG9tID0gTWF0aC5tYXgoc3RhcnQuYm90dG9tLCBlbmQuYm90dG9tKTtcbiAgY29uc3QgbGVmdCA9IE1hdGgubWluKHN0YXJ0LmxlZnQsIGVuZC5sZWZ0KTtcbiAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChzdGFydC5yaWdodCwgZW5kLnJpZ2h0KTtcbiAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgY29uc3QgeCA9IGxlZnQ7XG4gIGNvbnN0IHkgPSB0b3A7XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgdG9wLFxuICAgIGJvdHRvbSxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIHRvSlNPTjogKCkgPT4gZGF0YVxuICB9O1xufVxuXG4vLyBzcmMvaGVscGVycy9yZXdyaXRlVW5rbm93bkNvbnRlbnQudHNcbmZ1bmN0aW9uIHJld3JpdGVVbmtub3duQ29udGVudElubmVyKHtcbiAganNvbixcbiAgdmFsaWRNYXJrcyxcbiAgdmFsaWROb2RlcyxcbiAgb3B0aW9ucyxcbiAgcmV3cml0dGVuQ29udGVudCA9IFtdXG59KSB7XG4gIGlmIChqc29uLm1hcmtzICYmIEFycmF5LmlzQXJyYXkoanNvbi5tYXJrcykpIHtcbiAgICBqc29uLm1hcmtzID0ganNvbi5tYXJrcy5maWx0ZXIoKG1hcmspID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbWFyayA9PT0gXCJzdHJpbmdcIiA/IG1hcmsgOiBtYXJrLnR5cGU7XG4gICAgICBpZiAodmFsaWRNYXJrcy5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXdyaXR0ZW5Db250ZW50LnB1c2goe1xuICAgICAgICBvcmlnaW5hbDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtYXJrKSksXG4gICAgICAgIHVuc3VwcG9ydGVkOiBuYW1lXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfVxuICBpZiAoanNvbi5jb250ZW50ICYmIEFycmF5LmlzQXJyYXkoanNvbi5jb250ZW50KSkge1xuICAgIGpzb24uY29udGVudCA9IGpzb24uY29udGVudC5tYXAoXG4gICAgICAodmFsdWUpID0+IHJld3JpdGVVbmtub3duQ29udGVudElubmVyKHtcbiAgICAgICAganNvbjogdmFsdWUsXG4gICAgICAgIHZhbGlkTWFya3MsXG4gICAgICAgIHZhbGlkTm9kZXMsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHJld3JpdHRlbkNvbnRlbnRcbiAgICAgIH0pLmpzb25cbiAgICApLmZpbHRlcigoYSkgPT4gYSAhPT0gbnVsbCAmJiBhICE9PSB2b2lkIDApO1xuICB9XG4gIGlmIChqc29uLnR5cGUgJiYgIXZhbGlkTm9kZXMuaGFzKGpzb24udHlwZSkpIHtcbiAgICByZXdyaXR0ZW5Db250ZW50LnB1c2goe1xuICAgICAgb3JpZ2luYWw6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoanNvbikpLFxuICAgICAgdW5zdXBwb3J0ZWQ6IGpzb24udHlwZVxuICAgIH0pO1xuICAgIGlmIChqc29uLmNvbnRlbnQgJiYgQXJyYXkuaXNBcnJheShqc29uLmNvbnRlbnQpICYmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZhbGxiYWNrVG9QYXJhZ3JhcGgpICE9PSBmYWxzZSkge1xuICAgICAganNvbi50eXBlID0gXCJwYXJhZ3JhcGhcIjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb24sXG4gICAgICAgIHJld3JpdHRlbkNvbnRlbnRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBqc29uOiBudWxsLFxuICAgICAgcmV3cml0dGVuQ29udGVudFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsganNvbiwgcmV3cml0dGVuQ29udGVudCB9O1xufVxuZnVuY3Rpb24gcmV3cml0ZVVua25vd25Db250ZW50KGpzb24sIHNjaGVtYSwgb3B0aW9ucykge1xuICByZXR1cm4gcmV3cml0ZVVua25vd25Db250ZW50SW5uZXIoe1xuICAgIGpzb24sXG4gICAgdmFsaWROb2RlczogbmV3IFNldChPYmplY3Qua2V5cyhzY2hlbWEubm9kZXMpKSxcbiAgICB2YWxpZE1hcmtzOiBuZXcgU2V0KE9iamVjdC5rZXlzKHNjaGVtYS5tYXJrcykpLFxuICAgIG9wdGlvbnNcbiAgfSk7XG59XG5cbi8vIHNyYy9jb21tYW5kcy9zZXRNYXJrLnRzXG5mdW5jdGlvbiBjYW5TZXRNYXJrKHN0YXRlLCB0ciwgbmV3TWFya1R5cGUpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gIGxldCBjdXJzb3IgPSBudWxsO1xuICBpZiAoaXNUZXh0U2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjdXJzb3IgPSBzZWxlY3Rpb24uJGN1cnNvcjtcbiAgfVxuICBpZiAoY3Vyc29yKSB7XG4gICAgY29uc3QgY3VycmVudE1hcmtzID0gKF9hID0gc3RhdGUuc3RvcmVkTWFya3MpICE9IG51bGwgPyBfYSA6IGN1cnNvci5tYXJrcygpO1xuICAgIGNvbnN0IHBhcmVudEFsbG93c01hcmtUeXBlID0gY3Vyc29yLnBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKTtcbiAgICByZXR1cm4gcGFyZW50QWxsb3dzTWFya1R5cGUgJiYgKCEhbmV3TWFya1R5cGUuaXNJblNldChjdXJyZW50TWFya3MpIHx8ICFjdXJyZW50TWFya3Muc29tZSgobWFyaykgPT4gbWFyay50eXBlLmV4Y2x1ZGVzKG5ld01hcmtUeXBlKSkpO1xuICB9XG4gIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gIHJldHVybiByYW5nZXMuc29tZSgoeyAkZnJvbSwgJHRvIH0pID0+IHtcbiAgICBsZXQgc29tZU5vZGVTdXBwb3J0c01hcmsgPSAkZnJvbS5kZXB0aCA9PT0gMCA/IHN0YXRlLmRvYy5pbmxpbmVDb250ZW50ICYmIHN0YXRlLmRvYy50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKSA6IGZhbHNlO1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgX3BvcywgcGFyZW50KSA9PiB7XG4gICAgICBpZiAoc29tZU5vZGVTdXBwb3J0c01hcmspIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuaXNJbmxpbmUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50QWxsb3dzTWFya1R5cGUgPSAhcGFyZW50IHx8IHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKTtcbiAgICAgICAgY29uc3QgY3VycmVudE1hcmtzQWxsb3dNYXJrVHlwZSA9ICEhbmV3TWFya1R5cGUuaXNJblNldChub2RlLm1hcmtzKSB8fCAhbm9kZS5tYXJrcy5zb21lKChvdGhlck1hcmspID0+IG90aGVyTWFyay50eXBlLmV4Y2x1ZGVzKG5ld01hcmtUeXBlKSk7XG4gICAgICAgIHNvbWVOb2RlU3VwcG9ydHNNYXJrID0gcGFyZW50QWxsb3dzTWFya1R5cGUgJiYgY3VycmVudE1hcmtzQWxsb3dNYXJrVHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhc29tZU5vZGVTdXBwb3J0c01hcms7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNvbWVOb2RlU3VwcG9ydHNNYXJrO1xuICB9KTtcbn1cbnZhciBzZXRNYXJrID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBpZiAoZW1wdHkpIHtcbiAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdHlwZSk7XG4gICAgICB0ci5hZGRTdG9yZWRNYXJrKFxuICAgICAgICB0eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgLi4ub2xkQXR0cmlidXRlcyxcbiAgICAgICAgICAuLi5hdHRyaWJ1dGVzXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHJhbmdlLiRmcm9tLnBvcztcbiAgICAgICAgY29uc3QgdG8gPSByYW5nZS4kdG8ucG9zO1xuICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgY29uc3QgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pO1xuICAgICAgICAgIGNvbnN0IHRyaW1tZWRUbyA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICBjb25zdCBzb21lSGFzTWFyayA9IG5vZGUubWFya3MuZmluZCgobWFyaykgPT4gbWFyay50eXBlID09PSB0eXBlKTtcbiAgICAgICAgICBpZiAoc29tZUhhc01hcmspIHtcbiAgICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhcbiAgICAgICAgICAgICAgICAgIHRyaW1tZWRGcm9tLFxuICAgICAgICAgICAgICAgICAgdHJpbW1lZFRvLFxuICAgICAgICAgICAgICAgICAgdHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5tYXJrLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ci5hZGRNYXJrKHRyaW1tZWRGcm9tLCB0cmltbWVkVG8sIHR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5TZXRNYXJrKHN0YXRlLCB0ciwgdHlwZSk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc2V0TWV0YS50c1xudmFyIHNldE1ldGEgPSAoa2V5LCB2YWx1ZSkgPT4gKHsgdHIgfSkgPT4ge1xuICB0ci5zZXRNZXRhKGtleSwgdmFsdWUpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZXROb2RlLnRzXG5pbXBvcnQgeyBzZXRCbG9ja1R5cGUgfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIHNldE5vZGUgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2gsIGNoYWluIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGxldCBhdHRyaWJ1dGVzVG9Db3B5O1xuICBpZiAoc3RhdGUuc2VsZWN0aW9uLiRhbmNob3Iuc2FtZVBhcmVudChzdGF0ZS5zZWxlY3Rpb24uJGhlYWQpKSB7XG4gICAgYXR0cmlidXRlc1RvQ29weSA9IHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnBhcmVudC5hdHRycztcbiAgfVxuICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spIHtcbiAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IEN1cnJlbnRseSBcInNldE5vZGUoKVwiIG9ubHkgc3VwcG9ydHMgdGV4dCBibG9jayBub2Rlcy4nKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNoYWluKCkuY29tbWFuZCgoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgY29uc3QgY2FuU2V0QmxvY2sgPSBzZXRCbG9ja1R5cGUodHlwZSwgeyAuLi5hdHRyaWJ1dGVzVG9Db3B5LCAuLi5hdHRyaWJ1dGVzIH0pKHN0YXRlKTtcbiAgICBpZiAoY2FuU2V0QmxvY2spIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpO1xuICB9KS5jb21tYW5kKCh7IHN0YXRlOiB1cGRhdGVkU3RhdGUgfSkgPT4ge1xuICAgIHJldHVybiBzZXRCbG9ja1R5cGUodHlwZSwgeyAuLi5hdHRyaWJ1dGVzVG9Db3B5LCAuLi5hdHRyaWJ1dGVzIH0pKHVwZGF0ZWRTdGF0ZSwgZGlzcGF0Y2gpO1xuICB9KS5ydW4oKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZXROb2RlU2VsZWN0aW9uLnRzXG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uIGFzIE5vZGVTZWxlY3Rpb24yIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBzZXROb2RlU2VsZWN0aW9uID0gKHBvc2l0aW9uKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB7IGRvYyB9ID0gdHI7XG4gICAgY29uc3QgZnJvbSA9IG1pbk1heChwb3NpdGlvbiwgMCwgZG9jLmNvbnRlbnQuc2l6ZSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbjIuY3JlYXRlKGRvYywgZnJvbSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc2V0VGV4dERpcmVjdGlvbi50c1xudmFyIHNldFRleHREaXJlY3Rpb24gPSAoZGlyZWN0aW9uLCBwb3NpdGlvbikgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgbGV0IGZyb207XG4gIGxldCB0bztcbiAgaWYgKHR5cGVvZiBwb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgIGZyb20gPSBwb3NpdGlvbjtcbiAgICB0byA9IHBvc2l0aW9uO1xuICB9IGVsc2UgaWYgKHBvc2l0aW9uICYmIFwiZnJvbVwiIGluIHBvc2l0aW9uICYmIFwidG9cIiBpbiBwb3NpdGlvbikge1xuICAgIGZyb20gPSBwb3NpdGlvbi5mcm9tO1xuICAgIHRvID0gcG9zaXRpb24udG87XG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9IHNlbGVjdGlvbi5mcm9tO1xuICAgIHRvID0gc2VsZWN0aW9uLnRvO1xuICB9XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdm9pZCAwLCB7XG4gICAgICAgIC4uLm5vZGUuYXR0cnMsXG4gICAgICAgIGRpcjogZGlyZWN0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZXRUZXh0U2VsZWN0aW9uLnRzXG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb241IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBzZXRUZXh0U2VsZWN0aW9uID0gKHBvc2l0aW9uKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB7IGRvYyB9ID0gdHI7XG4gICAgY29uc3QgeyBmcm9tLCB0byB9ID0gdHlwZW9mIHBvc2l0aW9uID09PSBcIm51bWJlclwiID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiBwb3NpdGlvbjtcbiAgICBjb25zdCBtaW5Qb3MgPSBUZXh0U2VsZWN0aW9uNS5hdFN0YXJ0KGRvYykuZnJvbTtcbiAgICBjb25zdCBtYXhQb3MgPSBUZXh0U2VsZWN0aW9uNS5hdEVuZChkb2MpLnRvO1xuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcyk7XG4gICAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uNS5jcmVhdGUoZG9jLCByZXNvbHZlZEZyb20sIHJlc29sdmVkRW5kKTtcbiAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zaW5rTGlzdEl0ZW0udHNcbmltcG9ydCB7IHNpbmtMaXN0SXRlbSBhcyBvcmlnaW5hbFNpbmtMaXN0SXRlbSB9IGZyb20gXCJAdGlwdGFwL3BtL3NjaGVtYS1saXN0XCI7XG52YXIgc2lua0xpc3RJdGVtID0gKHR5cGVPck5hbWUpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICByZXR1cm4gb3JpZ2luYWxTaW5rTGlzdEl0ZW0odHlwZSkoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zcGxpdEJsb2NrLnRzXG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uIGFzIE5vZGVTZWxlY3Rpb24zLCBUZXh0U2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb242IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmltcG9ydCB7IGNhblNwbGl0IH0gZnJvbSBcIkB0aXB0YXAvcG0vdHJhbnNmb3JtXCI7XG5mdW5jdGlvbiBlbnN1cmVNYXJrcyhzdGF0ZSwgc3BsaXR0YWJsZU1hcmtzKSB7XG4gIGNvbnN0IG1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgfHwgc3RhdGUuc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCk7XG4gIGlmIChtYXJrcykge1xuICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IHNwbGl0dGFibGVNYXJrcyA9PSBudWxsID8gdm9pZCAwIDogc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XG4gICAgc3RhdGUudHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XG4gIH1cbn1cbnZhciBzcGxpdEJsb2NrID0gKHsga2VlcE1hcmtzID0gdHJ1ZSB9ID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGVkaXRvciB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHRyO1xuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgJGZyb20ubm9kZSgpLnR5cGUubmFtZSwgJGZyb20ubm9kZSgpLmF0dHJzKTtcbiAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24zICYmIHNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICBpZiAoISRmcm9tLnBhcmVudE9mZnNldCB8fCAhY2FuU3BsaXQoZG9jLCAkZnJvbS5wb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgICBlbnN1cmVNYXJrcyhzdGF0ZSwgZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuc3BsaXR0YWJsZU1hcmtzKTtcbiAgICAgIH1cbiAgICAgIHRyLnNwbGl0KCRmcm9tLnBvcykuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCEkZnJvbS5wYXJlbnQuaXNCbG9jaykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhdEVuZCA9ICR0by5wYXJlbnRPZmZzZXQgPT09ICR0by5wYXJlbnQuY29udGVudC5zaXplO1xuICBjb25zdCBkZWZsdCA9ICRmcm9tLmRlcHRoID09PSAwID8gdm9pZCAwIDogZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZSgtMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcigtMSkpKTtcbiAgbGV0IHR5cGVzID0gYXRFbmQgJiYgZGVmbHQgPyBbXG4gICAge1xuICAgICAgdHlwZTogZGVmbHQsXG4gICAgICBhdHRyczogbmV3QXR0cmlidXRlc1xuICAgIH1cbiAgXSA6IHZvaWQgMDtcbiAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuICBpZiAoIXR5cGVzICYmICFjYW4gJiYgY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdm9pZCAwKSkge1xuICAgIGNhbiA9IHRydWU7XG4gICAgdHlwZXMgPSBkZWZsdCA/IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogZGVmbHQsXG4gICAgICAgIGF0dHJzOiBuZXdBdHRyaWJ1dGVzXG4gICAgICB9XG4gICAgXSA6IHZvaWQgMDtcbiAgfVxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBpZiAoY2FuKSB7XG4gICAgICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbjYpIHtcbiAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgICBpZiAoZGVmbHQgJiYgIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT09IGRlZmx0KSB7XG4gICAgICAgIGNvbnN0IGZpcnN0MiA9IHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKTtcbiAgICAgICAgY29uc3QgJGZpcnN0ID0gdHIuZG9jLnJlc29sdmUoZmlyc3QyKTtcbiAgICAgICAgaWYgKCRmcm9tLm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRmaXJzdC5pbmRleCgpLCAkZmlyc3QuaW5kZXgoKSArIDEsIGRlZmx0KSkge1xuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCBkZWZsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgZW5zdXJlTWFya3Moc3RhdGUsIGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLnNwbGl0dGFibGVNYXJrcyk7XG4gICAgfVxuICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gIH1cbiAgcmV0dXJuIGNhbjtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zcGxpdExpc3RJdGVtLnRzXG5pbXBvcnQgeyBGcmFnbWVudCBhcyBGcmFnbWVudDMsIFNsaWNlIH0gZnJvbSBcIkB0aXB0YXAvcG0vbW9kZWxcIjtcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvbjcgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgY2FuU3BsaXQgYXMgY2FuU3BsaXQyIH0gZnJvbSBcIkB0aXB0YXAvcG0vdHJhbnNmb3JtXCI7XG52YXIgc3BsaXRMaXN0SXRlbSA9ICh0eXBlT3JOYW1lLCBvdmVycmlkZUF0dHJzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGVkaXRvciB9KSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCBub2RlID0gc3RhdGUuc2VsZWN0aW9uLm5vZGU7XG4gIGlmIChub2RlICYmIG5vZGUuaXNCbG9jayB8fCAkZnJvbS5kZXB0aCA8IDIgfHwgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBncmFuZFBhcmVudCA9ICRmcm9tLm5vZGUoLTEpO1xuICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPT0gdHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuYXR0cmlidXRlcztcbiAgaWYgKCRmcm9tLnBhcmVudC5jb250ZW50LnNpemUgPT09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PT0gJGZyb20uaW5kZXhBZnRlcigtMSkpIHtcbiAgICBpZiAoJGZyb20uZGVwdGggPT09IDIgfHwgJGZyb20ubm9kZSgtMykudHlwZSAhPT0gdHlwZSB8fCAkZnJvbS5pbmRleCgtMikgIT09ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgbGV0IHdyYXAgPSBGcmFnbWVudDMuZW1wdHk7XG4gICAgICBjb25zdCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogMztcbiAgICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCAtIGRlcHRoQmVmb3JlOyBkID49ICRmcm9tLmRlcHRoIC0gMzsgZCAtPSAxKSB7XG4gICAgICAgIHdyYXAgPSBGcmFnbWVudDMuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkod3JhcCkpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVwdGhBZnRlciA9IChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDEgOiAkZnJvbS5pbmRleEFmdGVyKC0yKSA8ICRmcm9tLm5vZGUoLTMpLmNoaWxkQ291bnQgPyAyIDogM1xuICAgICAgKTtcbiAgICAgIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlczIgPSB7XG4gICAgICAgIC4uLmdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpLFxuICAgICAgICAuLi5vdmVycmlkZUF0dHJzXG4gICAgICB9O1xuICAgICAgY29uc3QgbmV4dFR5cGUyID0gKChfYSA9IHR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY3JlYXRlQW5kRmlsbChuZXdOZXh0VHlwZUF0dHJpYnV0ZXMyKSkgfHwgdm9pZCAwO1xuICAgICAgd3JhcCA9IHdyYXAuYXBwZW5kKEZyYWdtZW50My5mcm9tKHR5cGUuY3JlYXRlQW5kRmlsbChudWxsLCBuZXh0VHlwZTIpIHx8IHZvaWQgMCkpO1xuICAgICAgY29uc3Qgc3RhcnQgPSAkZnJvbS5iZWZvcmUoJGZyb20uZGVwdGggLSAoZGVwdGhCZWZvcmUgLSAxKSk7XG4gICAgICB0ci5yZXBsYWNlKHN0YXJ0LCAkZnJvbS5hZnRlcigtZGVwdGhBZnRlciksIG5ldyBTbGljZSh3cmFwLCA0IC0gZGVwdGhCZWZvcmUsIDApKTtcbiAgICAgIGxldCBzZWwgPSAtMTtcbiAgICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIHRyLmRvYy5jb250ZW50LnNpemUsIChuLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKHNlbCA+IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLmlzVGV4dGJsb2NrICYmIG4uY29udGVudC5zaXplID09PSAwKSB7XG4gICAgICAgICAgc2VsID0gcG9zICsgMTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoc2VsID4gLTEpIHtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb243Lm5lYXIodHIuZG9jLnJlc29sdmUoc2VsKSkpO1xuICAgICAgfVxuICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgbmV4dFR5cGUgPSAkdG8ucG9zID09PSAkZnJvbS5lbmQoKSA/IGdyYW5kUGFyZW50LmNvbnRlbnRNYXRjaEF0KDApLmRlZmF1bHRUeXBlIDogbnVsbDtcbiAgY29uc3QgbmV3VHlwZUF0dHJpYnV0ZXMgPSB7XG4gICAgLi4uZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMsIGdyYW5kUGFyZW50LnR5cGUubmFtZSwgZ3JhbmRQYXJlbnQuYXR0cnMpLFxuICAgIC4uLm92ZXJyaWRlQXR0cnNcbiAgfTtcbiAgY29uc3QgbmV3TmV4dFR5cGVBdHRyaWJ1dGVzID0ge1xuICAgIC4uLmdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpLFxuICAgIC4uLm92ZXJyaWRlQXR0cnNcbiAgfTtcbiAgdHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gIGNvbnN0IHR5cGVzID0gbmV4dFR5cGUgPyBbXG4gICAgeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfSxcbiAgICB7IHR5cGU6IG5leHRUeXBlLCBhdHRyczogbmV3TmV4dFR5cGVBdHRyaWJ1dGVzIH1cbiAgXSA6IFt7IHR5cGUsIGF0dHJzOiBuZXdUeXBlQXR0cmlidXRlcyB9XTtcbiAgaWYgKCFjYW5TcGxpdDIodHIuZG9jLCAkZnJvbS5wb3MsIDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGU7XG4gICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCk7XG4gICAgdHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICBpZiAoIW1hcmtzIHx8ICFkaXNwYXRjaCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xuICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3RvZ2dsZUxpc3QudHNcbmltcG9ydCB7IGNhbkpvaW4gfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbnZhciBqb2luTGlzdEJhY2t3YXJkcyA9ICh0ciwgbGlzdFR5cGUpID0+IHtcbiAgY29uc3QgbGlzdCA9IGZpbmRQYXJlbnROb2RlKChub2RlKSA9PiBub2RlLnR5cGUgPT09IGxpc3RUeXBlKSh0ci5zZWxlY3Rpb24pO1xuICBpZiAoIWxpc3QpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCBsaXN0LnBvcyAtIDEpKS5iZWZvcmUobGlzdC5kZXB0aCk7XG4gIGlmIChiZWZvcmUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IG5vZGVCZWZvcmUgPSB0ci5kb2Mubm9kZUF0KGJlZm9yZSk7XG4gIGNvbnN0IGNhbkpvaW5CYWNrd2FyZHMgPSBsaXN0Lm5vZGUudHlwZSA9PT0gKG5vZGVCZWZvcmUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGVCZWZvcmUudHlwZSkgJiYgY2FuSm9pbih0ci5kb2MsIGxpc3QucG9zKTtcbiAgaWYgKCFjYW5Kb2luQmFja3dhcmRzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHIuam9pbihsaXN0LnBvcyk7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBqb2luTGlzdEZvcndhcmRzID0gKHRyLCBsaXN0VHlwZSkgPT4ge1xuICBjb25zdCBsaXN0ID0gZmluZFBhcmVudE5vZGUoKG5vZGUpID0+IG5vZGUudHlwZSA9PT0gbGlzdFR5cGUpKHRyLnNlbGVjdGlvbik7XG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGFmdGVyID0gdHIuZG9jLnJlc29sdmUobGlzdC5zdGFydCkuYWZ0ZXIobGlzdC5kZXB0aCk7XG4gIGlmIChhZnRlciA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qgbm9kZUFmdGVyID0gdHIuZG9jLm5vZGVBdChhZnRlcik7XG4gIGNvbnN0IGNhbkpvaW5Gb3J3YXJkcyA9IGxpc3Qubm9kZS50eXBlID09PSAobm9kZUFmdGVyID09IG51bGwgPyB2b2lkIDAgOiBub2RlQWZ0ZXIudHlwZSkgJiYgY2FuSm9pbih0ci5kb2MsIGFmdGVyKTtcbiAgaWYgKCFjYW5Kb2luRm9yd2FyZHMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0ci5qb2luKGFmdGVyKTtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIHRvZ2dsZUxpc3QgPSAobGlzdFR5cGVPck5hbWUsIGl0ZW1UeXBlT3JOYW1lLCBrZWVwTWFya3MsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgZWRpdG9yLCB0ciwgc3RhdGUsIGRpc3BhdGNoLCBjaGFpbiwgY29tbWFuZHMsIGNhbiB9KSA9PiB7XG4gIGNvbnN0IHsgZXh0ZW5zaW9ucywgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlcjtcbiAgY29uc3QgbGlzdFR5cGUgPSBnZXROb2RlVHlwZShsaXN0VHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgaXRlbVR5cGUgPSBnZXROb2RlVHlwZShpdGVtVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZTtcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb247XG4gIGNvbnN0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpO1xuICBpZiAoIXJhbmdlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHBhcmVudExpc3QgPSBmaW5kUGFyZW50Tm9kZSgobm9kZSkgPT4gaXNMaXN0KG5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKSkoc2VsZWN0aW9uKTtcbiAgaWYgKHJhbmdlLmRlcHRoID49IDEgJiYgcGFyZW50TGlzdCAmJiByYW5nZS5kZXB0aCAtIHBhcmVudExpc3QuZGVwdGggPD0gMSkge1xuICAgIGlmIChwYXJlbnRMaXN0Lm5vZGUudHlwZSA9PT0gbGlzdFR5cGUpIHtcbiAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0TGlzdEl0ZW0oaXRlbVR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNMaXN0KHBhcmVudExpc3Qubm9kZS50eXBlLm5hbWUsIGV4dGVuc2lvbnMpICYmIGxpc3RUeXBlLnZhbGlkQ29udGVudChwYXJlbnRMaXN0Lm5vZGUuY29udGVudCkgJiYgZGlzcGF0Y2gpIHtcbiAgICAgIHJldHVybiBjaGFpbigpLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBhcmVudExpc3QucG9zLCBsaXN0VHlwZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSkuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKS5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSkucnVuKCk7XG4gICAgfVxuICB9XG4gIGlmICgha2VlcE1hcmtzIHx8ICFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gY2hhaW4oKS5jb21tYW5kKCgpID0+IHtcbiAgICAgIGNvbnN0IGNhbldyYXBJbkxpc3QgPSBjYW4oKS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChjYW5XcmFwSW5MaXN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICB9KS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKS5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RGb3J3YXJkcyh0ciwgbGlzdFR5cGUpKS5ydW4oKTtcbiAgfVxuICByZXR1cm4gY2hhaW4oKS5jb21tYW5kKCgpID0+IHtcbiAgICBjb25zdCBjYW5XcmFwSW5MaXN0ID0gY2FuKCkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcyk7XG4gICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XG4gICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XG4gICAgaWYgKGNhbldyYXBJbkxpc3QpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpO1xuICB9KS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKS5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RGb3J3YXJkcyh0ciwgbGlzdFR5cGUpKS5ydW4oKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy90b2dnbGVNYXJrLnRzXG52YXIgdG9nZ2xlTWFyayA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30sIG9wdGlvbnMgPSB7fSkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgY29uc3QgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgaXNBY3RpdmUyID0gaXNNYXJrQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGlzQWN0aXZlMikge1xuICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodHlwZSwgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSB9KTtcbiAgfVxuICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0eXBlLCBhdHRyaWJ1dGVzKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy90b2dnbGVOb2RlLnRzXG52YXIgdG9nZ2xlTm9kZSA9ICh0eXBlT3JOYW1lLCB0b2dnbGVUeXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCB0b2dnbGVUeXBlID0gZ2V0Tm9kZVR5cGUodG9nZ2xlVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgaXNBY3RpdmUyID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgbGV0IGF0dHJpYnV0ZXNUb0NvcHk7XG4gIGlmIChzdGF0ZS5zZWxlY3Rpb24uJGFuY2hvci5zYW1lUGFyZW50KHN0YXRlLnNlbGVjdGlvbi4kaGVhZCkpIHtcbiAgICBhdHRyaWJ1dGVzVG9Db3B5ID0gc3RhdGUuc2VsZWN0aW9uLiRhbmNob3IucGFyZW50LmF0dHJzO1xuICB9XG4gIGlmIChpc0FjdGl2ZTIpIHtcbiAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0b2dnbGVUeXBlLCBhdHRyaWJ1dGVzVG9Db3B5KTtcbiAgfVxuICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0eXBlLCB7IC4uLmF0dHJpYnV0ZXNUb0NvcHksIC4uLmF0dHJpYnV0ZXMgfSk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvdG9nZ2xlV3JhcC50c1xudmFyIHRvZ2dsZVdyYXAgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgaXNBY3RpdmUyID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGlzQWN0aXZlMikge1xuICAgIHJldHVybiBjb21tYW5kcy5saWZ0KHR5cGUpO1xuICB9XG4gIHJldHVybiBjb21tYW5kcy53cmFwSW4odHlwZSwgYXR0cmlidXRlcyk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvdW5kb0lucHV0UnVsZS50c1xudmFyIHVuZG9JbnB1dFJ1bGUgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCBwbHVnaW5zID0gc3RhdGUucGx1Z2lucztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICBsZXQgdW5kb2FibGU7XG4gICAgaWYgKHBsdWdpbi5zcGVjLmlzSW5wdXRSdWxlcyAmJiAodW5kb2FibGUgPSBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpKSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XG4gICAgICAgIGNvbnN0IHRvVW5kbyA9IHVuZG9hYmxlLnRyYW5zZm9ybTtcbiAgICAgICAgZm9yIChsZXQgaiA9IHRvVW5kby5zdGVwcy5sZW5ndGggLSAxOyBqID49IDA7IGogLT0gMSkge1xuICAgICAgICAgIHRyLnN0ZXAodG9VbmRvLnN0ZXBzW2pdLmludmVydCh0b1VuZG8uZG9jc1tqXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRvYWJsZS50ZXh0KSB7XG4gICAgICAgICAgY29uc3QgbWFya3MgPSB0ci5kb2MucmVzb2x2ZSh1bmRvYWJsZS5mcm9tKS5tYXJrcygpO1xuICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvLCBzdGF0ZS5zY2hlbWEudGV4dCh1bmRvYWJsZS50ZXh0LCBtYXJrcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyLmRlbGV0ZSh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50byk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvdW5zZXRBbGxNYXJrcy50c1xudmFyIHVuc2V0QWxsTWFya3MgPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xuICBpZiAoZW1wdHkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy91bnNldE1hcmsudHNcbnZhciB1bnNldE1hcmsgPSAodHlwZU9yTmFtZSwgb3B0aW9ucyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IHsgJGZyb20sIGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgaWYgKCFkaXNwYXRjaCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlbXB0eSAmJiBleHRlbmRFbXB0eU1hcmtSYW5nZSkge1xuICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgYXR0cnMgPSAoX2EgPSAkZnJvbS5tYXJrcygpLmZpbmQoKG1hcmspID0+IG1hcmsudHlwZSA9PT0gdHlwZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hdHRycztcbiAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cnMpO1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgZnJvbSA9IHJhbmdlLmZyb207XG4gICAgICB0byA9IHJhbmdlLnRvO1xuICAgIH1cbiAgICB0ci5yZW1vdmVNYXJrKGZyb20sIHRvLCB0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zLCB0eXBlKTtcbiAgICB9KTtcbiAgfVxuICB0ci5yZW1vdmVTdG9yZWRNYXJrKHR5cGUpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy91bnNldFRleHREaXJlY3Rpb24udHNcbnZhciB1bnNldFRleHREaXJlY3Rpb24gPSAocG9zaXRpb24pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gIGxldCBmcm9tO1xuICBsZXQgdG87XG4gIGlmICh0eXBlb2YgcG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICBmcm9tID0gcG9zaXRpb247XG4gICAgdG8gPSBwb3NpdGlvbjtcbiAgfSBlbHNlIGlmIChwb3NpdGlvbiAmJiBcImZyb21cIiBpbiBwb3NpdGlvbiAmJiBcInRvXCIgaW4gcG9zaXRpb24pIHtcbiAgICBmcm9tID0gcG9zaXRpb24uZnJvbTtcbiAgICB0byA9IHBvc2l0aW9uLnRvO1xuICB9IGVsc2Uge1xuICAgIGZyb20gPSBzZWxlY3Rpb24uZnJvbTtcbiAgICB0byA9IHNlbGVjdGlvbi50bztcbiAgfVxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3QXR0cnMgPSB7IC4uLm5vZGUuYXR0cnMgfTtcbiAgICAgIGRlbGV0ZSBuZXdBdHRycy5kaXI7XG4gICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdm9pZCAwLCBuZXdBdHRycyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvdXBkYXRlQXR0cmlidXRlcy50c1xudmFyIHVwZGF0ZUF0dHJpYnV0ZXMgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgbGV0IG5vZGVUeXBlID0gbnVsbDtcbiAgbGV0IG1hcmtUeXBlID0gbnVsbDtcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKFxuICAgIHR5cGVvZiB0eXBlT3JOYW1lID09PSBcInN0cmluZ1wiID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSxcbiAgICBzdGF0ZS5zY2hlbWFcbiAgKTtcbiAgaWYgKCFzY2hlbWFUeXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzY2hlbWFUeXBlID09PSBcIm5vZGVcIikge1xuICAgIG5vZGVUeXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgfVxuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJtYXJrXCIpIHtcbiAgICBtYXJrVHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIH1cbiAgbGV0IGNhblVwZGF0ZSA9IGZhbHNlO1xuICB0ci5zZWxlY3Rpb24ucmFuZ2VzLmZvckVhY2goKHJhbmdlKSA9PiB7XG4gICAgY29uc3QgZnJvbSA9IHJhbmdlLiRmcm9tLnBvcztcbiAgICBjb25zdCB0byA9IHJhbmdlLiR0by5wb3M7XG4gICAgbGV0IGxhc3RQb3M7XG4gICAgbGV0IGxhc3ROb2RlO1xuICAgIGxldCB0cmltbWVkRnJvbTtcbiAgICBsZXQgdHJpbW1lZFRvO1xuICAgIGlmICh0ci5zZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICBjYW5VcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKTtcbiAgICAgICAgICB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgbGFzdFBvcyA9IHBvcztcbiAgICAgICAgICBsYXN0Tm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChwb3MgPCBmcm9tICYmIG5vZGVUeXBlICYmIG5vZGVUeXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICBjYW5VcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKTtcbiAgICAgICAgICB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgbGFzdFBvcyA9IHBvcztcbiAgICAgICAgICBsYXN0Tm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bykge1xuICAgICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYW5VcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB2b2lkIDAsIHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXJrVHlwZSAmJiBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKChtYXJrKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FuVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcm9tMiA9IE1hdGgubWF4KHBvcywgZnJvbSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkVG8yID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayhcbiAgICAgICAgICAgICAgICAgICAgdHJpbW1lZEZyb20yLFxuICAgICAgICAgICAgICAgICAgICB0cmltbWVkVG8yLFxuICAgICAgICAgICAgICAgICAgICBtYXJrVHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChsYXN0Tm9kZSkge1xuICAgICAgaWYgKGxhc3RQb3MgIT09IHZvaWQgMCAmJiBkaXNwYXRjaCkge1xuICAgICAgICB0ci5zZXROb2RlTWFya3VwKGxhc3RQb3MsIHZvaWQgMCwge1xuICAgICAgICAgIC4uLmxhc3ROb2RlLmF0dHJzLFxuICAgICAgICAgIC4uLmF0dHJpYnV0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobWFya1R5cGUgJiYgbGFzdE5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgIGxhc3ROb2RlLm1hcmtzLmZvckVhY2goKG1hcmspID0+IHtcbiAgICAgICAgICBpZiAobWFya1R5cGUgPT09IG1hcmsudHlwZSAmJiBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdHIuYWRkTWFyayhcbiAgICAgICAgICAgICAgdHJpbW1lZEZyb20sXG4gICAgICAgICAgICAgIHRyaW1tZWRUbyxcbiAgICAgICAgICAgICAgbWFya1R5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAuLi5tYXJrLmF0dHJzLFxuICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2FuVXBkYXRlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3dyYXBJbi50c1xuaW1wb3J0IHsgd3JhcEluIGFzIG9yaWdpbmFsV3JhcEluIH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcbnZhciB3cmFwSW4gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgcmV0dXJuIG9yaWdpbmFsV3JhcEluKHR5cGUsIGF0dHJpYnV0ZXMpKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvd3JhcEluTGlzdC50c1xuaW1wb3J0IHsgd3JhcEluTGlzdCBhcyBvcmlnaW5hbFdyYXBJbkxpc3QgfSBmcm9tIFwiQHRpcHRhcC9wbS9zY2hlbWEtbGlzdFwiO1xudmFyIHdyYXBJbkxpc3QgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgcmV0dXJuIG9yaWdpbmFsV3JhcEluTGlzdCh0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL0VkaXRvci50c1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gXCJAdGlwdGFwL3BtL3ZpZXdcIjtcblxuLy8gc3JjL0V2ZW50RW1pdHRlci50c1xudmFyIEV2ZW50RW1pdHRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgfVxuICBvbihldmVudCwgZm4pIHtcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50XSkge1xuICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gW107XG4gICAgfVxuICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XS5wdXNoKGZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3NbZXZlbnRdO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvZmYoZXZlbnQsIGZuKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3NbZXZlbnRdO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGlmIChmbikge1xuICAgICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0gPSBjYWxsYmFja3MuZmlsdGVyKChjYWxsYmFjaykgPT4gY2FsbGJhY2sgIT09IGZuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9uY2UoZXZlbnQsIGZuKSB7XG4gICAgY29uc3Qgb25jZUZuID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHRoaXMub2ZmKGV2ZW50LCBvbmNlRm4pO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgb25jZUZuKTtcbiAgfVxuICByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgfVxufTtcblxuLy8gc3JjL0V4dGVuc2lvbk1hbmFnZXIudHNcbmltcG9ydCB7IGtleW1hcCB9IGZyb20gXCJAdGlwdGFwL3BtL2tleW1hcFwiO1xuXG4vLyBzcmMvSW5wdXRSdWxlLnRzXG5pbXBvcnQgeyBGcmFnbWVudCBhcyBGcmFnbWVudDQgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBJbnB1dFJ1bGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmZpbmQgPSBjb25maWcuZmluZDtcbiAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlcjtcbiAgICB0aGlzLnVuZG9hYmxlID0gKF9hID0gY29uZmlnLnVuZG9hYmxlKSAhPSBudWxsID8gX2EgOiB0cnVlO1xuICB9XG59O1xudmFyIGlucHV0UnVsZU1hdGNoZXJIYW5kbGVyID0gKHRleHQsIGZpbmQpID0+IHtcbiAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XG4gICAgcmV0dXJuIGZpbmQuZXhlYyh0ZXh0KTtcbiAgfVxuICBjb25zdCBpbnB1dFJ1bGVNYXRjaCA9IGZpbmQodGV4dCk7XG4gIGlmICghaW5wdXRSdWxlTWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbaW5wdXRSdWxlTWF0Y2gudGV4dF07XG4gIHJlc3VsdC5pbmRleCA9IGlucHV0UnVsZU1hdGNoLmluZGV4O1xuICByZXN1bHQuaW5wdXQgPSB0ZXh0O1xuICByZXN1bHQuZGF0YSA9IGlucHV0UnVsZU1hdGNoLmRhdGE7XG4gIGlmIChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkge1xuICAgIGlmICghaW5wdXRSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogXCJpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aFwiIG11c3QgYmUgcGFydCBvZiBcImlucHV0UnVsZU1hdGNoLnRleHRcIi4nKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goaW5wdXRSdWxlTWF0Y2gucmVwbGFjZVdpdGgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuZnVuY3Rpb24gcnVuKGNvbmZpZykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHsgZWRpdG9yLCBmcm9tLCB0bywgdGV4dCwgcnVsZXMsIHBsdWdpbiB9ID0gY29uZmlnO1xuICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcbiAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0ICRmcm9tID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShmcm9tKTtcbiAgaWYgKFxuICAgIC8vIGNoZWNrIGZvciBjb2RlIG5vZGVcbiAgICAkZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgLy8gY2hlY2sgZm9yIGNvZGUgbWFya1xuICAgICEhKChfYSA9ICRmcm9tLm5vZGVCZWZvcmUgfHwgJGZyb20ubm9kZUFmdGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EubWFya3MuZmluZCgobWFyaykgPT4gbWFyay50eXBlLnNwZWMuY29kZSkpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgbWF0Y2hlZCA9IGZhbHNlO1xuICBjb25zdCB0ZXh0QmVmb3JlID0gZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMoJGZyb20pICsgdGV4dDtcbiAgcnVsZXMuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIodGV4dEJlZm9yZSwgcnVsZS5maW5kKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgIHN0YXRlOiB2aWV3LnN0YXRlLFxuICAgICAgdHJhbnNhY3Rpb246IHRyXG4gICAgfSk7XG4gICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICBmcm9tOiBmcm9tIC0gKG1hdGNoWzBdLmxlbmd0aCAtIHRleHQubGVuZ3RoKSxcbiAgICAgIHRvXG4gICAgfTtcbiAgICBjb25zdCB7IGNvbW1hbmRzLCBjaGFpbiwgY2FuIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgICAgZWRpdG9yLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgICBjb25zdCBoYW5kbGVyID0gcnVsZS5oYW5kbGVyKHtcbiAgICAgIHN0YXRlLFxuICAgICAgcmFuZ2UsXG4gICAgICBtYXRjaCxcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgY2hhaW4sXG4gICAgICBjYW5cbiAgICB9KTtcbiAgICBpZiAoaGFuZGxlciA9PT0gbnVsbCB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChydWxlLnVuZG9hYmxlKSB7XG4gICAgICB0ci5zZXRNZXRhKHBsdWdpbiwge1xuICAgICAgICB0cmFuc2Zvcm06IHRyLFxuICAgICAgICBmcm9tLFxuICAgICAgICB0byxcbiAgICAgICAgdGV4dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIG1hdGNoZWQgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIG1hdGNoZWQ7XG59XG5mdW5jdGlvbiBpbnB1dFJ1bGVzUGx1Z2luKHByb3BzKSB7XG4gIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHM7XG4gIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgIHN0YXRlOiB7XG4gICAgICBpbml0KCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBhcHBseSh0ciwgcHJldiwgc3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gdHIuZ2V0TWV0YShwbHVnaW4pO1xuICAgICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaW11bGF0ZWRJbnB1dE1ldGEgPSB0ci5nZXRNZXRhKFwiYXBwbHlJbnB1dFJ1bGVzXCIpO1xuICAgICAgICBjb25zdCBpc1NpbXVsYXRlZElucHV0ID0gISFzaW11bGF0ZWRJbnB1dE1ldGE7XG4gICAgICAgIGlmIChpc1NpbXVsYXRlZElucHV0KSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyB0ZXh0IH0gPSBzaW11bGF0ZWRJbnB1dE1ldGE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0ZXh0ID0gZ2V0SFRNTEZyb21GcmFnbWVudChGcmFnbWVudDQuZnJvbSh0ZXh0KSwgc3RhdGUuc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZnJvbSB9ID0gc2ltdWxhdGVkSW5wdXRNZXRhO1xuICAgICAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBydW4oe1xuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICBydWxlcyxcbiAgICAgICAgICAgICAgcGx1Z2luXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHIuc2VsZWN0aW9uU2V0IHx8IHRyLmRvY0NoYW5nZWQgPyBudWxsIDogcHJldjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBoYW5kbGVUZXh0SW5wdXQodmlldywgZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJ1bih7XG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIGZyb20sXG4gICAgICAgICAgdG8sXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICBydWxlcyxcbiAgICAgICAgICBwbHVnaW5cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgIGNvbXBvc2l0aW9uZW5kOiAodmlldykgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgICAgIHJ1bih7XG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIGZyb206ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgICAgIHRvOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICAgIHBsdWdpblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBhZGQgc3VwcG9ydCBmb3IgaW5wdXQgcnVsZXMgdG8gdHJpZ2dlciBvbiBlbnRlclxuICAgICAgLy8gdGhpcyBpcyB1c2VmdWwgZm9yIGV4YW1wbGUgZm9yIGNvZGUgYmxvY2tzXG4gICAgICBoYW5kbGVLZXlEb3duKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXkgIT09IFwiRW50ZXJcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgIHJldHVybiBydW4oe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgZnJvbTogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICB0bzogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICB0ZXh0OiBcIlxcblwiLFxuICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICBwbHVnaW5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaXNJbnB1dFJ1bGVzOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gcGx1Z2luO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2lzUGxhaW5PYmplY3QudHNcbmZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoZ2V0VHlwZSh2YWx1ZSkgIT09IFwiT2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9tZXJnZURlZXAudHNcbmZ1bmN0aW9uIG1lcmdlRGVlcCh0YXJnZXQsIHNvdXJjZSkge1xuICBjb25zdCBvdXRwdXQgPSB7IC4uLnRhcmdldCB9O1xuICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIGlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgb3V0cHV0W2tleV0gPSBtZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8gc3JjL0V4dGVuZGFibGUudHNcbnZhciBFeHRlbmRhYmxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIHRoaXMudHlwZSA9IFwiZXh0ZW5kYWJsZVwiO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgfTtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgLi4uY29uZmlnXG4gICAgfTtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsIFwiYWRkT3B0aW9uc1wiLCB7XG4gICAgICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgICAgIH0pXG4gICAgICApIHx8IHt9XG4gICAgfTtcbiAgfVxuICBnZXQgc3RvcmFnZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY2FsbE9yUmV0dXJuKFxuICAgICAgICBnZXRFeHRlbnNpb25GaWVsZCh0aGlzLCBcImFkZFN0b3JhZ2VcIiwge1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnNcbiAgICAgICAgfSlcbiAgICAgICkgfHwge31cbiAgICB9O1xuICB9XG4gIGNvbmZpZ3VyZShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCh7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIGFkZE9wdGlvbnM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGV4dGVuc2lvbi5uYW1lID0gdGhpcy5uYW1lO1xuICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICB9XG4gIGV4dGVuZChleHRlbmRlZENvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IHRoaXMuY29uc3RydWN0b3IoeyAuLi50aGlzLmNvbmZpZywgLi4uZXh0ZW5kZWRDb25maWcgfSk7XG4gICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXM7XG4gICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvbjtcbiAgICBleHRlbnNpb24ubmFtZSA9IFwibmFtZVwiIGluIGV4dGVuZGVkQ29uZmlnID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZTtcbiAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICB9XG59O1xuXG4vLyBzcmMvTWFyay50c1xudmFyIE1hcmsgPSBjbGFzcyBfTWFyayBleHRlbmRzIEV4dGVuZGFibGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IFwibWFya1wiO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTWFyayBpbnN0YW5jZVxuICAgKiBAcGFyYW0gY29uZmlnIC0gTWFyayBjb25maWd1cmF0aW9uIG9iamVjdCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRDb25maWcgPSB0eXBlb2YgY29uZmlnID09PSBcImZ1bmN0aW9uXCIgPyBjb25maWcoKSA6IGNvbmZpZztcbiAgICByZXR1cm4gbmV3IF9NYXJrKHJlc29sdmVkQ29uZmlnKTtcbiAgfVxuICBzdGF0aWMgaGFuZGxlRXhpdCh7IGVkaXRvciwgbWFyayB9KSB7XG4gICAgY29uc3QgeyB0ciB9ID0gZWRpdG9yLnN0YXRlO1xuICAgIGNvbnN0IGN1cnJlbnRQb3MgPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuICAgIGNvbnN0IGlzQXRFbmQgPSBjdXJyZW50UG9zLnBvcyA9PT0gY3VycmVudFBvcy5lbmQoKTtcbiAgICBpZiAoaXNBdEVuZCkge1xuICAgICAgY29uc3QgY3VycmVudE1hcmtzID0gY3VycmVudFBvcy5tYXJrcygpO1xuICAgICAgY29uc3QgaXNJbk1hcmsgPSAhIWN1cnJlbnRNYXJrcy5maW5kKChtKSA9PiAobSA9PSBudWxsID8gdm9pZCAwIDogbS50eXBlLm5hbWUpID09PSBtYXJrLm5hbWUpO1xuICAgICAgaWYgKCFpc0luTWFyaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCByZW1vdmVNYXJrID0gY3VycmVudE1hcmtzLmZpbmQoKG0pID0+IChtID09IG51bGwgPyB2b2lkIDAgOiBtLnR5cGUubmFtZSkgPT09IG1hcmsubmFtZSk7XG4gICAgICBpZiAocmVtb3ZlTWFyaykge1xuICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKHJlbW92ZU1hcmspO1xuICAgICAgfVxuICAgICAgdHIuaW5zZXJ0VGV4dChcIiBcIiwgY3VycmVudFBvcy5wb3MpO1xuICAgICAgZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25maWd1cmUob3B0aW9ucykge1xuICAgIHJldHVybiBzdXBlci5jb25maWd1cmUob3B0aW9ucyk7XG4gIH1cbiAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRDb25maWcgPSB0eXBlb2YgZXh0ZW5kZWRDb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IGV4dGVuZGVkQ29uZmlnKCkgOiBleHRlbmRlZENvbmZpZztcbiAgICByZXR1cm4gc3VwZXIuZXh0ZW5kKHJlc29sdmVkQ29uZmlnKTtcbiAgfVxufTtcblxuLy8gc3JjL1Bhc3RlUnVsZS50c1xuaW1wb3J0IHsgRnJhZ21lbnQgYXMgRnJhZ21lbnQ1IH0gZnJvbSBcIkB0aXB0YXAvcG0vbW9kZWxcIjtcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW4yIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcblxuLy8gc3JjL3V0aWxpdGllcy9pc051bWJlci50c1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn1cblxuLy8gc3JjL1Bhc3RlUnVsZS50c1xudmFyIFBhc3RlUnVsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5maW5kID0gY29uZmlnLmZpbmQ7XG4gICAgdGhpcy5oYW5kbGVyID0gY29uZmlnLmhhbmRsZXI7XG4gIH1cbn07XG52YXIgcGFzdGVSdWxlTWF0Y2hlckhhbmRsZXIgPSAodGV4dCwgZmluZCwgZXZlbnQpID0+IHtcbiAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XG4gICAgcmV0dXJuIFsuLi50ZXh0Lm1hdGNoQWxsKGZpbmQpXTtcbiAgfVxuICBjb25zdCBtYXRjaGVzID0gZmluZCh0ZXh0LCBldmVudCk7XG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcy5tYXAoKHBhc3RlUnVsZU1hdGNoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW3Bhc3RlUnVsZU1hdGNoLnRleHRdO1xuICAgIHJlc3VsdC5pbmRleCA9IHBhc3RlUnVsZU1hdGNoLmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IHRleHQ7XG4gICAgcmVzdWx0LmRhdGEgPSBwYXN0ZVJ1bGVNYXRjaC5kYXRhO1xuICAgIGlmIChwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkge1xuICAgICAgaWYgKCFwYXN0ZVJ1bGVNYXRjaC50ZXh0LmluY2x1ZGVzKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IFwicGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGhcIiBtdXN0IGJlIHBhcnQgb2YgXCJwYXN0ZVJ1bGVNYXRjaC50ZXh0XCIuJyk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIHJ1bjIoY29uZmlnKSB7XG4gIGNvbnN0IHsgZWRpdG9yLCBzdGF0ZSwgZnJvbSwgdG8sIHJ1bGUsIHBhc3RlRXZlbnQsIGRyb3BFdmVudCB9ID0gY29uZmlnO1xuICBjb25zdCB7IGNvbW1hbmRzLCBjaGFpbiwgY2FuIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgIGVkaXRvcixcbiAgICBzdGF0ZVxuICB9KTtcbiAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgaWYgKCgoX2IgPSAoX2EgPSBub2RlLnR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zcGVjKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY29kZSkgfHwgIShub2RlLmlzVGV4dCB8fCBub2RlLmlzVGV4dGJsb2NrIHx8IG5vZGUuaXNJbmxpbmUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnRTaXplID0gKF9lID0gKF9kID0gKF9jID0gbm9kZS5jb250ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Muc2l6ZSkgIT0gbnVsbCA/IF9kIDogbm9kZS5ub2RlU2l6ZSkgIT0gbnVsbCA/IF9lIDogMDtcbiAgICBjb25zdCByZXNvbHZlZEZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpO1xuICAgIGNvbnN0IHJlc29sdmVkVG8gPSBNYXRoLm1pbih0bywgcG9zICsgY29udGVudFNpemUpO1xuICAgIGlmIChyZXNvbHZlZEZyb20gPj0gcmVzb2x2ZWRUbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0VG9NYXRjaCA9IG5vZGUuaXNUZXh0ID8gbm9kZS50ZXh0IHx8IFwiXCIgOiBub2RlLnRleHRCZXR3ZWVuKHJlc29sdmVkRnJvbSAtIHBvcywgcmVzb2x2ZWRUbyAtIHBvcywgdm9pZCAwLCBcIlxcdUZGRkNcIik7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyKHRleHRUb01hdGNoLCBydWxlLmZpbmQsIHBhc3RlRXZlbnQpO1xuICAgIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0ID0gcmVzb2x2ZWRGcm9tICsgbWF0Y2guaW5kZXggKyAxO1xuICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgZnJvbTogc3RhdGUudHIubWFwcGluZy5tYXAoc3RhcnQpLFxuICAgICAgICB0bzogc3RhdGUudHIubWFwcGluZy5tYXAoZW5kKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcmFuZ2UsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIGNhbixcbiAgICAgICAgcGFzdGVFdmVudCxcbiAgICAgICAgZHJvcEV2ZW50XG4gICAgICB9KTtcbiAgICAgIGhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBzdWNjZXNzID0gaGFuZGxlcnMuZXZlcnkoKGhhbmRsZXIpID0+IGhhbmRsZXIgIT09IG51bGwpO1xuICByZXR1cm4gc3VjY2Vzcztcbn1cbnZhciB0aXB0YXBEcmFnRnJvbU90aGVyRWRpdG9yID0gbnVsbDtcbnZhciBjcmVhdGVDbGlwYm9hcmRQYXN0ZUV2ZW50ID0gKHRleHQpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBldmVudCA9IG5ldyBDbGlwYm9hcmRFdmVudChcInBhc3RlXCIsIHtcbiAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKClcbiAgfSk7XG4gIChfYSA9IGV2ZW50LmNsaXBib2FyZERhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zZXREYXRhKFwidGV4dC9odG1sXCIsIHRleHQpO1xuICByZXR1cm4gZXZlbnQ7XG59O1xuZnVuY3Rpb24gcGFzdGVSdWxlc1BsdWdpbihwcm9wcykge1xuICBjb25zdCB7IGVkaXRvciwgcnVsZXMgfSA9IHByb3BzO1xuICBsZXQgZHJhZ1NvdXJjZUVsZW1lbnQgPSBudWxsO1xuICBsZXQgaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3IgPSBmYWxzZTtcbiAgbGV0IGlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlO1xuICBsZXQgcGFzdGVFdmVudCA9IHR5cGVvZiBDbGlwYm9hcmRFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBDbGlwYm9hcmRFdmVudChcInBhc3RlXCIpIDogbnVsbDtcbiAgbGV0IGRyb3BFdmVudDtcbiAgdHJ5IHtcbiAgICBkcm9wRXZlbnQgPSB0eXBlb2YgRHJhZ0V2ZW50ICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IERyYWdFdmVudChcImRyb3BcIikgOiBudWxsO1xuICB9IGNhdGNoIHtcbiAgICBkcm9wRXZlbnQgPSBudWxsO1xuICB9XG4gIGNvbnN0IHByb2Nlc3NFdmVudCA9ICh7XG4gICAgc3RhdGUsXG4gICAgZnJvbSxcbiAgICB0byxcbiAgICBydWxlLFxuICAgIHBhc3RlRXZ0XG4gIH0pID0+IHtcbiAgICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuICAgIGNvbnN0IGNoYWluYWJsZVN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICB0cmFuc2FjdGlvbjogdHJcbiAgICB9KTtcbiAgICBjb25zdCBoYW5kbGVyID0gcnVuMih7XG4gICAgICBlZGl0b3IsXG4gICAgICBzdGF0ZTogY2hhaW5hYmxlU3RhdGUsXG4gICAgICBmcm9tOiBNYXRoLm1heChmcm9tIC0gMSwgMCksXG4gICAgICB0bzogdG8uYiAtIDEsXG4gICAgICBydWxlLFxuICAgICAgcGFzdGVFdmVudDogcGFzdGVFdnQsXG4gICAgICBkcm9wRXZlbnRcbiAgICB9KTtcbiAgICBpZiAoIWhhbmRsZXIgfHwgIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZHJvcEV2ZW50ID0gdHlwZW9mIERyYWdFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBEcmFnRXZlbnQoXCJkcm9wXCIpIDogbnVsbDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGRyb3BFdmVudCA9IG51bGw7XG4gICAgfVxuICAgIHBhc3RlRXZlbnQgPSB0eXBlb2YgQ2xpcGJvYXJkRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgQ2xpcGJvYXJkRXZlbnQoXCJwYXN0ZVwiKSA6IG51bGw7XG4gICAgcmV0dXJuIHRyO1xuICB9O1xuICBjb25zdCBwbHVnaW5zID0gcnVsZXMubWFwKChydWxlKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4yKHtcbiAgICAgIC8vIHdlIHJlZ2lzdGVyIGEgZ2xvYmFsIGRyYWcgaGFuZGxlciB0byB0cmFjayB0aGUgY3VycmVudCBkcmFnIHNvdXJjZSBlbGVtZW50XG4gICAgICB2aWV3KHZpZXcpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ3N0YXJ0ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGRyYWdTb3VyY2VFbGVtZW50ID0gKChfYSA9IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jb250YWlucyhldmVudC50YXJnZXQpKSA/IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQgOiBudWxsO1xuICAgICAgICAgIGlmIChkcmFnU291cmNlRWxlbWVudCkge1xuICAgICAgICAgICAgdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZURyYWdlbmQgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3IpIHtcbiAgICAgICAgICAgIHRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3IgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgaGFuZGxlRHJhZ3N0YXJ0KTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIGhhbmRsZURyYWdlbmQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBoYW5kbGVEcmFnc3RhcnQpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIGhhbmRsZURyYWdlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBwcm9wczoge1xuICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICBkcm9wOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvciA9IGRyYWdTb3VyY2VFbGVtZW50ID09PSB2aWV3LmRvbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgZHJvcEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBpZiAoIWlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBkcmFnRnJvbU90aGVyRWRpdG9yID0gdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvcjtcbiAgICAgICAgICAgICAgaWYgKGRyYWdGcm9tT3RoZXJFZGl0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IGRyYWdGcm9tT3RoZXJFZGl0b3IuaXNFZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZHJhZ0Zyb21PdGhlckVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdGcm9tT3RoZXJFZGl0b3IuY29tbWFuZHMuZGVsZXRlUmFuZ2UoeyBmcm9tOiBzZWxlY3Rpb24uZnJvbSwgdG86IHNlbGVjdGlvbi50byB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhc3RlOiAoX3ZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBodG1sID0gKF9hID0gZXZlbnQuY2xpcGJvYXJkRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldERhdGEoXCJ0ZXh0L2h0bWxcIik7XG4gICAgICAgICAgICBwYXN0ZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9ICEhKGh0bWwgPT0gbnVsbCA/IHZvaWQgMCA6IGh0bWwuaW5jbHVkZXMoXCJkYXRhLXBtLXNsaWNlXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25zWzBdO1xuICAgICAgICBjb25zdCBpc1Bhc3RlID0gdHJhbnNhY3Rpb24uZ2V0TWV0YShcInVpRXZlbnRcIikgPT09IFwicGFzdGVcIiAmJiAhaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3I7XG4gICAgICAgIGNvbnN0IGlzRHJvcCA9IHRyYW5zYWN0aW9uLmdldE1ldGEoXCJ1aUV2ZW50XCIpID09PSBcImRyb3BcIiAmJiAhaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yO1xuICAgICAgICBjb25zdCBzaW11bGF0ZWRQYXN0ZU1ldGEgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKFwiYXBwbHlQYXN0ZVJ1bGVzXCIpO1xuICAgICAgICBjb25zdCBpc1NpbXVsYXRlZFBhc3RlID0gISFzaW11bGF0ZWRQYXN0ZU1ldGE7XG4gICAgICAgIGlmICghaXNQYXN0ZSAmJiAhaXNEcm9wICYmICFpc1NpbXVsYXRlZFBhc3RlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NpbXVsYXRlZFBhc3RlKSB7XG4gICAgICAgICAgbGV0IHsgdGV4dCB9ID0gc2ltdWxhdGVkUGFzdGVNZXRhO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHQgPSBnZXRIVE1MRnJvbUZyYWdtZW50KEZyYWdtZW50NS5mcm9tKHRleHQpLCBzdGF0ZS5zY2hlbWEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IGZyb206IGZyb20yIH0gPSBzaW11bGF0ZWRQYXN0ZU1ldGE7XG4gICAgICAgICAgY29uc3QgdG8yID0gZnJvbTIgKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBwYXN0ZUV2dCA9IGNyZWF0ZUNsaXBib2FyZFBhc3RlRXZlbnQodGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHByb2Nlc3NFdmVudCh7XG4gICAgICAgICAgICBydWxlLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBmcm9tOiBmcm9tMixcbiAgICAgICAgICAgIHRvOiB7IGI6IHRvMiB9LFxuICAgICAgICAgICAgcGFzdGVFdnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9tID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZTdGFydChzdGF0ZS5kb2MuY29udGVudCk7XG4gICAgICAgIGNvbnN0IHRvID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZFbmQoc3RhdGUuZG9jLmNvbnRlbnQpO1xuICAgICAgICBpZiAoIWlzTnVtYmVyKGZyb20pIHx8ICF0byB8fCBmcm9tID09PSB0by5iKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZXNzRXZlbnQoe1xuICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB0byxcbiAgICAgICAgICBwYXN0ZUV2dDogcGFzdGVFdmVudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBwbHVnaW5zO1xufVxuXG4vLyBzcmMvRXh0ZW5zaW9uTWFuYWdlci50c1xudmFyIEV4dGVuc2lvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGV4dGVuc2lvbnMsIGVkaXRvcikge1xuICAgIHRoaXMuc3BsaXR0YWJsZU1hcmtzID0gW107XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgdGhpcy5iYXNlRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgdGhpcy5leHRlbnNpb25zID0gcmVzb2x2ZUV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XG4gICAgdGhpcy5zY2hlbWEgPSBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyh0aGlzLmV4dGVuc2lvbnMsIGVkaXRvcik7XG4gICAgdGhpcy5zZXR1cEV4dGVuc2lvbnMoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCBjb21tYW5kcyBmcm9tIHRoZSBleHRlbnNpb25zLlxuICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBhbGwgY29tbWFuZHMgd2hlcmUgdGhlIGtleSBpcyB0aGUgY29tbWFuZCBuYW1lIGFuZCB0aGUgdmFsdWUgaXMgdGhlIGNvbW1hbmQgZnVuY3Rpb25cbiAgICovXG4gIGdldCBjb21tYW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zLnJlZHVjZSgoY29tbWFuZHMsIGV4dGVuc2lvbikgPT4ge1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiB0aGlzLmVkaXRvci5leHRlbnNpb25TdG9yYWdlW2V4dGVuc2lvbi5uYW1lXSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpXG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkQ29tbWFuZHMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiYWRkQ29tbWFuZHNcIiwgY29udGV4dCk7XG4gICAgICBpZiAoIWFkZENvbW1hbmRzKSB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNvbW1hbmRzLFxuICAgICAgICAuLi5hZGRDb21tYW5kcygpXG4gICAgICB9O1xuICAgIH0sIHt9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCByZWdpc3RlcmVkIFByb3NlbWlycm9yIHBsdWdpbnMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgUHJvc2VtaXJyb3IgcGx1Z2luc1xuICAgKi9cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXM7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHNvcnRFeHRlbnNpb25zKFsuLi50aGlzLmV4dGVuc2lvbnNdLnJldmVyc2UoKSk7XG4gICAgY29uc3QgYWxsUGx1Z2lucyA9IGV4dGVuc2lvbnMuZmxhdE1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdLFxuICAgICAgICBlZGl0b3IsXG4gICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgICAgIGNvbnN0IGFkZEtleWJvYXJkU2hvcnRjdXRzID0gZ2V0RXh0ZW5zaW9uRmllbGQoXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgXCJhZGRLZXlib2FyZFNob3J0Y3V0c1wiLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgICAgbGV0IGRlZmF1bHRCaW5kaW5ncyA9IHt9O1xuICAgICAgaWYgKGV4dGVuc2lvbi50eXBlID09PSBcIm1hcmtcIiAmJiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiZXhpdGFibGVcIiwgY29udGV4dCkpIHtcbiAgICAgICAgZGVmYXVsdEJpbmRpbmdzLkFycm93UmlnaHQgPSAoKSA9PiBNYXJrLmhhbmRsZUV4aXQoeyBlZGl0b3IsIG1hcms6IGV4dGVuc2lvbiB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChhZGRLZXlib2FyZFNob3J0Y3V0cykge1xuICAgICAgICBjb25zdCBiaW5kaW5ncyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhhZGRLZXlib2FyZFNob3J0Y3V0cygpKS5tYXAoKFtzaG9ydGN1dCwgbWV0aG9kXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtzaG9ydGN1dCwgKCkgPT4gbWV0aG9kKHsgZWRpdG9yIH0pXTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBkZWZhdWx0QmluZGluZ3MgPSB7IC4uLmRlZmF1bHRCaW5kaW5ncywgLi4uYmluZGluZ3MgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleU1hcFBsdWdpbiA9IGtleW1hcChkZWZhdWx0QmluZGluZ3MpO1xuICAgICAgcGx1Z2lucy5wdXNoKGtleU1hcFBsdWdpbik7XG4gICAgICBjb25zdCBhZGRJbnB1dFJ1bGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZElucHV0UnVsZXNcIiwgY29udGV4dCk7XG4gICAgICBpZiAoaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlZGl0b3Iub3B0aW9ucy5lbmFibGVJbnB1dFJ1bGVzKSAmJiBhZGRJbnB1dFJ1bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gYWRkSW5wdXRSdWxlcygpO1xuICAgICAgICBpZiAocnVsZXMgJiYgcnVsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgaW5wdXRSZXN1bHQgPSBpbnB1dFJ1bGVzUGx1Z2luKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHJ1bGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgaW5wdXRQbHVnaW5zID0gQXJyYXkuaXNBcnJheShpbnB1dFJlc3VsdCkgPyBpbnB1dFJlc3VsdCA6IFtpbnB1dFJlc3VsdF07XG4gICAgICAgICAgcGx1Z2lucy5wdXNoKC4uLmlucHV0UGx1Z2lucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGFkZFBhc3RlUnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiYWRkUGFzdGVSdWxlc1wiLCBjb250ZXh0KTtcbiAgICAgIGlmIChpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVkaXRvci5vcHRpb25zLmVuYWJsZVBhc3RlUnVsZXMpICYmIGFkZFBhc3RlUnVsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZXMgPSBhZGRQYXN0ZVJ1bGVzKCk7XG4gICAgICAgIGlmIChydWxlcyAmJiBydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBwYXN0ZVJ1bGVzID0gcGFzdGVSdWxlc1BsdWdpbih7IGVkaXRvciwgcnVsZXMgfSk7XG4gICAgICAgICAgcGx1Z2lucy5wdXNoKC4uLnBhc3RlUnVsZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBhZGRQcm9zZU1pcnJvclBsdWdpbnMgPSBnZXRFeHRlbnNpb25GaWVsZChcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICBcImFkZFByb3NlTWlycm9yUGx1Z2luc1wiLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgICAgaWYgKGFkZFByb3NlTWlycm9yUGx1Z2lucykge1xuICAgICAgICBjb25zdCBwcm9zZU1pcnJvclBsdWdpbnMgPSBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKTtcbiAgICAgICAgcGx1Z2lucy5wdXNoKC4uLnByb3NlTWlycm9yUGx1Z2lucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGx1Z2lucztcbiAgICB9KTtcbiAgICByZXR1cm4gYWxsUGx1Z2lucztcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCBhdHRyaWJ1dGVzIGZyb20gdGhlIGV4dGVuc2lvbnMuXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGF0dHJpYnV0ZXNcbiAgICovXG4gIGdldCBhdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCBub2RlIHZpZXdzIGZyb20gdGhlIGV4dGVuc2lvbnMuXG4gICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGFsbCBub2RlIHZpZXdzIHdoZXJlIHRoZSBrZXkgaXMgdGhlIG5vZGUgbmFtZSBhbmQgdGhlIHZhbHVlIGlzIHRoZSBub2RlIHZpZXcgZnVuY3Rpb25cbiAgICovXG4gIGdldCBub2RlVmlld3MoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucyk7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIG5vZGVFeHRlbnNpb25zLmZpbHRlcigoZXh0ZW5zaW9uKSA9PiAhIWdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJhZGROb2RlVmlld1wiKSkubWFwKChleHRlbnNpb24pID0+IHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcy5maWx0ZXIoKGF0dHJpYnV0ZSkgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICBzdG9yYWdlOiB0aGlzLmVkaXRvci5leHRlbnNpb25TdG9yYWdlW2V4dGVuc2lvbi5uYW1lXSxcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgdHlwZTogZ2V0Tm9kZVR5cGUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhZGROb2RlVmlldyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJhZGROb2RlVmlld1wiLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKCFhZGROb2RlVmlldykge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlVmlld1Jlc3VsdCA9IGFkZE5vZGVWaWV3KCk7XG4gICAgICAgIGlmICghbm9kZVZpZXdSZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZXZpZXcgPSAobm9kZSwgdmlldywgZ2V0UG9zLCBkZWNvcmF0aW9ucywgaW5uZXJEZWNvcmF0aW9ucykgPT4ge1xuICAgICAgICAgIGNvbnN0IEhUTUxBdHRyaWJ1dGVzID0gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpO1xuICAgICAgICAgIHJldHVybiBub2RlVmlld1Jlc3VsdCh7XG4gICAgICAgICAgICAvLyBwYXNzLXRocm91Z2hcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2aWV3LFxuICAgICAgICAgICAgZ2V0UG9zLFxuICAgICAgICAgICAgZGVjb3JhdGlvbnMsXG4gICAgICAgICAgICBpbm5lckRlY29yYXRpb25zLFxuICAgICAgICAgICAgLy8gdGlwdGFwLXNwZWNpZmljXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBub2Rldmlld107XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgZ2V0IG1hcmtWaWV3cygpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICBjb25zdCB7IG1hcmtFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgbWFya0V4dGVuc2lvbnMuZmlsdGVyKChleHRlbnNpb24pID0+ICEhZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZE1hcmtWaWV3XCIpKS5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLmZpbHRlcigoYXR0cmlidXRlKSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgIHN0b3JhZ2U6IHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdLFxuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICB0eXBlOiBnZXRNYXJrVHlwZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZE1hcmtWaWV3ID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZE1hcmtWaWV3XCIsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIWFkZE1hcmtWaWV3KSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hcmtWaWV3ID0gKG1hcmssIHZpZXcsIGlubGluZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IEhUTUxBdHRyaWJ1dGVzID0gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG1hcmssIGV4dGVuc2lvbkF0dHJpYnV0ZXMpO1xuICAgICAgICAgIHJldHVybiBhZGRNYXJrVmlldygpKHtcbiAgICAgICAgICAgIC8vIHBhc3MtdGhyb3VnaFxuICAgICAgICAgICAgbWFyayxcbiAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICBpbmxpbmUsXG4gICAgICAgICAgICAvLyB0aXB0YXAtc3BlY2lmaWNcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlczogKGF0dHJzKSA9PiB7XG4gICAgICAgICAgICAgIHVwZGF0ZU1hcmtWaWV3QXR0cmlidXRlcyhtYXJrLCBlZGl0b3IsIGF0dHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgbWFya1ZpZXddO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHbyB0aHJvdWdoIGFsbCBleHRlbnNpb25zLCBjcmVhdGUgZXh0ZW5zaW9uIHN0b3JhZ2VzICYgc2V0dXAgbWFya3NcbiAgICogJiBiaW5kIGVkaXRvciBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIHNldHVwRXh0ZW5zaW9ucygpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2UgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBleHRlbnNpb25zLm1hcCgoZXh0ZW5zaW9uKSA9PiBbZXh0ZW5zaW9uLm5hbWUsIGV4dGVuc2lvbi5zdG9yYWdlXSlcbiAgICApO1xuICAgIGV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSlcbiAgICAgIH07XG4gICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUgPT09IFwibWFya1wiKSB7XG4gICAgICAgIGNvbnN0IGtlZXBPblNwbGl0ID0gKF9hID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJrZWVwT25TcGxpdFwiLCBjb250ZXh0KSkpICE9IG51bGwgPyBfYSA6IHRydWU7XG4gICAgICAgIGlmIChrZWVwT25TcGxpdCkge1xuICAgICAgICAgIHRoaXMuc3BsaXR0YWJsZU1hcmtzLnB1c2goZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBvbkJlZm9yZUNyZWF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJvbkJlZm9yZUNyZWF0ZVwiLCBjb250ZXh0KTtcbiAgICAgIGNvbnN0IG9uQ3JlYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcIm9uQ3JlYXRlXCIsIGNvbnRleHQpO1xuICAgICAgY29uc3Qgb25VcGRhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwib25VcGRhdGVcIiwgY29udGV4dCk7XG4gICAgICBjb25zdCBvblNlbGVjdGlvblVwZGF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkKFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgIFwib25TZWxlY3Rpb25VcGRhdGVcIixcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG9uVHJhbnNhY3Rpb24gPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwib25UcmFuc2FjdGlvblwiLCBjb250ZXh0KTtcbiAgICAgIGNvbnN0IG9uRm9jdXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwib25Gb2N1c1wiLCBjb250ZXh0KTtcbiAgICAgIGNvbnN0IG9uQmx1ciA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJvbkJsdXJcIiwgY29udGV4dCk7XG4gICAgICBjb25zdCBvbkRlc3Ryb3kgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwib25EZXN0cm95XCIsIGNvbnRleHQpO1xuICAgICAgaWYgKG9uQmVmb3JlQ3JlYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwiYmVmb3JlQ3JlYXRlXCIsIG9uQmVmb3JlQ3JlYXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkNyZWF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcImNyZWF0ZVwiLCBvbkNyZWF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oXCJ1cGRhdGVcIiwgb25VcGRhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKG9uU2VsZWN0aW9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwic2VsZWN0aW9uVXBkYXRlXCIsIG9uU2VsZWN0aW9uVXBkYXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvblRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwidHJhbnNhY3Rpb25cIiwgb25UcmFuc2FjdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAob25Gb2N1cykge1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcImZvY3VzXCIsIG9uRm9jdXMpO1xuICAgICAgfVxuICAgICAgaWYgKG9uQmx1cikge1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcImJsdXJcIiwgb25CbHVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkRlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oXCJkZXN0cm95XCIsIG9uRGVzdHJveSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5FeHRlbnNpb25NYW5hZ2VyLnJlc29sdmUgPSByZXNvbHZlRXh0ZW5zaW9ucztcbkV4dGVuc2lvbk1hbmFnZXIuc29ydCA9IHNvcnRFeHRlbnNpb25zO1xuRXh0ZW5zaW9uTWFuYWdlci5mbGF0dGVuID0gZmxhdHRlbkV4dGVuc2lvbnM7XG5cbi8vIHNyYy9leHRlbnNpb25zL2luZGV4LnRzXG52YXIgZXh0ZW5zaW9uc19leHBvcnRzID0ge307XG5fX2V4cG9ydChleHRlbnNpb25zX2V4cG9ydHMsIHtcbiAgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXI6ICgpID0+IENsaXBib2FyZFRleHRTZXJpYWxpemVyLFxuICBDb21tYW5kczogKCkgPT4gQ29tbWFuZHMsXG4gIERlbGV0ZTogKCkgPT4gRGVsZXRlLFxuICBEcm9wOiAoKSA9PiBEcm9wLFxuICBFZGl0YWJsZTogKCkgPT4gRWRpdGFibGUsXG4gIEZvY3VzRXZlbnRzOiAoKSA9PiBGb2N1c0V2ZW50cyxcbiAgS2V5bWFwOiAoKSA9PiBLZXltYXAsXG4gIFBhc3RlOiAoKSA9PiBQYXN0ZSxcbiAgVGFiaW5kZXg6ICgpID0+IFRhYmluZGV4LFxuICBUZXh0RGlyZWN0aW9uOiAoKSA9PiBUZXh0RGlyZWN0aW9uLFxuICBmb2N1c0V2ZW50c1BsdWdpbktleTogKCkgPT4gZm9jdXNFdmVudHNQbHVnaW5LZXlcbn0pO1xuXG4vLyBzcmMvZXh0ZW5zaW9ucy9jbGlwYm9hcmRUZXh0U2VyaWFsaXplci50c1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjMsIFBsdWdpbktleSB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5cbi8vIHNyYy9FeHRlbnNpb24udHNcbnZhciBFeHRlbnNpb24gPSBjbGFzcyBfRXh0ZW5zaW9uIGV4dGVuZHMgRXh0ZW5kYWJsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gXCJleHRlbnNpb25cIjtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEV4dGVuc2lvbiBpbnN0YW5jZVxuICAgKiBAcGFyYW0gY29uZmlnIC0gRXh0ZW5zaW9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICBjb25zdCByZXNvbHZlZENvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IGNvbmZpZygpIDogY29uZmlnO1xuICAgIHJldHVybiBuZXcgX0V4dGVuc2lvbihyZXNvbHZlZENvbmZpZyk7XG4gIH1cbiAgY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3VwZXIuY29uZmlndXJlKG9wdGlvbnMpO1xuICB9XG4gIGV4dGVuZChleHRlbmRlZENvbmZpZykge1xuICAgIGNvbnN0IHJlc29sdmVkQ29uZmlnID0gdHlwZW9mIGV4dGVuZGVkQ29uZmlnID09PSBcImZ1bmN0aW9uXCIgPyBleHRlbmRlZENvbmZpZygpIDogZXh0ZW5kZWRDb25maWc7XG4gICAgcmV0dXJuIHN1cGVyLmV4dGVuZChyZXNvbHZlZENvbmZpZyk7XG4gIH1cbn07XG5cbi8vIHNyYy9leHRlbnNpb25zL2NsaXBib2FyZFRleHRTZXJpYWxpemVyLnRzXG52YXIgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJjbGlwYm9hcmRUZXh0U2VyaWFsaXplclwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBibG9ja1NlcGFyYXRvcjogdm9pZCAwXG4gICAgfTtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luMyh7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleShcImNsaXBib2FyZFRleHRTZXJpYWxpemVyXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGNsaXBib2FyZFRleHRTZXJpYWxpemVyOiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUsIHNjaGVtYSB9ID0gZWRpdG9yO1xuICAgICAgICAgICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IE1hdGgubWluKC4uLnJhbmdlcy5tYXAoKHJhbmdlMikgPT4gcmFuZ2UyLiRmcm9tLnBvcykpO1xuICAgICAgICAgICAgY29uc3QgdG8gPSBNYXRoLm1heCguLi5yYW5nZXMubWFwKChyYW5nZTIpID0+IHJhbmdlMi4kdG8ucG9zKSk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0U2VyaWFsaXplcnMgPSBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgZnJvbSwgdG8gfTtcbiAgICAgICAgICAgIHJldHVybiBnZXRUZXh0QmV0d2Vlbihkb2MsIHJhbmdlLCB7XG4gICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5ibG9ja1NlcGFyYXRvciAhPT0gdm9pZCAwID8geyBibG9ja1NlcGFyYXRvcjogdGhpcy5vcHRpb25zLmJsb2NrU2VwYXJhdG9yIH0gOiB7fSxcbiAgICAgICAgICAgICAgdGV4dFNlcmlhbGl6ZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL2NvbW1hbmRzLnRzXG52YXIgQ29tbWFuZHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJjb21tYW5kc1wiLFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29tbWFuZHNfZXhwb3J0c1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvZXh0ZW5zaW9ucy9kZWxldGUudHNcbmltcG9ydCB7IFJlbW92ZU1hcmtTdGVwIH0gZnJvbSBcIkB0aXB0YXAvcG0vdHJhbnNmb3JtXCI7XG52YXIgRGVsZXRlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZGVsZXRlXCIsXG4gIG9uVXBkYXRlKHsgdHJhbnNhY3Rpb24sIGFwcGVuZGVkVHJhbnNhY3Rpb25zIH0pIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iMiwgX2MyLCBfZDtcbiAgICAgIGlmICgoX2QgPSAoX2MyID0gKF9iMiA9IChfYTIgPSB0aGlzLmVkaXRvci5vcHRpb25zLmNvcmVFeHRlbnNpb25PcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmRlbGV0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5maWx0ZXJUcmFuc2FjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi5jYWxsKF9iMiwgdHJhbnNhY3Rpb24pKSAhPSBudWxsID8gX2QgOiB0cmFuc2FjdGlvbi5nZXRNZXRhKFwieS1zeW5jJFwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0VHJhbnNhY3Rpb24gPSBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcyh0cmFuc2FjdGlvbi5iZWZvcmUsIFt0cmFuc2FjdGlvbiwgLi4uYXBwZW5kZWRUcmFuc2FjdGlvbnNdKTtcbiAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRDaGFuZ2VkUmFuZ2VzKG5leHRUcmFuc2FjdGlvbik7XG4gICAgICBjaGFuZ2VzLmZvckVhY2goKGNoYW5nZSkgPT4ge1xuICAgICAgICBpZiAobmV4dFRyYW5zYWN0aW9uLm1hcHBpbmcubWFwUmVzdWx0KGNoYW5nZS5vbGRSYW5nZS5mcm9tKS5kZWxldGVkQWZ0ZXIgJiYgbmV4dFRyYW5zYWN0aW9uLm1hcHBpbmcubWFwUmVzdWx0KGNoYW5nZS5vbGRSYW5nZS50bykuZGVsZXRlZEJlZm9yZSkge1xuICAgICAgICAgIG5leHRUcmFuc2FjdGlvbi5iZWZvcmUubm9kZXNCZXR3ZWVuKGNoYW5nZS5vbGRSYW5nZS5mcm9tLCBjaGFuZ2Uub2xkUmFuZ2UudG8sIChub2RlLCBmcm9tKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyBub2RlLm5vZGVTaXplIC0gMjtcbiAgICAgICAgICAgIGNvbnN0IGlzRnVsbHlXaXRoaW5SYW5nZSA9IGNoYW5nZS5vbGRSYW5nZS5mcm9tIDw9IGZyb20gJiYgdG8gPD0gY2hhbmdlLm9sZFJhbmdlLnRvO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdChcImRlbGV0ZVwiLCB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibm9kZVwiLFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgbmV3RnJvbTogbmV4dFRyYW5zYWN0aW9uLm1hcHBpbmcubWFwKGZyb20pLFxuICAgICAgICAgICAgICBuZXdUbzogbmV4dFRyYW5zYWN0aW9uLm1hcHBpbmcubWFwKHRvKSxcbiAgICAgICAgICAgICAgZGVsZXRlZFJhbmdlOiBjaGFuZ2Uub2xkUmFuZ2UsXG4gICAgICAgICAgICAgIG5ld1JhbmdlOiBjaGFuZ2UubmV3UmFuZ2UsXG4gICAgICAgICAgICAgIHBhcnRpYWw6ICFpc0Z1bGx5V2l0aGluUmFuZ2UsXG4gICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICBjb21iaW5lZFRyYW5zZm9ybTogbmV4dFRyYW5zYWN0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBtYXBwaW5nID0gbmV4dFRyYW5zYWN0aW9uLm1hcHBpbmc7XG4gICAgICBuZXh0VHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaCgoc3RlcCwgaW5kZXgpID0+IHtcbiAgICAgICAgdmFyIF9hMywgX2IzO1xuICAgICAgICBpZiAoc3RlcCBpbnN0YW5jZW9mIFJlbW92ZU1hcmtTdGVwKSB7XG4gICAgICAgICAgY29uc3QgbmV3U3RhcnQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAoc3RlcC5mcm9tLCAtMSk7XG4gICAgICAgICAgY29uc3QgbmV3RW5kID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKHN0ZXAudG8pO1xuICAgICAgICAgIGNvbnN0IG9sZFN0YXJ0ID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3U3RhcnQsIC0xKTtcbiAgICAgICAgICBjb25zdCBvbGRFbmQgPSBtYXBwaW5nLmludmVydCgpLm1hcChuZXdFbmQpO1xuICAgICAgICAgIGNvbnN0IGZvdW5kQmVmb3JlTWFyayA9IChfYTMgPSBuZXh0VHJhbnNhY3Rpb24uZG9jLm5vZGVBdChuZXdTdGFydCAtIDEpKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLm1hcmtzLnNvbWUoKG1hcmspID0+IG1hcmsuZXEoc3RlcC5tYXJrKSk7XG4gICAgICAgICAgY29uc3QgZm91bmRBZnRlck1hcmsgPSAoX2IzID0gbmV4dFRyYW5zYWN0aW9uLmRvYy5ub2RlQXQobmV3RW5kKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMy5tYXJrcy5zb21lKChtYXJrKSA9PiBtYXJrLmVxKHN0ZXAubWFyaykpO1xuICAgICAgICAgIHRoaXMuZWRpdG9yLmVtaXQoXCJkZWxldGVcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJtYXJrXCIsXG4gICAgICAgICAgICBtYXJrOiBzdGVwLm1hcmssXG4gICAgICAgICAgICBmcm9tOiBzdGVwLmZyb20sXG4gICAgICAgICAgICB0bzogc3RlcC50byxcbiAgICAgICAgICAgIGRlbGV0ZWRSYW5nZToge1xuICAgICAgICAgICAgICBmcm9tOiBvbGRTdGFydCxcbiAgICAgICAgICAgICAgdG86IG9sZEVuZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5ld1JhbmdlOiB7XG4gICAgICAgICAgICAgIGZyb206IG5ld1N0YXJ0LFxuICAgICAgICAgICAgICB0bzogbmV3RW5kXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFydGlhbDogQm9vbGVhbihmb3VuZEFmdGVyTWFyayB8fCBmb3VuZEJlZm9yZU1hcmspLFxuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgY29tYmluZWRUcmFuc2Zvcm06IG5leHRUcmFuc2FjdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmICgoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmVkaXRvci5vcHRpb25zLmNvcmVFeHRlbnNpb25PcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGVsZXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYXN5bmMpICE9IG51bGwgPyBfYyA6IHRydWUpIHtcbiAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL2Ryb3AudHNcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW40LCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5MiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgRHJvcCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcImRyb3BcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luNCh7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleTIoXCJ0aXB0YXBEcm9wXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGhhbmRsZURyb3A6IChfLCBlLCBzbGljZSwgbW92ZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVtaXQoXCJkcm9wXCIsIHtcbiAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHNsaWNlLFxuICAgICAgICAgICAgICBtb3ZlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvZXh0ZW5zaW9ucy9lZGl0YWJsZS50c1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjUsIFBsdWdpbktleSBhcyBQbHVnaW5LZXkzIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBFZGl0YWJsZSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcImVkaXRhYmxlXCIsXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbjUoe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkzKFwiZWRpdGFibGVcIiksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgZWRpdGFibGU6ICgpID0+IHRoaXMuZWRpdG9yLm9wdGlvbnMuZWRpdGFibGVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2V4dGVuc2lvbnMvZm9jdXNFdmVudHMudHNcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW42LCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5NCB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgZm9jdXNFdmVudHNQbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5NChcImZvY3VzRXZlbnRzXCIpO1xudmFyIEZvY3VzRXZlbnRzID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZm9jdXNFdmVudHNcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luNih7XG4gICAgICAgIGtleTogZm9jdXNFdmVudHNQbHVnaW5LZXksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICBmb2N1czogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGVkaXRvci5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKFwiZm9jdXNcIiwgeyBldmVudCB9KS5zZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibHVyOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKFwiYmx1clwiLCB7IGV2ZW50IH0pLnNldE1ldGEoXCJhZGRUb0hpc3RvcnlcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2V4dGVuc2lvbnMva2V5bWFwLnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luNywgUGx1Z2luS2V5IGFzIFBsdWdpbktleTUsIFNlbGVjdGlvbiBhcyBTZWxlY3Rpb24zIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBLZXltYXAgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJrZXltYXBcIixcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgY29uc3QgaGFuZGxlQmFja3NwYWNlID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xuICAgICAgKCkgPT4gY29tbWFuZHMudW5kb0lucHV0UnVsZSgpLFxuICAgICAgLy8gbWF5YmUgY29udmVydCBmaXJzdCB0ZXh0IGJsb2NrIG5vZGUgdG8gZGVmYXVsdCBub2RlXG4gICAgICAoKSA9PiBjb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHI7XG4gICAgICAgIGNvbnN0IHsgZW1wdHksICRhbmNob3IgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgY29uc3QgeyBwb3MsIHBhcmVudCB9ID0gJGFuY2hvcjtcbiAgICAgICAgY29uc3QgJHBhcmVudFBvcyA9ICRhbmNob3IucGFyZW50LmlzVGV4dGJsb2NrICYmIHBvcyA+IDAgPyB0ci5kb2MucmVzb2x2ZShwb3MgLSAxKSA6ICRhbmNob3I7XG4gICAgICAgIGNvbnN0IHBhcmVudElzSXNvbGF0aW5nID0gJHBhcmVudFBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZztcbiAgICAgICAgY29uc3QgcGFyZW50UG9zID0gJGFuY2hvci5wb3MgLSAkYW5jaG9yLnBhcmVudE9mZnNldDtcbiAgICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gcGFyZW50SXNJc29sYXRpbmcgJiYgJHBhcmVudFBvcy5wYXJlbnQuY2hpbGRDb3VudCA9PT0gMSA/IHBhcmVudFBvcyA9PT0gJGFuY2hvci5wb3MgOiBTZWxlY3Rpb24zLmF0U3RhcnQoZG9jKS5mcm9tID09PSBwb3M7XG4gICAgICAgIGlmICghZW1wdHkgfHwgIXBhcmVudC50eXBlLmlzVGV4dGJsb2NrIHx8IHBhcmVudC50ZXh0Q29udGVudC5sZW5ndGggfHwgIWlzQXRTdGFydCB8fCBpc0F0U3RhcnQgJiYgJGFuY2hvci5wYXJlbnQudHlwZS5uYW1lID09PSBcInBhcmFncmFwaFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgICB9KSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkJhY2t3YXJkKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlQmFja3dhcmQoKVxuICAgIF0pO1xuICAgIGNvbnN0IGhhbmRsZURlbGV0ZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlQ3VycmVudE5vZGUoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmpvaW5Gb3J3YXJkKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlRm9yd2FyZCgpXG4gICAgXSk7XG4gICAgY29uc3QgaGFuZGxlRW50ZXIgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAoKSA9PiBjb21tYW5kcy5uZXdsaW5lSW5Db2RlKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5jcmVhdGVQYXJhZ3JhcGhOZWFyKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5saWZ0RW1wdHlCbG9jaygpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuc3BsaXRCbG9jaygpXG4gICAgXSk7XG4gICAgY29uc3QgYmFzZUtleW1hcCA9IHtcbiAgICAgIEVudGVyOiBoYW5kbGVFbnRlcixcbiAgICAgIFwiTW9kLUVudGVyXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKCksXG4gICAgICBCYWNrc3BhY2U6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgIFwiTW9kLUJhY2tzcGFjZVwiOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICBEZWxldGU6IGhhbmRsZURlbGV0ZSxcbiAgICAgIFwiTW9kLURlbGV0ZVwiOiBoYW5kbGVEZWxldGUsXG4gICAgICBcIk1vZC1hXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNlbGVjdEFsbCgpXG4gICAgfTtcbiAgICBjb25zdCBwY0tleW1hcCA9IHtcbiAgICAgIC4uLmJhc2VLZXltYXBcbiAgICB9O1xuICAgIGNvbnN0IG1hY0tleW1hcCA9IHtcbiAgICAgIC4uLmJhc2VLZXltYXAsXG4gICAgICBcIkN0cmwtaFwiOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICBcIkFsdC1CYWNrc3BhY2VcIjogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgXCJDdHJsLWRcIjogaGFuZGxlRGVsZXRlLFxuICAgICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogaGFuZGxlRGVsZXRlLFxuICAgICAgXCJBbHQtRGVsZXRlXCI6IGhhbmRsZURlbGV0ZSxcbiAgICAgIFwiQWx0LWRcIjogaGFuZGxlRGVsZXRlLFxuICAgICAgXCJDdHJsLWFcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrU3RhcnQoKSxcbiAgICAgIFwiQ3RybC1lXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNlbGVjdFRleHRibG9ja0VuZCgpXG4gICAgfTtcbiAgICBpZiAoaXNpT1MoKSB8fCBpc01hY09TKCkpIHtcbiAgICAgIHJldHVybiBtYWNLZXltYXA7XG4gICAgfVxuICAgIHJldHVybiBwY0tleW1hcDtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBXaXRoIHRoaXMgcGx1Z2luIHdlIGNoZWNrIGlmIHRoZSB3aG9sZSBkb2N1bWVudCB3YXMgc2VsZWN0ZWQgYW5kIGRlbGV0ZWQuXG4gICAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugd2lsbCBhZGRpdGlvbmFsbHkgY2FsbCBgY2xlYXJOb2RlcygpYCB0byBjb252ZXJ0IGUuZy4gYSBoZWFkaW5nXG4gICAgICAvLyB0byBhIHBhcmFncmFwaCBpZiBuZWNlc3NhcnkuXG4gICAgICAvLyBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHRvIFByb3NlTWlycm9yJ3MgYEFsbFNlbGVjdGlvbmAsIHdoaWNoIGRvZXNu4oCZdCB3b3JrIHdlbGxcbiAgICAgIC8vIHdpdGggbWFueSBvdGhlciBjb21tYW5kcy5cbiAgICAgIG5ldyBQbHVnaW43KHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5NShcImNsZWFyRG9jdW1lbnRcIiksXG4gICAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAodHJhbnNhY3Rpb25zLnNvbWUoKHRyMikgPT4gdHIyLmdldE1ldGEoXCJjb21wb3NpdGlvblwiKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IHRyYW5zYWN0aW9ucy5zb21lKCh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZCkgJiYgIW9sZFN0YXRlLmRvYy5lcShuZXdTdGF0ZS5kb2MpO1xuICAgICAgICAgIGNvbnN0IGlnbm9yZVRyID0gdHJhbnNhY3Rpb25zLnNvbWUoKHRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbi5nZXRNZXRhKFwicHJldmVudENsZWFyRG9jdW1lbnRcIikpO1xuICAgICAgICAgIGlmICghZG9jQ2hhbmdlcyB8fCBpZ25vcmVUcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IGVtcHR5LCBmcm9tLCB0byB9ID0gb2xkU3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgIGNvbnN0IGFsbEZyb20gPSBTZWxlY3Rpb24zLmF0U3RhcnQob2xkU3RhdGUuZG9jKS5mcm9tO1xuICAgICAgICAgIGNvbnN0IGFsbEVuZCA9IFNlbGVjdGlvbjMuYXRFbmQob2xkU3RhdGUuZG9jKS50bztcbiAgICAgICAgICBjb25zdCBhbGxXYXNTZWxlY3RlZCA9IGZyb20gPT09IGFsbEZyb20gJiYgdG8gPT09IGFsbEVuZDtcbiAgICAgICAgICBpZiAoZW1wdHkgfHwgIWFsbFdhc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzRW1wdHkgPSBpc05vZGVFbXB0eShuZXdTdGF0ZS5kb2MpO1xuICAgICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0ciA9IG5ld1N0YXRlLnRyO1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgeyBjb21tYW5kcyB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICAgICAgICBpZiAoIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL3Bhc3RlLnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luOCwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTYgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIFBhc3RlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwicGFzdGVcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luOCh7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleTYoXCJ0aXB0YXBQYXN0ZVwiKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVQYXN0ZTogKF92aWV3LCBlLCBzbGljZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdChcInBhc3RlXCIsIHtcbiAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHNsaWNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL3RhYmluZGV4LnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luOSwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTcgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIFRhYmluZGV4ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwidGFiaW5kZXhcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luOSh7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleTcoXCJ0YWJpbmRleFwiKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBhdHRyaWJ1dGVzOiAoKSA9PiB0aGlzLmVkaXRvci5pc0VkaXRhYmxlID8geyB0YWJpbmRleDogXCIwXCIgfSA6IHt9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL3RleHREaXJlY3Rpb24udHNcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW4xMCwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTggfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIFRleHREaXJlY3Rpb24gPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJ0ZXh0RGlyZWN0aW9uXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpcmVjdGlvbjogdm9pZCAwXG4gICAgfTtcbiAgfSxcbiAgYWRkR2xvYmFsQXR0cmlidXRlcygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXJlY3Rpb24pIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucyk7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdHlwZXM6IG5vZGVFeHRlbnNpb25zLmZpbHRlcigoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24ubmFtZSAhPT0gXCJ0ZXh0XCIpLm1hcCgoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24ubmFtZSksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBkaXI6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24sXG4gICAgICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGRpciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGlyXCIpO1xuICAgICAgICAgICAgICBpZiAoZGlyICYmIChkaXIgPT09IFwibHRyXCIgfHwgZGlyID09PSBcInJ0bFwiIHx8IGRpciA9PT0gXCJhdXRvXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW5kZXJIVE1MOiAoYXR0cmlidXRlcykgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMuZGlyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlyOiBhdHRyaWJ1dGVzLmRpclxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbjEwKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5OChcInRleHREaXJlY3Rpb25cIiksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgYXR0cmlidXRlczogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRpcjogZGlyZWN0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL05vZGVQb3MudHNcbnZhciBOb2RlUG9zID0gY2xhc3MgX05vZGVQb3Mge1xuICBjb25zdHJ1Y3Rvcihwb3MsIGVkaXRvciwgaXNCbG9jayA9IGZhbHNlLCBub2RlID0gbnVsbCkge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSBudWxsO1xuICAgIHRoaXMuYWN0dWFsRGVwdGggPSBudWxsO1xuICAgIHRoaXMuaXNCbG9jayA9IGlzQmxvY2s7XG4gICAgdGhpcy5yZXNvbHZlZFBvcyA9IHBvcztcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLmN1cnJlbnROb2RlID0gbm9kZTtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLnR5cGUubmFtZTtcbiAgfVxuICBnZXQgbm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50Tm9kZSB8fCB0aGlzLnJlc29sdmVkUG9zLm5vZGUoKTtcbiAgfVxuICBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3Iudmlldy5kb21BdFBvcyh0aGlzLnBvcykubm9kZTtcbiAgfVxuICBnZXQgZGVwdGgoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLmFjdHVhbERlcHRoKSAhPSBudWxsID8gX2EgOiB0aGlzLnJlc29sdmVkUG9zLmRlcHRoO1xuICB9XG4gIGdldCBwb3MoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQb3MucG9zO1xuICB9XG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUuY29udGVudDtcbiAgfVxuICBzZXQgY29udGVudChjb250ZW50KSB7XG4gICAgbGV0IGZyb20gPSB0aGlzLmZyb207XG4gICAgbGV0IHRvID0gdGhpcy50bztcbiAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICBpZiAodGhpcy5jb250ZW50LnNpemUgPT09IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgWW91IGNhblxcdTIwMTl0IHNldCBjb250ZW50IG9uIGEgYmxvY2sgbm9kZS4gVHJpZWQgdG8gc2V0IGNvbnRlbnQgb24gJHt0aGlzLm5hbWV9IGF0ICR7dGhpcy5wb3N9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZyb20gPSB0aGlzLmZyb20gKyAxO1xuICAgICAgdG8gPSB0aGlzLnRvIC0gMTtcbiAgICB9XG4gICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KHsgZnJvbSwgdG8gfSwgY29udGVudCk7XG4gIH1cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5hdHRycztcbiAgfVxuICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS50ZXh0Q29udGVudDtcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLm5vZGVTaXplO1xuICB9XG4gIGdldCBmcm9tKCkge1xuICAgIGlmICh0aGlzLmlzQmxvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnBvcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQb3Muc3RhcnQodGhpcy5yZXNvbHZlZFBvcy5kZXB0aCk7XG4gIH1cbiAgZ2V0IHJhbmdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICB0bzogdGhpcy50b1xuICAgIH07XG4gIH1cbiAgZ2V0IHRvKCkge1xuICAgIGlmICh0aGlzLmlzQmxvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnBvcyArIHRoaXMuc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQb3MuZW5kKHRoaXMucmVzb2x2ZWRQb3MuZGVwdGgpICsgKHRoaXMubm9kZS5pc1RleHQgPyAwIDogMSk7XG4gIH1cbiAgZ2V0IHBhcmVudCgpIHtcbiAgICBpZiAodGhpcy5kZXB0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudFBvcyA9IHRoaXMucmVzb2x2ZWRQb3Muc3RhcnQodGhpcy5yZXNvbHZlZFBvcy5kZXB0aCAtIDEpO1xuICAgIGNvbnN0ICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHBhcmVudFBvcyk7XG4gICAgcmV0dXJuIG5ldyBfTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcik7XG4gIH1cbiAgZ2V0IGJlZm9yZSgpIHtcbiAgICBsZXQgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy5mcm9tIC0gKHRoaXMuaXNCbG9jayA/IDEgOiAyKSk7XG4gICAgaWYgKCRwb3MuZGVwdGggIT09IHRoaXMuZGVwdGgpIHtcbiAgICAgICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMuZnJvbSAtIDMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9Ob2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yKTtcbiAgfVxuICBnZXQgYWZ0ZXIoKSB7XG4gICAgbGV0ICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMudG8gKyAodGhpcy5pc0Jsb2NrID8gMiA6IDEpKTtcbiAgICBpZiAoJHBvcy5kZXB0aCAhPT0gdGhpcy5kZXB0aCkge1xuICAgICAgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy50byArIDMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9Ob2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yKTtcbiAgfVxuICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLm5vZGUuY29udGVudC5mb3JFYWNoKChub2RlLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IGlzQmxvY2sgPSBub2RlLmlzQmxvY2sgJiYgIW5vZGUuaXNUZXh0YmxvY2s7XG4gICAgICBjb25zdCBpc05vblRleHRBdG9tID0gbm9kZS5pc0F0b20gJiYgIW5vZGUuaXNUZXh0O1xuICAgICAgY29uc3QgdGFyZ2V0UG9zID0gdGhpcy5wb3MgKyBvZmZzZXQgKyAoaXNOb25UZXh0QXRvbSA/IDAgOiAxKTtcbiAgICAgIGlmICh0YXJnZXRQb3MgPCAwIHx8IHRhcmdldFBvcyA+IHRoaXMucmVzb2x2ZWRQb3MuZG9jLm5vZGVTaXplIC0gMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0YXJnZXRQb3MpO1xuICAgICAgaWYgKCFpc0Jsb2NrICYmICRwb3MuZGVwdGggPD0gdGhpcy5kZXB0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZE5vZGVQb3MgPSBuZXcgX05vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IsIGlzQmxvY2ssIGlzQmxvY2sgPyBub2RlIDogbnVsbCk7XG4gICAgICBpZiAoaXNCbG9jaykge1xuICAgICAgICBjaGlsZE5vZGVQb3MuYWN0dWFsRGVwdGggPSB0aGlzLmRlcHRoICsgMTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnB1c2gobmV3IF9Ob2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yLCBpc0Jsb2NrLCBpc0Jsb2NrID8gbm9kZSA6IG51bGwpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgZ2V0IGZpcnN0Q2hpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF0gfHwgbnVsbDtcbiAgfVxuICBnZXQgbGFzdENoaWxkKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICByZXR1cm4gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgfVxuICBjbG9zZXN0KHNlbGVjdG9yLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICBsZXQgbm9kZSA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcy5wYXJlbnQ7XG4gICAgd2hpbGUgKGN1cnJlbnROb2RlICYmICFub2RlKSB7XG4gICAgICBpZiAoY3VycmVudE5vZGUubm9kZS50eXBlLm5hbWUgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZUF0dHJpYnV0ZXMgPSBjdXJyZW50Tm9kZS5ub2RlLmF0dHJzO1xuICAgICAgICAgIGNvbnN0IGF0dHJLZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcyk7XG4gICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGF0dHJLZXlzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXR0cktleXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5vZGVBdHRyaWJ1dGVzW2tleV0gIT09IGF0dHJpYnV0ZXNba2V5XSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IGN1cnJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcXVlcnlTZWxlY3RvcihzZWxlY3RvciwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcywgdHJ1ZSlbMF0gfHwgbnVsbDtcbiAgfVxuICBxdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzID0ge30sIGZpcnN0SXRlbU9ubHkgPSBmYWxzZSkge1xuICAgIGxldCBub2RlcyA9IFtdO1xuICAgIGlmICghdGhpcy5jaGlsZHJlbiB8fCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBjb25zdCBhdHRyS2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpO1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGRQb3MpID0+IHtcbiAgICAgIGlmIChmaXJzdEl0ZW1Pbmx5ICYmIG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkUG9zLm5vZGUudHlwZS5uYW1lID09PSBzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBkb2VzQWxsQXR0cmlidXRlc01hdGNoID0gYXR0cktleXMuZXZlcnkoKGtleSkgPT4gYXR0cmlidXRlc1trZXldID09PSBjaGlsZFBvcy5ub2RlLmF0dHJzW2tleV0pO1xuICAgICAgICBpZiAoZG9lc0FsbEF0dHJpYnV0ZXNNYXRjaCkge1xuICAgICAgICAgIG5vZGVzLnB1c2goY2hpbGRQb3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RJdGVtT25seSAmJiBub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGNoaWxkUG9zLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGF0dHJpYnV0ZXMsIGZpcnN0SXRlbU9ubHkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cbiAgc2V0QXR0cmlidXRlKGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB7IHRyIH0gPSB0aGlzLmVkaXRvci5zdGF0ZTtcbiAgICB0ci5zZXROb2RlTWFya3VwKHRoaXMuZnJvbSwgdm9pZCAwLCB7XG4gICAgICAuLi50aGlzLm5vZGUuYXR0cnMsXG4gICAgICAuLi5hdHRyaWJ1dGVzXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3Iudmlldy5kaXNwYXRjaCh0cik7XG4gIH1cbn07XG5cbi8vIHNyYy9zdHlsZS50c1xudmFyIHN0eWxlID0gYC5Qcm9zZU1pcnJvciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cblxuLlByb3NlTWlycm9yIHtcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG4gIHdoaXRlLXNwYWNlOiBicmVhay1zcGFjZXM7XG4gIC13ZWJraXQtZm9udC12YXJpYW50LWxpZ2F0dXJlczogbm9uZTtcbiAgZm9udC12YXJpYW50LWxpZ2F0dXJlczogbm9uZTtcbiAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiBcImxpZ2FcIiAwOyAvKiB0aGUgYWJvdmUgZG9lc24ndCBzZWVtIHRvIHdvcmsgaW4gRWRnZSAqL1xufVxuXG4uUHJvc2VNaXJyb3IgW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdIHtcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcbn1cblxuLlByb3NlTWlycm9yIFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSBbY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXSB7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbn1cblxuLlByb3NlTWlycm9yIHByZSB7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbn1cblxuaW1nLlByb3NlTWlycm9yLXNlcGFyYXRvciB7XG4gIGRpc3BsYXk6IGlubGluZSAhaW1wb3J0YW50O1xuICBib3JkZXI6IG5vbmUgIWltcG9ydGFudDtcbiAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XG4gIHdpZHRoOiAwICFpbXBvcnRhbnQ7XG4gIGhlaWdodDogMCAhaW1wb3J0YW50O1xufVxuXG4uUHJvc2VNaXJyb3ItZ2FwY3Vyc29yIHtcbiAgZGlzcGxheTogbm9uZTtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbWFyZ2luOiAwO1xufVxuXG4uUHJvc2VNaXJyb3ItZ2FwY3Vyc29yOmFmdGVyIHtcbiAgY29udGVudDogXCJcIjtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAtMnB4O1xuICB3aWR0aDogMjBweDtcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIGJsYWNrO1xuICBhbmltYXRpb246IFByb3NlTWlycm9yLWN1cnNvci1ibGluayAxLjFzIHN0ZXBzKDIsIHN0YXJ0KSBpbmZpbml0ZTtcbn1cblxuQGtleWZyYW1lcyBQcm9zZU1pcnJvci1jdXJzb3ItYmxpbmsge1xuICB0byB7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICB9XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICo6OnNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqOjotbW96LXNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqIHtcbiAgY2FyZXQtY29sb3I6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItZm9jdXNlZCAuUHJvc2VNaXJyb3ItZ2FwY3Vyc29yIHtcbiAgZGlzcGxheTogYmxvY2s7XG59YDtcblxuLy8gc3JjL3V0aWxpdGllcy9jcmVhdGVTdHlsZVRhZy50c1xuZnVuY3Rpb24gY3JlYXRlU3R5bGVUYWcoc3R5bGUyLCBub25jZSwgc3VmZml4KSB7XG4gIGNvbnN0IHRpcHRhcFN0eWxlVGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3R5bGVbZGF0YS10aXB0YXAtc3R5bGUke3N1ZmZpeCA/IGAtJHtzdWZmaXh9YCA6IFwiXCJ9XWApO1xuICBpZiAodGlwdGFwU3R5bGVUYWcgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdGlwdGFwU3R5bGVUYWc7XG4gIH1cbiAgY29uc3Qgc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZU5vZGUuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICB9XG4gIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoYGRhdGEtdGlwdGFwLXN0eWxlJHtzdWZmaXggPyBgLSR7c3VmZml4fWAgOiBcIlwifWAsIFwiXCIpO1xuICBzdHlsZU5vZGUuaW5uZXJIVE1MID0gc3R5bGUyO1xuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQoc3R5bGVOb2RlKTtcbiAgcmV0dXJuIHN0eWxlTm9kZTtcbn1cblxuLy8gc3JjL0VkaXRvci50c1xudmFyIEVkaXRvciA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNzcyA9IG51bGw7XG4gICAgdGhpcy5jbGFzc05hbWUgPSBcInRpcHRhcFwiO1xuICAgIHRoaXMuZWRpdG9yVmlldyA9IG51bGw7XG4gICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGNvbnNpZGVyZWQgaW5pdGlhbGl6ZWQgYWZ0ZXIgdGhlIGBjcmVhdGVgIGV2ZW50IGhhcyBiZWVuIGVtaXR0ZWQuXG4gICAgICovXG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5leHRlbnNpb25TdG9yYWdlID0ge307XG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgSUQgZm9yIHRoaXMgZWRpdG9yIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDkpO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGVsZW1lbnQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgOiBudWxsLFxuICAgICAgY29udGVudDogXCJcIixcbiAgICAgIGluamVjdENTUzogdHJ1ZSxcbiAgICAgIGluamVjdE5vbmNlOiB2b2lkIDAsXG4gICAgICBleHRlbnNpb25zOiBbXSxcbiAgICAgIGF1dG9mb2N1czogZmFsc2UsXG4gICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgIHRleHREaXJlY3Rpb246IHZvaWQgMCxcbiAgICAgIGVkaXRvclByb3BzOiB7fSxcbiAgICAgIHBhcnNlT3B0aW9uczoge30sXG4gICAgICBjb3JlRXh0ZW5zaW9uT3B0aW9uczoge30sXG4gICAgICBlbmFibGVJbnB1dFJ1bGVzOiB0cnVlLFxuICAgICAgZW5hYmxlUGFzdGVSdWxlczogdHJ1ZSxcbiAgICAgIGVuYWJsZUNvcmVFeHRlbnNpb25zOiB0cnVlLFxuICAgICAgZW5hYmxlQ29udGVudENoZWNrOiBmYWxzZSxcbiAgICAgIGVtaXRDb250ZW50RXJyb3I6IGZhbHNlLFxuICAgICAgb25CZWZvcmVDcmVhdGU6ICgpID0+IG51bGwsXG4gICAgICBvbkNyZWF0ZTogKCkgPT4gbnVsbCxcbiAgICAgIG9uTW91bnQ6ICgpID0+IG51bGwsXG4gICAgICBvblVubW91bnQ6ICgpID0+IG51bGwsXG4gICAgICBvblVwZGF0ZTogKCkgPT4gbnVsbCxcbiAgICAgIG9uU2VsZWN0aW9uVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgICAgb25UcmFuc2FjdGlvbjogKCkgPT4gbnVsbCxcbiAgICAgIG9uRm9jdXM6ICgpID0+IG51bGwsXG4gICAgICBvbkJsdXI6ICgpID0+IG51bGwsXG4gICAgICBvbkRlc3Ryb3k6ICgpID0+IG51bGwsXG4gICAgICBvbkNvbnRlbnRFcnJvcjogKHsgZXJyb3IgfSkgPT4ge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0sXG4gICAgICBvblBhc3RlOiAoKSA9PiBudWxsLFxuICAgICAgb25Ecm9wOiAoKSA9PiBudWxsLFxuICAgICAgb25EZWxldGU6ICgpID0+IG51bGxcbiAgICB9O1xuICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNldCBvZiB1dGlsaXRpZXMgZm9yIHdvcmtpbmcgd2l0aCBwb3NpdGlvbnMgYW5kIHJhbmdlcy5cbiAgICAgKi9cbiAgICB0aGlzLnV0aWxzID0ge1xuICAgICAgZ2V0VXBkYXRlZFBvc2l0aW9uLFxuICAgICAgY3JlYXRlTWFwcGFibGVQb3NpdGlvblxuICAgIH07XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuY3JlYXRlRXh0ZW5zaW9uTWFuYWdlcigpO1xuICAgIHRoaXMuY3JlYXRlQ29tbWFuZE1hbmFnZXIoKTtcbiAgICB0aGlzLmNyZWF0ZVNjaGVtYSgpO1xuICAgIHRoaXMub24oXCJiZWZvcmVDcmVhdGVcIiwgdGhpcy5vcHRpb25zLm9uQmVmb3JlQ3JlYXRlKTtcbiAgICB0aGlzLmVtaXQoXCJiZWZvcmVDcmVhdGVcIiwgeyBlZGl0b3I6IHRoaXMgfSk7XG4gICAgdGhpcy5vbihcIm1vdW50XCIsIHRoaXMub3B0aW9ucy5vbk1vdW50KTtcbiAgICB0aGlzLm9uKFwidW5tb3VudFwiLCB0aGlzLm9wdGlvbnMub25Vbm1vdW50KTtcbiAgICB0aGlzLm9uKFwiY29udGVudEVycm9yXCIsIHRoaXMub3B0aW9ucy5vbkNvbnRlbnRFcnJvcik7XG4gICAgdGhpcy5vbihcImNyZWF0ZVwiLCB0aGlzLm9wdGlvbnMub25DcmVhdGUpO1xuICAgIHRoaXMub24oXCJ1cGRhdGVcIiwgdGhpcy5vcHRpb25zLm9uVXBkYXRlKTtcbiAgICB0aGlzLm9uKFwic2VsZWN0aW9uVXBkYXRlXCIsIHRoaXMub3B0aW9ucy5vblNlbGVjdGlvblVwZGF0ZSk7XG4gICAgdGhpcy5vbihcInRyYW5zYWN0aW9uXCIsIHRoaXMub3B0aW9ucy5vblRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLm9uKFwiZm9jdXNcIiwgdGhpcy5vcHRpb25zLm9uRm9jdXMpO1xuICAgIHRoaXMub24oXCJibHVyXCIsIHRoaXMub3B0aW9ucy5vbkJsdXIpO1xuICAgIHRoaXMub24oXCJkZXN0cm95XCIsIHRoaXMub3B0aW9ucy5vbkRlc3Ryb3kpO1xuICAgIHRoaXMub24oXCJkcm9wXCIsICh7IGV2ZW50LCBzbGljZSwgbW92ZWQgfSkgPT4gdGhpcy5vcHRpb25zLm9uRHJvcChldmVudCwgc2xpY2UsIG1vdmVkKSk7XG4gICAgdGhpcy5vbihcInBhc3RlXCIsICh7IGV2ZW50LCBzbGljZSB9KSA9PiB0aGlzLm9wdGlvbnMub25QYXN0ZShldmVudCwgc2xpY2UpKTtcbiAgICB0aGlzLm9uKFwiZGVsZXRlXCIsIHRoaXMub3B0aW9ucy5vbkRlbGV0ZSk7XG4gICAgY29uc3QgaW5pdGlhbERvYyA9IHRoaXMuY3JlYXRlRG9jKCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gcmVzb2x2ZUZvY3VzUG9zaXRpb24oaW5pdGlhbERvYywgdGhpcy5vcHRpb25zLmF1dG9mb2N1cyk7XG4gICAgdGhpcy5lZGl0b3JTdGF0ZSA9IEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgICBkb2M6IGluaXRpYWxEb2MsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgc2VsZWN0aW9uOiBzZWxlY3Rpb24gfHwgdm9pZCAwXG4gICAgfSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICB0aGlzLm1vdW50KHRoaXMub3B0aW9ucy5lbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaCB0aGUgZWRpdG9yIHRvIHRoZSBET00sIGNyZWF0aW5nIGEgbmV3IGVkaXRvciB2aWV3LlxuICAgKi9cbiAgbW91bnQoZWwpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBbdGlwdGFwIGVycm9yXTogVGhlIGVkaXRvciBjYW5ub3QgYmUgbW91bnRlZCBiZWNhdXNlIHRoZXJlIGlzIG5vICdkb2N1bWVudCcgZGVmaW5lZCBpbiB0aGlzIGVudmlyb25tZW50LmBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlVmlldyhlbCk7XG4gICAgdGhpcy5lbWl0KFwibW91bnRcIiwgeyBlZGl0b3I6IHRoaXMgfSk7XG4gICAgaWYgKHRoaXMuY3NzICYmICFkb2N1bWVudC5oZWFkLmNvbnRhaW5zKHRoaXMuY3NzKSkge1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLmNzcyk7XG4gICAgfVxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b2ZvY3VzICE9PSBmYWxzZSAmJiB0aGlzLm9wdGlvbnMuYXV0b2ZvY3VzICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMuZm9jdXModGhpcy5vcHRpb25zLmF1dG9mb2N1cyk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJjcmVhdGVcIiwgeyBlZGl0b3I6IHRoaXMgfSk7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH0sIDApO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGVkaXRvciBmcm9tIHRoZSBET00sIGJ1dCBzdGlsbCBhbGxvdyByZW1vdW50aW5nIGF0IGEgZGlmZmVyZW50IHBvaW50IGluIHRpbWVcbiAgICovXG4gIHVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuZWRpdG9yVmlldykge1xuICAgICAgY29uc3QgZG9tID0gdGhpcy5lZGl0b3JWaWV3LmRvbTtcbiAgICAgIGlmIChkb20gPT0gbnVsbCA/IHZvaWQgMCA6IGRvbS5lZGl0b3IpIHtcbiAgICAgICAgZGVsZXRlIGRvbS5lZGl0b3I7XG4gICAgICB9XG4gICAgICB0aGlzLmVkaXRvclZpZXcuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmVkaXRvclZpZXcgPSBudWxsO1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmNzcyAmJiAhZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7dGhpcy5jbGFzc05hbWV9YCkubGVuZ3RoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY3NzLnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5jc3MucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jc3MucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRoaXMuY3NzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jc3MpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gcmVtb3ZlIENTUyBlbGVtZW50OlwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3NzID0gbnVsbDtcbiAgICB0aGlzLmVtaXQoXCJ1bm1vdW50XCIsIHsgZWRpdG9yOiB0aGlzIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RvcmFnZS5cbiAgICovXG4gIGdldCBzdG9yYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuc2lvblN0b3JhZ2U7XG4gIH1cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBvZiBhbGwgcmVnaXN0ZXJlZCBjb21tYW5kcy5cbiAgICovXG4gIGdldCBjb21tYW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jb21tYW5kcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgY29tbWFuZCBjaGFpbiB0byBjYWxsIG11bHRpcGxlIGNvbW1hbmRzIGF0IG9uY2UuXG4gICAqL1xuICBjaGFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jaGFpbigpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGNvbW1hbmQgb3IgYSBjb21tYW5kIGNoYWluIGNhbiBiZSBleGVjdXRlZC4gV2l0aG91dCBleGVjdXRpbmcgaXQuXG4gICAqL1xuICBjYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY2FuKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluamVjdCBDU1Mgc3R5bGVzLlxuICAgKi9cbiAgaW5qZWN0Q1NTKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5qZWN0Q1NTICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5jc3MgPSBjcmVhdGVTdHlsZVRhZyhzdHlsZSwgdGhpcy5vcHRpb25zLmluamVjdE5vbmNlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBlZGl0b3Igb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgQSBsaXN0IG9mIG9wdGlvbnNcbiAgICovXG4gIHNldE9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgaWYgKCF0aGlzLmVkaXRvclZpZXcgfHwgIXRoaXMuc3RhdGUgfHwgdGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVkaXRvclByb3BzKSB7XG4gICAgICB0aGlzLnZpZXcuc2V0UHJvcHModGhpcy5vcHRpb25zLmVkaXRvclByb3BzKTtcbiAgICB9XG4gICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHRoaXMuc3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgZWRpdGFibGUgc3RhdGUgb2YgdGhlIGVkaXRvci5cbiAgICovXG4gIHNldEVkaXRhYmxlKGVkaXRhYmxlLCBlbWl0VXBkYXRlID0gdHJ1ZSkge1xuICAgIHRoaXMuc2V0T3B0aW9ucyh7IGVkaXRhYmxlIH0pO1xuICAgIGlmIChlbWl0VXBkYXRlKSB7XG4gICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgeyBlZGl0b3I6IHRoaXMsIHRyYW5zYWN0aW9uOiB0aGlzLnN0YXRlLnRyLCBhcHBlbmRlZFRyYW5zYWN0aW9uczogW10gfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVkaXRvciBpcyBlZGl0YWJsZS5cbiAgICovXG4gIGdldCBpc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZWRpdGFibGUgJiYgdGhpcy52aWV3ICYmIHRoaXMudmlldy5lZGl0YWJsZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRpdG9yIHN0YXRlLlxuICAgKi9cbiAgZ2V0IHZpZXcoKSB7XG4gICAgaWYgKHRoaXMuZWRpdG9yVmlldykge1xuICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yVmlldztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm94eShcbiAgICAgIHtcbiAgICAgICAgc3RhdGU6IHRoaXMuZWRpdG9yU3RhdGUsXG4gICAgICAgIHVwZGF0ZVN0YXRlOiAoc3RhdGUpID0+IHtcbiAgICAgICAgICB0aGlzLmVkaXRvclN0YXRlID0gc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BhdGNoOiAodHIpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb24odHIpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTdHViIHNvbWUgY29tbW9ubHkgYWNjZXNzZWQgcHJvcGVydGllcyB0byBwcmV2ZW50IGVycm9yc1xuICAgICAgICBjb21wb3Npbmc6IGZhbHNlLFxuICAgICAgICBkcmFnZ2luZzogbnVsbCxcbiAgICAgICAgZWRpdGFibGU6IHRydWUsXG4gICAgICAgIGlzRGVzdHJveWVkOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZ2V0OiAob2JqLCBrZXkpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5lZGl0b3JWaWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3JWaWV3W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXkgPT09IFwic3RhdGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yU3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQob2JqLCBrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgW3RpcHRhcCBlcnJvcl06IFRoZSBlZGl0b3IgdmlldyBpcyBub3QgYXZhaWxhYmxlLiBDYW5ub3QgYWNjZXNzIHZpZXdbJyR7a2V5fSddLiBUaGUgZWRpdG9yIG1heSBub3QgYmUgbW91bnRlZCB5ZXQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAqL1xuICBnZXQgc3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuZWRpdG9yVmlldykge1xuICAgICAgdGhpcy5lZGl0b3JTdGF0ZSA9IHRoaXMudmlldy5zdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yU3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgUHJvc2VNaXJyb3IgcGx1Z2luLlxuICAgKlxuICAgKiBAcGFyYW0gcGx1Z2luIEEgUHJvc2VNaXJyb3IgcGx1Z2luXG4gICAqIEBwYXJhbSBoYW5kbGVQbHVnaW5zIENvbnRyb2wgaG93IHRvIG1lcmdlIHRoZSBwbHVnaW4gaW50byB0aGUgZXhpc3RpbmcgcGx1Z2lucy5cbiAgICogQHJldHVybnMgVGhlIG5ldyBlZGl0b3Igc3RhdGVcbiAgICovXG4gIHJlZ2lzdGVyUGx1Z2luKHBsdWdpbiwgaGFuZGxlUGx1Z2lucykge1xuICAgIGNvbnN0IHBsdWdpbnMgPSBpc0Z1bmN0aW9uKGhhbmRsZVBsdWdpbnMpID8gaGFuZGxlUGx1Z2lucyhwbHVnaW4sIFsuLi50aGlzLnN0YXRlLnBsdWdpbnNdKSA6IFsuLi50aGlzLnN0YXRlLnBsdWdpbnMsIHBsdWdpbl07XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHsgcGx1Z2lucyB9KTtcbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICAvKipcbiAgICogVW5yZWdpc3RlciBhIFByb3NlTWlycm9yIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIG5hbWVPclBsdWdpbktleVRvUmVtb3ZlIFRoZSBwbHVnaW5zIG5hbWVcbiAgICogQHJldHVybnMgVGhlIG5ldyBlZGl0b3Igc3RhdGUgb3IgdW5kZWZpbmVkIGlmIHRoZSBlZGl0b3IgaXMgZGVzdHJveWVkXG4gICAqL1xuICB1bnJlZ2lzdGVyUGx1Z2luKG5hbWVPclBsdWdpbktleVRvUmVtb3ZlKSB7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IHByZXZQbHVnaW5zID0gdGhpcy5zdGF0ZS5wbHVnaW5zO1xuICAgIGxldCBwbHVnaW5zID0gcHJldlBsdWdpbnM7XG4gICAgW10uY29uY2F0KG5hbWVPclBsdWdpbktleVRvUmVtb3ZlKS5mb3JFYWNoKChuYW1lT3JQbHVnaW5LZXkpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yUGx1Z2luS2V5ID09PSBcInN0cmluZ1wiID8gYCR7bmFtZU9yUGx1Z2luS2V5fSRgIDogbmFtZU9yUGx1Z2luS2V5LmtleTtcbiAgICAgIHBsdWdpbnMgPSBwbHVnaW5zLmZpbHRlcigocGx1Z2luKSA9PiAhcGx1Z2luLmtleS5zdGFydHNXaXRoKG5hbWUpKTtcbiAgICB9KTtcbiAgICBpZiAocHJldlBsdWdpbnMubGVuZ3RoID09PSBwbHVnaW5zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcbiAgICAgIHBsdWdpbnNcbiAgICB9KTtcbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBleHRlbnNpb24gbWFuYWdlci5cbiAgICovXG4gIGNyZWF0ZUV4dGVuc2lvbk1hbmFnZXIoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBjb3JlRXh0ZW5zaW9ucyA9IHRoaXMub3B0aW9ucy5lbmFibGVDb3JlRXh0ZW5zaW9ucyA/IFtcbiAgICAgIEVkaXRhYmxlLFxuICAgICAgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIuY29uZmlndXJlKHtcbiAgICAgICAgYmxvY2tTZXBhcmF0b3I6IChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jb3JlRXh0ZW5zaW9uT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNsaXBib2FyZFRleHRTZXJpYWxpemVyKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYmxvY2tTZXBhcmF0b3JcbiAgICAgIH0pLFxuICAgICAgQ29tbWFuZHMsXG4gICAgICBGb2N1c0V2ZW50cyxcbiAgICAgIEtleW1hcCxcbiAgICAgIFRhYmluZGV4LFxuICAgICAgRHJvcCxcbiAgICAgIFBhc3RlLFxuICAgICAgRGVsZXRlLFxuICAgICAgVGV4dERpcmVjdGlvbi5jb25maWd1cmUoe1xuICAgICAgICBkaXJlY3Rpb246IHRoaXMub3B0aW9ucy50ZXh0RGlyZWN0aW9uXG4gICAgICB9KVxuICAgIF0uZmlsdGVyKChleHQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmVuYWJsZUNvcmVFeHRlbnNpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZW5hYmxlQ29yZUV4dGVuc2lvbnNbZXh0Lm5hbWVdICE9PSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pIDogW107XG4gICAgY29uc3QgYWxsRXh0ZW5zaW9ucyA9IFsuLi5jb3JlRXh0ZW5zaW9ucywgLi4udGhpcy5vcHRpb25zLmV4dGVuc2lvbnNdLmZpbHRlcigoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICByZXR1cm4gW1wiZXh0ZW5zaW9uXCIsIFwibm9kZVwiLCBcIm1hcmtcIl0uaW5jbHVkZXMoZXh0ZW5zaW9uID09IG51bGwgPyB2b2lkIDAgOiBleHRlbnNpb24udHlwZSk7XG4gICAgfSk7XG4gICAgdGhpcy5leHRlbnNpb25NYW5hZ2VyID0gbmV3IEV4dGVuc2lvbk1hbmFnZXIoYWxsRXh0ZW5zaW9ucywgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gY29tbWFuZCBtYW5hZ2VyLlxuICAgKi9cbiAgY3JlYXRlQ29tbWFuZE1hbmFnZXIoKSB7XG4gICAgdGhpcy5jb21tYW5kTWFuYWdlciA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICBlZGl0b3I6IHRoaXNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHNjaGVtYS5cbiAgICovXG4gIGNyZWF0ZVNjaGVtYSgpIHtcbiAgICB0aGlzLnNjaGVtYSA9IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5zY2hlbWE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGluaXRpYWwgZG9jdW1lbnQuXG4gICAqL1xuICBjcmVhdGVEb2MoKSB7XG4gICAgbGV0IGRvYztcbiAgICB0cnkge1xuICAgICAgZG9jID0gY3JlYXRlRG9jdW1lbnQodGhpcy5vcHRpb25zLmNvbnRlbnQsIHRoaXMuc2NoZW1hLCB0aGlzLm9wdGlvbnMucGFyc2VPcHRpb25zLCB7XG4gICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogdGhpcy5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVja1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIEVycm9yKSB8fCAhW1wiW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSlNPTiBjb250ZW50XCIsIFwiW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSFRNTCBjb250ZW50XCJdLmluY2x1ZGVzKGUubWVzc2FnZSkpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcImNvbnRlbnRFcnJvclwiLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgIGRpc2FibGVDb2xsYWJvcmF0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKFwiY29sbGFib3JhdGlvblwiIGluIHRoaXMuc3RvcmFnZSAmJiB0eXBlb2YgdGhpcy5zdG9yYWdlLmNvbGxhYm9yYXRpb24gPT09IFwib2JqZWN0XCIgJiYgdGhpcy5zdG9yYWdlLmNvbGxhYm9yYXRpb24pIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5jb2xsYWJvcmF0aW9uLmlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmZpbHRlcigoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24ubmFtZSAhPT0gXCJjb2xsYWJvcmF0aW9uXCIpO1xuICAgICAgICAgIHRoaXMuY3JlYXRlRXh0ZW5zaW9uTWFuYWdlcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRvYyA9IGNyZWF0ZURvY3VtZW50KHRoaXMub3B0aW9ucy5jb250ZW50LCB0aGlzLnNjaGVtYSwgdGhpcy5vcHRpb25zLnBhcnNlT3B0aW9ucywge1xuICAgICAgICBlcnJvck9uSW52YWxpZENvbnRlbnQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRvYztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHZpZXcuXG4gICAqL1xuICBjcmVhdGVWaWV3KGVsZW1lbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5lZGl0b3JWaWV3ID0gbmV3IEVkaXRvclZpZXcoZWxlbWVudCwge1xuICAgICAgLi4udGhpcy5vcHRpb25zLmVkaXRvclByb3BzLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAvLyBhZGQgYHJvbGU9XCJ0ZXh0Ym94XCJgIHRvIHRoZSBlZGl0b3IgZWxlbWVudFxuICAgICAgICByb2xlOiBcInRleHRib3hcIixcbiAgICAgICAgLi4uKF9hID0gdGhpcy5vcHRpb25zLmVkaXRvclByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYXR0cmlidXRlc1xuICAgICAgfSxcbiAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb246IHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgc3RhdGU6IHRoaXMuZWRpdG9yU3RhdGUsXG4gICAgICBtYXJrVmlld3M6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5tYXJrVmlld3MsXG4gICAgICBub2RlVmlld3M6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5ub2RlVmlld3NcbiAgICB9KTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoe1xuICAgICAgcGx1Z2luczogdGhpcy5leHRlbnNpb25NYW5hZ2VyLnBsdWdpbnNcbiAgICB9KTtcbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUobmV3U3RhdGUpO1xuICAgIHRoaXMucHJlcGVuZENsYXNzKCk7XG4gICAgdGhpcy5pbmplY3RDU1MoKTtcbiAgICBjb25zdCBkb20gPSB0aGlzLnZpZXcuZG9tO1xuICAgIGRvbS5lZGl0b3IgPSB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFsbCBub2RlIGFuZCBtYXJrIHZpZXdzLlxuICAgKi9cbiAgY3JlYXRlTm9kZVZpZXdzKCkge1xuICAgIGlmICh0aGlzLnZpZXcuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy52aWV3LnNldFByb3BzKHtcbiAgICAgIG1hcmtWaWV3czogdGhpcy5leHRlbnNpb25NYW5hZ2VyLm1hcmtWaWV3cyxcbiAgICAgIG5vZGVWaWV3czogdGhpcy5leHRlbnNpb25NYW5hZ2VyLm5vZGVWaWV3c1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQcmVwZW5kIGNsYXNzIG5hbWUgdG8gZWxlbWVudC5cbiAgICovXG4gIHByZXBlbmRDbGFzcygpIHtcbiAgICB0aGlzLnZpZXcuZG9tLmNsYXNzTmFtZSA9IGAke3RoaXMuY2xhc3NOYW1lfSAke3RoaXMudmlldy5kb20uY2xhc3NOYW1lfWA7XG4gIH1cbiAgY2FwdHVyZVRyYW5zYWN0aW9uKGZuKSB7XG4gICAgdGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICBmbigpO1xuICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgIGNvbnN0IHRyID0gdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uO1xuICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgcmV0dXJuIHRyO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY2FsbGJhY2sgb3ZlciB3aGljaCB0byBzZW5kIHRyYW5zYWN0aW9ucyAoc3RhdGUgdXBkYXRlcykgcHJvZHVjZWQgYnkgdGhlIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbiBBbiBlZGl0b3Igc3RhdGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGRpc3BhdGNoVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodGhpcy52aWV3LmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmICghdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKChzdGVwKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0ZXAoc3RlcCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBzdGF0ZSwgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0YXRlLmFwcGx5VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHNlbGVjdGlvbkhhc0NoYW5nZWQgPSAhdGhpcy5zdGF0ZS5zZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKTtcbiAgICBjb25zdCByb290VHJXYXNBcHBsaWVkID0gdHJhbnNhY3Rpb25zLmluY2x1ZGVzKHRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuZW1pdChcImJlZm9yZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgbmV4dFN0YXRlOiBzdGF0ZVxuICAgIH0pO1xuICAgIGlmICghcm9vdFRyV2FzQXBwbGllZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgIHRoaXMuZW1pdChcInRyYW5zYWN0aW9uXCIsIHtcbiAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgYXBwZW5kZWRUcmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9ucy5zbGljZSgxKVxuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb25IYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoXCJzZWxlY3Rpb25VcGRhdGVcIiwge1xuICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgIHRyYW5zYWN0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbW9zdFJlY2VudEZvY3VzVHIgPSB0cmFuc2FjdGlvbnMuZmluZExhc3QoKHRyKSA9PiB0ci5nZXRNZXRhKFwiZm9jdXNcIikgfHwgdHIuZ2V0TWV0YShcImJsdXJcIikpO1xuICAgIGNvbnN0IGZvY3VzMiA9IG1vc3RSZWNlbnRGb2N1c1RyID09IG51bGwgPyB2b2lkIDAgOiBtb3N0UmVjZW50Rm9jdXNUci5nZXRNZXRhKFwiZm9jdXNcIik7XG4gICAgY29uc3QgYmx1cjIgPSBtb3N0UmVjZW50Rm9jdXNUciA9PSBudWxsID8gdm9pZCAwIDogbW9zdFJlY2VudEZvY3VzVHIuZ2V0TWV0YShcImJsdXJcIik7XG4gICAgaWYgKGZvY3VzMikge1xuICAgICAgdGhpcy5lbWl0KFwiZm9jdXNcIiwge1xuICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgIGV2ZW50OiBmb2N1czIuZXZlbnQsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHRyYW5zYWN0aW9uOiBtb3N0UmVjZW50Rm9jdXNUclxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChibHVyMikge1xuICAgICAgdGhpcy5lbWl0KFwiYmx1clwiLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgZXZlbnQ6IGJsdXIyLmV2ZW50LFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICB0cmFuc2FjdGlvbjogbW9zdFJlY2VudEZvY3VzVHJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24uZ2V0TWV0YShcInByZXZlbnRVcGRhdGVcIikgfHwgIXRyYW5zYWN0aW9ucy5zb21lKCh0cikgPT4gdHIuZG9jQ2hhbmdlZCkgfHwgcHJldlN0YXRlLmRvYy5lcShzdGF0ZS5kb2MpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB7XG4gICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIGFwcGVuZGVkVHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnMuc2xpY2UoMSlcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGF0dHJpYnV0ZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2RlIG9yIG1hcmsuXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzKG5hbWVPclR5cGUpIHtcbiAgICByZXR1cm4gZ2V0QXR0cmlidXRlcyh0aGlzLnN0YXRlLCBuYW1lT3JUeXBlKTtcbiAgfVxuICBpc0FjdGl2ZShuYW1lT3JBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzT3JVbmRlZmluZWQpIHtcbiAgICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPckF0dHJpYnV0ZXMgPT09IFwic3RyaW5nXCIgPyBuYW1lT3JBdHRyaWJ1dGVzIDogbnVsbDtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gdHlwZW9mIG5hbWVPckF0dHJpYnV0ZXMgPT09IFwic3RyaW5nXCIgPyBhdHRyaWJ1dGVzT3JVbmRlZmluZWQgOiBuYW1lT3JBdHRyaWJ1dGVzO1xuICAgIHJldHVybiBpc0FjdGl2ZSh0aGlzLnN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBkb2N1bWVudCBhcyBKU09OLlxuICAgKi9cbiAgZ2V0SlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kb2MudG9KU09OKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSFRNTC5cbiAgICovXG4gIGdldEhUTUwoKSB7XG4gICAgcmV0dXJuIGdldEhUTUxGcm9tRnJhZ21lbnQodGhpcy5zdGF0ZS5kb2MuY29udGVudCwgdGhpcy5zY2hlbWEpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGRvY3VtZW50IGFzIHRleHQuXG4gICAqL1xuICBnZXRUZXh0KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gXCJcXG5cXG5cIiwgdGV4dFNlcmlhbGl6ZXJzID0ge30gfSA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIGdldFRleHQodGhpcy5zdGF0ZS5kb2MsIHtcbiAgICAgIGJsb2NrU2VwYXJhdG9yLFxuICAgICAgdGV4dFNlcmlhbGl6ZXJzOiB7XG4gICAgICAgIC4uLmdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEodGhpcy5zY2hlbWEpLFxuICAgICAgICAuLi50ZXh0U2VyaWFsaXplcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlcmUgaXMgbm8gY29udGVudC5cbiAgICovXG4gIGdldCBpc0VtcHR5KCkge1xuICAgIHJldHVybiBpc05vZGVFbXB0eSh0aGlzLnN0YXRlLmRvYyk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIGVkaXRvci5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiKTtcbiAgICB0aGlzLnVubW91bnQoKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZWRpdG9yIGlzIGFscmVhZHkgZGVzdHJveWVkLlxuICAgKi9cbiAgZ2V0IGlzRGVzdHJveWVkKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuZWRpdG9yVmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmlzRGVzdHJveWVkKSAhPSBudWxsID8gX2IgOiB0cnVlO1xuICB9XG4gICRub2RlKHNlbGVjdG9yLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdGhpcy4kZG9jKSA9PSBudWxsID8gdm9pZCAwIDogX2EucXVlcnlTZWxlY3RvcihzZWxlY3RvciwgYXR0cmlidXRlcykpIHx8IG51bGw7XG4gIH1cbiAgJG5vZGVzKHNlbGVjdG9yLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdGhpcy4kZG9jKSA9PSBudWxsID8gdm9pZCAwIDogX2EucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcykpIHx8IG51bGw7XG4gIH1cbiAgJHBvcyhwb3MpIHtcbiAgICBjb25zdCAkcG9zID0gdGhpcy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xuICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzKTtcbiAgfVxuICBnZXQgJGRvYygpIHtcbiAgICByZXR1cm4gdGhpcy4kcG9zKDApO1xuICB9XG59O1xuXG4vLyBzcmMvaW5wdXRSdWxlcy9tYXJrSW5wdXRSdWxlLnRzXG5mdW5jdGlvbiBtYXJrSW5wdXRSdWxlKGNvbmZpZykge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB2b2lkIDAsIG1hdGNoKTtcbiAgICAgIGlmIChhdHRyaWJ1dGVzID09PSBmYWxzZSB8fCBhdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XG4gICAgICBjb25zdCBjYXB0dXJlR3JvdXAgPSBtYXRjaFttYXRjaC5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IG1hdGNoWzBdO1xuICAgICAgaWYgKGNhcHR1cmVHcm91cCkge1xuICAgICAgICBjb25zdCBzdGFydFNwYWNlcyA9IGZ1bGxNYXRjaC5zZWFyY2goL1xcUy8pO1xuICAgICAgICBjb25zdCB0ZXh0U3RhcnQgPSByYW5nZS5mcm9tICsgZnVsbE1hdGNoLmluZGV4T2YoY2FwdHVyZUdyb3VwKTtcbiAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVkTWFya3MgPSBnZXRNYXJrc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHN0YXRlLmRvYykuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBpdGVtLm1hcmsudHlwZS5leGNsdWRlZDtcbiAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCgodHlwZSkgPT4gdHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgdHlwZSAhPT0gaXRlbS5tYXJrLnR5cGUpO1xuICAgICAgICB9KS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udG8gPiB0ZXh0U3RhcnQpO1xuICAgICAgICBpZiAoZXhjbHVkZWRNYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dEVuZCA8IHJhbmdlLnRvKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHRleHRFbmQsIHJhbmdlLnRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xuICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFya0VuZCA9IHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcyArIGNhcHR1cmVHcm91cC5sZW5ndGg7XG4gICAgICAgIHRyLmFkZE1hcmsocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCBtYXJrRW5kLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyB8fCB7fSkpO1xuICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKGNvbmZpZy50eXBlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVuZG9hYmxlOiBjb25maWcudW5kb2FibGVcbiAgfSk7XG59XG5cbi8vIHNyYy9pbnB1dFJ1bGVzL25vZGVJbnB1dFJ1bGUudHNcbmZ1bmN0aW9uIG5vZGVJbnB1dFJ1bGUoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHZvaWQgMCwgbWF0Y2gpIHx8IHt9O1xuICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XG4gICAgICBjb25zdCBzdGFydCA9IHJhbmdlLmZyb207XG4gICAgICBsZXQgZW5kID0gcmFuZ2UudG87XG4gICAgICBjb25zdCBuZXdOb2RlID0gY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcbiAgICAgICAgbGV0IG1hdGNoU3RhcnQgPSBzdGFydCArIG9mZnNldDtcbiAgICAgICAgaWYgKG1hdGNoU3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICBtYXRjaFN0YXJ0ID0gZW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZCA9IG1hdGNoU3RhcnQgKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdENoYXIgPSBtYXRjaFswXVttYXRjaFswXS5sZW5ndGggLSAxXTtcbiAgICAgICAgdHIuaW5zZXJ0VGV4dChsYXN0Q2hhciwgc3RhcnQgKyBtYXRjaFswXS5sZW5ndGggLSAxKTtcbiAgICAgICAgdHIucmVwbGFjZVdpdGgobWF0Y2hTdGFydCwgZW5kLCBuZXdOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0pIHtcbiAgICAgICAgY29uc3QgaW5zZXJ0aW9uU3RhcnQgPSBjb25maWcudHlwZS5pc0lubGluZSA/IHN0YXJ0IDogc3RhcnQgLSAxO1xuICAgICAgICB0ci5pbnNlcnQoaW5zZXJ0aW9uU3RhcnQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKSkuZGVsZXRlKHRyLm1hcHBpbmcubWFwKHN0YXJ0KSwgdHIubWFwcGluZy5tYXAoZW5kKSk7XG4gICAgICB9XG4gICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgIH0sXG4gICAgdW5kb2FibGU6IGNvbmZpZy51bmRvYWJsZVxuICB9KTtcbn1cblxuLy8gc3JjL2lucHV0UnVsZXMvdGV4dGJsb2NrVHlwZUlucHV0UnVsZS50c1xuZnVuY3Rpb24gdGV4dGJsb2NrVHlwZUlucHV0UnVsZShjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgY29uc3QgJHN0YXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSk7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB2b2lkIDAsIG1hdGNoKSB8fCB7fTtcbiAgICAgIGlmICghJHN0YXJ0Lm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRzdGFydC5pbmRleCgtMSksICRzdGFydC5pbmRleEFmdGVyKC0xKSwgY29uZmlnLnR5cGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3RhdGUudHIuZGVsZXRlKHJhbmdlLmZyb20sIHJhbmdlLnRvKS5zZXRCbG9ja1R5cGUocmFuZ2UuZnJvbSwgcmFuZ2UuZnJvbSwgY29uZmlnLnR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgIH0sXG4gICAgdW5kb2FibGU6IGNvbmZpZy51bmRvYWJsZVxuICB9KTtcbn1cblxuLy8gc3JjL2lucHV0UnVsZXMvdGV4dElucHV0UnVsZS50c1xuZnVuY3Rpb24gdGV4dElucHV0UnVsZShjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgbGV0IGluc2VydCA9IGNvbmZpZy5yZXBsYWNlO1xuICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbTtcbiAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvO1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcbiAgICAgICAgaW5zZXJ0ICs9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCArIG1hdGNoWzFdLmxlbmd0aCk7XG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICAgICAgY29uc3QgY3V0T2ZmID0gc3RhcnQgLSBlbmQ7XG4gICAgICAgIGlmIChjdXRPZmYgPiAwKSB7XG4gICAgICAgICAgaW5zZXJ0ID0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0IC0gY3V0T2ZmLCBvZmZzZXQpICsgaW5zZXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS50ci5pbnNlcnRUZXh0KGluc2VydCwgc3RhcnQsIGVuZCk7XG4gICAgfSxcbiAgICB1bmRvYWJsZTogY29uZmlnLnVuZG9hYmxlXG4gIH0pO1xufVxuXG4vLyBzcmMvaW5wdXRSdWxlcy93cmFwcGluZ0lucHV0UnVsZS50c1xuaW1wb3J0IHsgY2FuSm9pbiBhcyBjYW5Kb2luMiwgZmluZFdyYXBwaW5nIH0gZnJvbSBcIkB0aXB0YXAvcG0vdHJhbnNmb3JtXCI7XG5mdW5jdGlvbiB3cmFwcGluZ0lucHV0UnVsZShjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2gsIGNoYWluIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHZvaWQgMCwgbWF0Y2gpIHx8IHt9O1xuICAgICAgY29uc3QgdHIgPSBzdGF0ZS50ci5kZWxldGUocmFuZ2UuZnJvbSwgcmFuZ2UudG8pO1xuICAgICAgY29uc3QgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSk7XG4gICAgICBjb25zdCBibG9ja1JhbmdlID0gJHN0YXJ0LmJsb2NrUmFuZ2UoKTtcbiAgICAgIGNvbnN0IHdyYXBwaW5nID0gYmxvY2tSYW5nZSAmJiBmaW5kV3JhcHBpbmcoYmxvY2tSYW5nZSwgY29uZmlnLnR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKCF3cmFwcGluZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRyLndyYXAoYmxvY2tSYW5nZSwgd3JhcHBpbmcpO1xuICAgICAgaWYgKGNvbmZpZy5rZWVwTWFya3MgJiYgY29uZmlnLmVkaXRvcikge1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gY29uZmlnLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpO1xuICAgICAgICBpZiAobWFya3MpIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcbiAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBub2RlVHlwZSA9IGNvbmZpZy50eXBlLm5hbWUgPT09IFwiYnVsbGV0TGlzdFwiIHx8IGNvbmZpZy50eXBlLm5hbWUgPT09IFwib3JkZXJlZExpc3RcIiA/IFwibGlzdEl0ZW1cIiA6IFwidGFza0xpc3RcIjtcbiAgICAgICAgY2hhaW4oKS51cGRhdGVBdHRyaWJ1dGVzKG5vZGVUeXBlLCBhdHRyaWJ1dGVzKS5ydW4oKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJlZm9yZSA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20gLSAxKS5ub2RlQmVmb3JlO1xuICAgICAgaWYgKGJlZm9yZSAmJiBiZWZvcmUudHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgY2FuSm9pbjIodHIuZG9jLCByYW5nZS5mcm9tIC0gMSkgJiYgKCFjb25maWcuam9pblByZWRpY2F0ZSB8fCBjb25maWcuam9pblByZWRpY2F0ZShtYXRjaCwgYmVmb3JlKSkpIHtcbiAgICAgICAgdHIuam9pbihyYW5nZS5mcm9tIC0gMSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1bmRvYWJsZTogY29uZmlnLnVuZG9hYmxlXG4gIH0pO1xufVxuXG4vLyBzcmMvanN4LXJ1bnRpbWUudHNcbmZ1bmN0aW9uIEZyYWdtZW50Nihwcm9wcykge1xuICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG52YXIgaCA9ICh0YWcsIGF0dHJpYnV0ZXMpID0+IHtcbiAgaWYgKHRhZyA9PT0gXCJzbG90XCIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAodGFnIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGFnKGF0dHJpYnV0ZXMpO1xuICB9XG4gIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnJlc3QgfSA9IGF0dHJpYnV0ZXMgIT0gbnVsbCA/IGF0dHJpYnV0ZXMgOiB7fTtcbiAgaWYgKHRhZyA9PT0gXCJzdmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNWRyBlbGVtZW50cyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGUgSlNYIHN5bnRheCwgdXNlIHRoZSBhcnJheSBzeW50YXggaW5zdGVhZFwiKTtcbiAgfVxuICByZXR1cm4gW3RhZywgcmVzdCwgY2hpbGRyZW5dO1xufTtcblxuLy8gc3JjL2xpYi9SZXNpemFibGVOb2RlVmlldy50c1xudmFyIGlzVG91Y2hFdmVudCA9IChlKSA9PiB7XG4gIHJldHVybiBcInRvdWNoZXNcIiBpbiBlO1xufTtcbnZhciBSZXNpemFibGVOb2RlVmlldyA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUmVzaXphYmxlTm9kZVZpZXcgaW5zdGFuY2UuXG4gICAqXG4gICAqIFRoZSBjb25zdHJ1Y3RvciBzZXRzIHVwIHRoZSByZXNpemUgaGFuZGxlcywgYXBwbGllcyBpbml0aWFsIHNpemluZyBmcm9tXG4gICAqIG5vZGUgYXR0cmlidXRlcywgYW5kIGNvbmZpZ3VyZXMgYWxsIHJlc2l6ZSBiZWhhdmlvciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHJlc2l6YWJsZSBub2RlIHZpZXdcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKiogQWN0aXZlIHJlc2l6ZSBoYW5kbGUgZGlyZWN0aW9ucyAqL1xuICAgIHRoaXMuZGlyZWN0aW9ucyA9IFtcImJvdHRvbS1sZWZ0XCIsIFwiYm90dG9tLXJpZ2h0XCIsIFwidG9wLWxlZnRcIiwgXCJ0b3AtcmlnaHRcIl07XG4gICAgLyoqIE1pbmltdW0gYWxsb3dlZCBkaW1lbnNpb25zICovXG4gICAgdGhpcy5taW5TaXplID0ge1xuICAgICAgaGVpZ2h0OiA4LFxuICAgICAgd2lkdGg6IDhcbiAgICB9O1xuICAgIC8qKiBXaGV0aGVyIHRvIGFsd2F5cyBwcmVzZXJ2ZSBhc3BlY3QgcmF0aW8gKi9cbiAgICB0aGlzLnByZXNlcnZlQXNwZWN0UmF0aW8gPSBmYWxzZTtcbiAgICAvKiogQ1NTIGNsYXNzIG5hbWVzIGZvciBlbGVtZW50cyAqL1xuICAgIHRoaXMuY2xhc3NOYW1lcyA9IHtcbiAgICAgIGNvbnRhaW5lcjogXCJcIixcbiAgICAgIHdyYXBwZXI6IFwiXCIsXG4gICAgICBoYW5kbGU6IFwiXCIsXG4gICAgICByZXNpemluZzogXCJcIlxuICAgIH07XG4gICAgLyoqIEluaXRpYWwgd2lkdGggb2YgdGhlIGVsZW1lbnQgKGZvciBhc3BlY3QgcmF0aW8gY2FsY3VsYXRpb24pICovXG4gICAgdGhpcy5pbml0aWFsV2lkdGggPSAwO1xuICAgIC8qKiBJbml0aWFsIGhlaWdodCBvZiB0aGUgZWxlbWVudCAoZm9yIGFzcGVjdCByYXRpbyBjYWxjdWxhdGlvbikgKi9cbiAgICB0aGlzLmluaXRpYWxIZWlnaHQgPSAwO1xuICAgIC8qKiBDYWxjdWxhdGVkIGFzcGVjdCByYXRpbyAod2lkdGggLyBoZWlnaHQpICovXG4gICAgdGhpcy5hc3BlY3RSYXRpbyA9IDE7XG4gICAgLyoqIFdoZXRoZXIgYSByZXNpemUgb3BlcmF0aW9uIGlzIGN1cnJlbnRseSBhY3RpdmUgKi9cbiAgICB0aGlzLmlzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAvKiogVGhlIGhhbmRsZSBjdXJyZW50bHkgYmVpbmcgZHJhZ2dlZCAqL1xuICAgIHRoaXMuYWN0aXZlSGFuZGxlID0gbnVsbDtcbiAgICAvKiogU3RhcnRpbmcgbW91c2UgWCBwb3NpdGlvbiB3aGVuIHJlc2l6ZSBiZWdhbiAqL1xuICAgIHRoaXMuc3RhcnRYID0gMDtcbiAgICAvKiogU3RhcnRpbmcgbW91c2UgWSBwb3NpdGlvbiB3aGVuIHJlc2l6ZSBiZWdhbiAqL1xuICAgIHRoaXMuc3RhcnRZID0gMDtcbiAgICAvKiogRWxlbWVudCB3aWR0aCB3aGVuIHJlc2l6ZSBiZWdhbiAqL1xuICAgIHRoaXMuc3RhcnRXaWR0aCA9IDA7XG4gICAgLyoqIEVsZW1lbnQgaGVpZ2h0IHdoZW4gcmVzaXplIGJlZ2FuICovXG4gICAgdGhpcy5zdGFydEhlaWdodCA9IDA7XG4gICAgLyoqIFdoZXRoZXIgU2hpZnQga2V5IGlzIGN1cnJlbnRseSBwcmVzc2VkIChmb3IgdGVtcG9yYXJ5IGFzcGVjdCByYXRpbyBsb2NrKSAqL1xuICAgIHRoaXMuaXNTaGlmdEtleVByZXNzZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG1vdXNlIG1vdmVtZW50IGR1cmluZyBhbiBhY3RpdmUgcmVzaXplLlxuICAgICAqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZGVsdGEgZnJvbSB0aGUgc3RhcnRpbmcgcG9zaXRpb24sIGNvbXB1dGVzIG5ldyBkaW1lbnNpb25zXG4gICAgICogYmFzZWQgb24gdGhlIGFjdGl2ZSBoYW5kbGUgZGlyZWN0aW9uLCBhcHBsaWVzIGNvbnN0cmFpbnRzIGFuZCBhc3BlY3QgcmF0aW8sXG4gICAgICogdGhlbiB1cGRhdGVzIHRoZSBlbGVtZW50J3Mgc3R5bGUgYW5kIGNhbGxzIHRoZSBvblJlc2l6ZSBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSBtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghdGhpcy5pc1Jlc2l6aW5nIHx8ICF0aGlzLmFjdGl2ZUhhbmRsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkZWx0YVggPSBldmVudC5jbGllbnRYIC0gdGhpcy5zdGFydFg7XG4gICAgICBjb25zdCBkZWx0YVkgPSBldmVudC5jbGllbnRZIC0gdGhpcy5zdGFydFk7XG4gICAgICB0aGlzLmhhbmRsZVJlc2l6ZShkZWx0YVgsIGRlbHRhWSk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVRvdWNoTW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlzUmVzaXppbmcgfHwgIXRoaXMuYWN0aXZlSGFuZGxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgIGlmICghdG91Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVsdGFYID0gdG91Y2guY2xpZW50WCAtIHRoaXMuc3RhcnRYO1xuICAgICAgY29uc3QgZGVsdGFZID0gdG91Y2guY2xpZW50WSAtIHRoaXMuc3RhcnRZO1xuICAgICAgdGhpcy5oYW5kbGVSZXNpemUoZGVsdGFYLCBkZWx0YVkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGxldGVzIHRoZSByZXNpemUgb3BlcmF0aW9uIHdoZW4gdGhlIG1vdXNlIGJ1dHRvbiBpcyByZWxlYXNlZC5cbiAgICAgKlxuICAgICAqIENhcHR1cmVzIGZpbmFsIGRpbWVuc2lvbnMsIGNhbGxzIHRoZSBvbkNvbW1pdCBjYWxsYmFjayB0byBwZXJzaXN0IGNoYW5nZXMsXG4gICAgICogcmVtb3ZlcyB0aGUgcmVzaXppbmcgc3RhdGUgYW5kIGNsYXNzLCBhbmQgY2xlYW5zIHVwIGRvY3VtZW50LWxldmVsIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsZU1vdXNlVXAgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaXNSZXNpemluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmaW5hbFdpZHRoID0gdGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgY29uc3QgZmluYWxIZWlnaHQgPSB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5vbkNvbW1pdChmaW5hbFdpZHRoLCBmaW5hbEhlaWdodCk7XG4gICAgICB0aGlzLmlzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuYWN0aXZlSGFuZGxlID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmRhdGFzZXQucmVzaXplU3RhdGUgPSBcImZhbHNlXCI7XG4gICAgICBpZiAodGhpcy5jbGFzc05hbWVzLnJlc2l6aW5nKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jbGFzc05hbWVzLnJlc2l6aW5nKTtcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5oYW5kbGVLZXlVcCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFja3MgU2hpZnQga2V5IHN0YXRlIHRvIGVuYWJsZSB0ZW1wb3JhcnkgYXNwZWN0IHJhdGlvIGxvY2tpbmcuXG4gICAgICpcbiAgICAgKiBXaGVuIFNoaWZ0IGlzIHByZXNzZWQgZHVyaW5nIHJlc2l6ZSwgYXNwZWN0IHJhdGlvIGlzIHByZXNlcnZlZCBldmVuIGlmXG4gICAgICogcHJlc2VydmVBc3BlY3RSYXRpbyBpcyBmYWxzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBrZXlib2FyZCBldmVudFxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJTaGlmdFwiKSB7XG4gICAgICAgIHRoaXMuaXNTaGlmdEtleVByZXNzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhY2tzIFNoaWZ0IGtleSByZWxlYXNlIHRvIGRpc2FibGUgdGVtcG9yYXJ5IGFzcGVjdCByYXRpbyBsb2NraW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGtleWJvYXJkIGV2ZW50XG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVLZXlVcCA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJTaGlmdFwiKSB7XG4gICAgICAgIHRoaXMuaXNTaGlmdEtleVByZXNzZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgdGhpcy5ub2RlID0gb3B0aW9ucy5ub2RlO1xuICAgIHRoaXMuZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcbiAgICB0aGlzLmNvbnRlbnRFbGVtZW50ID0gb3B0aW9ucy5jb250ZW50RWxlbWVudDtcbiAgICB0aGlzLmdldFBvcyA9IG9wdGlvbnMuZ2V0UG9zO1xuICAgIHRoaXMub25SZXNpemUgPSBvcHRpb25zLm9uUmVzaXplO1xuICAgIHRoaXMub25Db21taXQgPSBvcHRpb25zLm9uQ29tbWl0O1xuICAgIHRoaXMub25VcGRhdGUgPSBvcHRpb25zLm9uVXBkYXRlO1xuICAgIGlmICgoX2EgPSBvcHRpb25zLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5taW4pIHtcbiAgICAgIHRoaXMubWluU2l6ZSA9IHtcbiAgICAgICAgLi4udGhpcy5taW5TaXplLFxuICAgICAgICAuLi5vcHRpb25zLm9wdGlvbnMubWluXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoKF9iID0gb3B0aW9ucy5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2IubWF4KSB7XG4gICAgICB0aGlzLm1heFNpemUgPSBvcHRpb25zLm9wdGlvbnMubWF4O1xuICAgIH1cbiAgICBpZiAoKF9jID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2MuZGlyZWN0aW9ucykge1xuICAgICAgdGhpcy5kaXJlY3Rpb25zID0gb3B0aW9ucy5vcHRpb25zLmRpcmVjdGlvbnM7XG4gICAgfVxuICAgIGlmICgoX2QgPSBvcHRpb25zLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZC5wcmVzZXJ2ZUFzcGVjdFJhdGlvKSB7XG4gICAgICB0aGlzLnByZXNlcnZlQXNwZWN0UmF0aW8gPSBvcHRpb25zLm9wdGlvbnMucHJlc2VydmVBc3BlY3RSYXRpbztcbiAgICB9XG4gICAgaWYgKChfZSA9IG9wdGlvbnMub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmNsYXNzTmFtZSkge1xuICAgICAgdGhpcy5jbGFzc05hbWVzID0ge1xuICAgICAgICBjb250YWluZXI6IG9wdGlvbnMub3B0aW9ucy5jbGFzc05hbWUuY29udGFpbmVyIHx8IFwiXCIsXG4gICAgICAgIHdyYXBwZXI6IG9wdGlvbnMub3B0aW9ucy5jbGFzc05hbWUud3JhcHBlciB8fCBcIlwiLFxuICAgICAgICBoYW5kbGU6IG9wdGlvbnMub3B0aW9ucy5jbGFzc05hbWUuaGFuZGxlIHx8IFwiXCIsXG4gICAgICAgIHJlc2l6aW5nOiBvcHRpb25zLm9wdGlvbnMuY2xhc3NOYW1lLnJlc2l6aW5nIHx8IFwiXCJcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMud3JhcHBlciA9IHRoaXMuY3JlYXRlV3JhcHBlcigpO1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICB0aGlzLmFwcGx5SW5pdGlhbFNpemUoKTtcbiAgICB0aGlzLmF0dGFjaEhhbmRsZXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG9wLWxldmVsIERPTSBub2RlIHRoYXQgc2hvdWxkIGJlIHBsYWNlZCBpbiB0aGUgZWRpdG9yLlxuICAgKlxuICAgKiBUaGlzIGlzIHJlcXVpcmVkIGJ5IHRoZSBQcm9zZU1pcnJvciBOb2RlVmlldyBpbnRlcmZhY2UuIFRoZSBjb250YWluZXJcbiAgICogaW5jbHVkZXMgdGhlIHdyYXBwZXIsIGhhbmRsZXMsIGFuZCB0aGUgYWN0dWFsIGNvbnRlbnQgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIGNvbnRhaW5lciBlbGVtZW50IHRvIGJlIGluc2VydGVkIGludG8gdGhlIGVkaXRvclxuICAgKi9cbiAgZ2V0IGRvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0IGNvbnRlbnRET00oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudEVsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBub2RlJ3MgY29udGVudCBvciBhdHRyaWJ1dGVzIGNoYW5nZS5cbiAgICpcbiAgICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgbm9kZSByZWZlcmVuY2UuIElmIGEgY3VzdG9tIGBvblVwZGF0ZWAgY2FsbGJhY2tcbiAgICogd2FzIHByb3ZpZGVkLCBpdCB3aWxsIGJlIGNhbGxlZCB0byBoYW5kbGUgYWRkaXRpb25hbCB1cGRhdGUgbG9naWMuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlIC0gVGhlIG5ldy91cGRhdGVkIG5vZGVcbiAgICogQHBhcmFtIGRlY29yYXRpb25zIC0gTm9kZSBkZWNvcmF0aW9uc1xuICAgKiBAcGFyYW0gaW5uZXJEZWNvcmF0aW9ucyAtIElubmVyIGRlY29yYXRpb25zXG4gICAqIEByZXR1cm5zIGBmYWxzZWAgaWYgdGhlIG5vZGUgdHlwZSBoYXMgY2hhbmdlZCAocmVxdWlyZXMgZnVsbCByZWJ1aWxkKSwgb3RoZXJ3aXNlIHRoZSByZXN1bHQgb2YgYG9uVXBkYXRlYCBvciBgdHJ1ZWBcbiAgICovXG4gIHVwZGF0ZShub2RlLCBkZWNvcmF0aW9ucywgaW5uZXJEZWNvcmF0aW9ucykge1xuICAgIGlmIChub2RlLnR5cGUgIT09IHRoaXMubm9kZS50eXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgaWYgKHRoaXMub25VcGRhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm9uVXBkYXRlKG5vZGUsIGRlY29yYXRpb25zLCBpbm5lckRlY29yYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFudXAgbWV0aG9kIGNhbGxlZCB3aGVuIHRoZSBub2RlIHZpZXcgaXMgYmVpbmcgcmVtb3ZlZC5cbiAgICpcbiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiBUaGlzIGlzIHJlcXVpcmVkXG4gICAqIGJ5IHRoZSBQcm9zZU1pcnJvciBOb2RlVmlldyBpbnRlcmZhY2UuIElmIGEgcmVzaXplIGlzIGFjdGl2ZSB3aGVuXG4gICAqIGRlc3Ryb3kgaXMgY2FsbGVkLCBpdCB3aWxsIGJlIHByb3Blcmx5IGNhbmNlbGxlZC5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuaXNSZXNpemluZykge1xuICAgICAgdGhpcy5jb250YWluZXIuZGF0YXNldC5yZXNpemVTdGF0ZSA9IFwiZmFsc2VcIjtcbiAgICAgIGlmICh0aGlzLmNsYXNzTmFtZXMucmVzaXppbmcpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmNsYXNzTmFtZXMucmVzaXppbmcpO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXlEb3duKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLmhhbmRsZUtleVVwKTtcbiAgICAgIHRoaXMuaXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5hY3RpdmVIYW5kbGUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgb3V0ZXIgY29udGFpbmVyIGVsZW1lbnQuXG4gICAqXG4gICAqIFRoZSBjb250YWluZXIgaXMgdGhlIHRvcC1sZXZlbCBlbGVtZW50IHJldHVybmVkIGJ5IHRoZSBOb2RlVmlldyBhbmRcbiAgICogd3JhcHMgdGhlIGVudGlyZSByZXNpemFibGUgbm9kZS4gSXQncyBzZXQgdXAgd2l0aCBmbGV4Ym94IHRvIGhhbmRsZVxuICAgKiBhbGlnbm1lbnQgYW5kIGluY2x1ZGVzIGRhdGEgYXR0cmlidXRlcyBmb3Igc3R5bGluZyBhbmQgaWRlbnRpZmljYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBjb250YWluZXIgZWxlbWVudFxuICAgKi9cbiAgY3JlYXRlQ29udGFpbmVyKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGVsZW1lbnQuZGF0YXNldC5yZXNpemVDb250YWluZXIgPSBcIlwiO1xuICAgIGVsZW1lbnQuZGF0YXNldC5ub2RlID0gdGhpcy5ub2RlLnR5cGUubmFtZTtcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICBlbGVtZW50LnN0eWxlLmp1c3RpZnlDb250ZW50ID0gXCJmbGV4LXN0YXJ0XCI7XG4gICAgZWxlbWVudC5zdHlsZS5hbGlnbkl0ZW1zID0gXCJmbGV4LXN0YXJ0XCI7XG4gICAgaWYgKHRoaXMuY2xhc3NOYW1lcy5jb250YWluZXIpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWVzLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSB3cmFwcGVyIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udGVudCBhbmQgaGFuZGxlcy5cbiAgICpcbiAgICogVGhlIHdyYXBwZXIgdXNlcyByZWxhdGl2ZSBwb3NpdGlvbmluZyBzbyB0aGF0IHJlc2l6ZSBoYW5kbGVzIGNhbiBiZVxuICAgKiBwb3NpdGlvbmVkIGFic29sdXRlbHkgd2l0aGluIGl0LiBUaGlzIGlzIHRoZSBkaXJlY3QgcGFyZW50IG9mIHRoZVxuICAgKiBjb250ZW50IGVsZW1lbnQgYmVpbmcgbWFkZSByZXNpemFibGUuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSB3cmFwcGVyIGVsZW1lbnRcbiAgICovXG4gIGNyZWF0ZVdyYXBwZXIoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgZWxlbWVudC5kYXRhc2V0LnJlc2l6ZVdyYXBwZXIgPSBcIlwiO1xuICAgIGlmICh0aGlzLmNsYXNzTmFtZXMud3JhcHBlcikge1xuICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZXMud3JhcHBlcjtcbiAgICB9XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVzaXplIGhhbmRsZSBlbGVtZW50IGZvciBhIHNwZWNpZmljIGRpcmVjdGlvbi5cbiAgICpcbiAgICogRWFjaCBoYW5kbGUgaXMgYWJzb2x1dGVseSBwb3NpdGlvbmVkIGFuZCBpbmNsdWRlcyBhIGRhdGEgYXR0cmlidXRlXG4gICAqIGlkZW50aWZ5aW5nIGl0cyBkaXJlY3Rpb24gZm9yIHN0eWxpbmcgcHVycG9zZXMuXG4gICAqXG4gICAqIEBwYXJhbSBkaXJlY3Rpb24gLSBUaGUgcmVzaXplIGRpcmVjdGlvbiBmb3IgdGhpcyBoYW5kbGVcbiAgICogQHJldHVybnMgVGhlIGhhbmRsZSBlbGVtZW50XG4gICAqL1xuICBjcmVhdGVIYW5kbGUoZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgaGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBoYW5kbGUuZGF0YXNldC5yZXNpemVIYW5kbGUgPSBkaXJlY3Rpb247XG4gICAgaGFuZGxlLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGlmICh0aGlzLmNsYXNzTmFtZXMuaGFuZGxlKSB7XG4gICAgICBoYW5kbGUuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWVzLmhhbmRsZTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZTtcbiAgfVxuICAvKipcbiAgICogUG9zaXRpb25zIGEgaGFuZGxlIGVsZW1lbnQgYWNjb3JkaW5nIHRvIGl0cyBkaXJlY3Rpb24uXG4gICAqXG4gICAqIENvcm5lciBoYW5kbGVzIChlLmcuLCAndG9wLWxlZnQnKSBhcmUgcG9zaXRpb25lZCBhdCB0aGUgaW50ZXJzZWN0aW9uXG4gICAqIG9mIHR3byBlZGdlcy4gRWRnZSBoYW5kbGVzIChlLmcuLCAndG9wJykgc3BhbiB0aGUgZnVsbCB3aWR0aCBvciBoZWlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSBoYW5kbGUgLSBUaGUgaGFuZGxlIGVsZW1lbnQgdG8gcG9zaXRpb25cbiAgICogQHBhcmFtIGRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gZGV0ZXJtaW5pbmcgdGhlIHBvc2l0aW9uXG4gICAqL1xuICBwb3NpdGlvbkhhbmRsZShoYW5kbGUsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IGlzVG9wID0gZGlyZWN0aW9uLmluY2x1ZGVzKFwidG9wXCIpO1xuICAgIGNvbnN0IGlzQm90dG9tID0gZGlyZWN0aW9uLmluY2x1ZGVzKFwiYm90dG9tXCIpO1xuICAgIGNvbnN0IGlzTGVmdCA9IGRpcmVjdGlvbi5pbmNsdWRlcyhcImxlZnRcIik7XG4gICAgY29uc3QgaXNSaWdodCA9IGRpcmVjdGlvbi5pbmNsdWRlcyhcInJpZ2h0XCIpO1xuICAgIGlmIChpc1RvcCkge1xuICAgICAgaGFuZGxlLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgIH1cbiAgICBpZiAoaXNCb3R0b20pIHtcbiAgICAgIGhhbmRsZS5zdHlsZS5ib3R0b20gPSBcIjBcIjtcbiAgICB9XG4gICAgaWYgKGlzTGVmdCkge1xuICAgICAgaGFuZGxlLnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICB9XG4gICAgaWYgKGlzUmlnaHQpIHtcbiAgICAgIGhhbmRsZS5zdHlsZS5yaWdodCA9IFwiMFwiO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInRvcFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJib3R0b21cIikge1xuICAgICAgaGFuZGxlLnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICAgIGhhbmRsZS5zdHlsZS5yaWdodCA9IFwiMFwiO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImxlZnRcIiB8fCBkaXJlY3Rpb24gPT09IFwicmlnaHRcIikge1xuICAgICAgaGFuZGxlLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgICAgaGFuZGxlLnN0eWxlLmJvdHRvbSA9IFwiMFwiO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgYXR0YWNoZXMgYWxsIHJlc2l6ZSBoYW5kbGVzIHRvIHRoZSB3cmFwcGVyLlxuICAgKlxuICAgKiBJdGVyYXRlcyB0aHJvdWdoIHRoZSBjb25maWd1cmVkIGRpcmVjdGlvbnMsIGNyZWF0ZXMgYSBoYW5kbGUgZm9yIGVhY2gsXG4gICAqIHBvc2l0aW9ucyBpdCwgYXR0YWNoZXMgdGhlIG1vdXNlZG93biBsaXN0ZW5lciwgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIERPTS5cbiAgICovXG4gIGF0dGFjaEhhbmRsZXMoKSB7XG4gICAgdGhpcy5kaXJlY3Rpb25zLmZvckVhY2goKGRpcmVjdGlvbikgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlID0gdGhpcy5jcmVhdGVIYW5kbGUoZGlyZWN0aW9uKTtcbiAgICAgIHRoaXMucG9zaXRpb25IYW5kbGUoaGFuZGxlLCBkaXJlY3Rpb24pO1xuICAgICAgaGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGV2ZW50KSA9PiB0aGlzLmhhbmRsZVJlc2l6ZVN0YXJ0KGV2ZW50LCBkaXJlY3Rpb24pKTtcbiAgICAgIGhhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCAoZXZlbnQpID0+IHRoaXMuaGFuZGxlUmVzaXplU3RhcnQoZXZlbnQsIGRpcmVjdGlvbikpO1xuICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGhhbmRsZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgaW5pdGlhbCBzaXppbmcgZnJvbSBub2RlIGF0dHJpYnV0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIElmIHdpZHRoL2hlaWdodCBhdHRyaWJ1dGVzIGV4aXN0IG9uIHRoZSBub2RlLCB0aGV5J3JlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQuXG4gICAqIE90aGVyd2lzZSwgdGhlIGVsZW1lbnQncyBuYXR1cmFsL2N1cnJlbnQgZGltZW5zaW9ucyBhcmUgbWVhc3VyZWQuIFRoZSBhc3BlY3RcbiAgICogcmF0aW8gaXMgY2FsY3VsYXRlZCBmb3IgbGF0ZXIgdXNlIGluIGFzcGVjdC1yYXRpby1wcmVzZXJ2aW5nIHJlc2l6ZXMuXG4gICAqL1xuICBhcHBseUluaXRpYWxTaXplKCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5ub2RlLmF0dHJzLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMubm9kZS5hdHRycy5oZWlnaHQ7XG4gICAgaWYgKHdpZHRoKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgICB0aGlzLmluaXRpYWxXaWR0aCA9IHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmluaXRpYWxXaWR0aCA9IHRoaXMuZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB9XG4gICAgaWYgKGhlaWdodCkge1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgICB0aGlzLmluaXRpYWxIZWlnaHQgPSBoZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5pdGlhbEhlaWdodCA9IHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmluaXRpYWxXaWR0aCA+IDAgJiYgdGhpcy5pbml0aWFsSGVpZ2h0ID4gMCkge1xuICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IHRoaXMuaW5pdGlhbFdpZHRoIC8gdGhpcy5pbml0aWFsSGVpZ2h0O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgcmVzaXplIG9wZXJhdGlvbiB3aGVuIGEgaGFuZGxlIGlzIGNsaWNrZWQuXG4gICAqXG4gICAqIENhcHR1cmVzIHRoZSBzdGFydGluZyBtb3VzZSBwb3NpdGlvbiBhbmQgZWxlbWVudCBkaW1lbnNpb25zLCBzZXRzIHVwXG4gICAqIHRoZSByZXNpemUgc3RhdGUsIGFkZHMgdGhlIHJlc2l6aW5nIGNsYXNzIGFuZCBzdGF0ZSBhdHRyaWJ1dGUsIGFuZFxuICAgKiBhdHRhY2hlcyBkb2N1bWVudC1sZXZlbCBsaXN0ZW5lcnMgZm9yIG1vdXNlIG1vdmVtZW50IGFuZCBrZXlib2FyZCBpbnB1dC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIG1vdXNlIGRvd24gZXZlbnRcbiAgICogQHBhcmFtIGRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gb2YgdGhlIGhhbmRsZSBiZWluZyBkcmFnZ2VkXG4gICAqL1xuICBoYW5kbGVSZXNpemVTdGFydChldmVudCwgZGlyZWN0aW9uKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLmlzUmVzaXppbmcgPSB0cnVlO1xuICAgIHRoaXMuYWN0aXZlSGFuZGxlID0gZGlyZWN0aW9uO1xuICAgIGlmIChpc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgICB0aGlzLnN0YXJ0WCA9IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgIHRoaXMuc3RhcnRZID0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRZO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0WCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICB0aGlzLnN0YXJ0WSA9IGV2ZW50LmNsaWVudFk7XG4gICAgfVxuICAgIHRoaXMuc3RhcnRXaWR0aCA9IHRoaXMuZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLnN0YXJ0SGVpZ2h0ID0gdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICBpZiAodGhpcy5zdGFydFdpZHRoID4gMCAmJiB0aGlzLnN0YXJ0SGVpZ2h0ID4gMCkge1xuICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IHRoaXMuc3RhcnRXaWR0aCAvIHRoaXMuc3RhcnRIZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgaWYgKHBvcyAhPT0gdm9pZCAwKSB7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmRhdGFzZXQucmVzaXplU3RhdGUgPSBcInRydWVcIjtcbiAgICBpZiAodGhpcy5jbGFzc05hbWVzLnJlc2l6aW5nKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5yZXNpemluZyk7XG4gICAgfVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXlEb3duKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5oYW5kbGVLZXlVcCk7XG4gIH1cbiAgaGFuZGxlUmVzaXplKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgaWYgKCF0aGlzLmFjdGl2ZUhhbmRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRQcmVzZXJ2ZUFzcGVjdFJhdGlvID0gdGhpcy5wcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8IHRoaXMuaXNTaGlmdEtleVByZXNzZWQ7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLmNhbGN1bGF0ZU5ld0RpbWVuc2lvbnModGhpcy5hY3RpdmVIYW5kbGUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICBjb25zdCBjb25zdHJhaW5lZCA9IHRoaXMuYXBwbHlDb25zdHJhaW50cyh3aWR0aCwgaGVpZ2h0LCBzaG91bGRQcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtjb25zdHJhaW5lZC53aWR0aH1weGA7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke2NvbnN0cmFpbmVkLmhlaWdodH1weGA7XG4gICAgaWYgKHRoaXMub25SZXNpemUpIHtcbiAgICAgIHRoaXMub25SZXNpemUoY29uc3RyYWluZWQud2lkdGgsIGNvbnN0cmFpbmVkLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIG5ldyBkaW1lbnNpb25zIGJhc2VkIG9uIG1vdXNlIGRlbHRhIGFuZCByZXNpemUgZGlyZWN0aW9uLlxuICAgKlxuICAgKiBUYWtlcyB0aGUgc3RhcnRpbmcgZGltZW5zaW9ucyBhbmQgYXBwbGllcyB0aGUgbW91c2UgbW92ZW1lbnQgZGVsdGFcbiAgICogYWNjb3JkaW5nIHRvIHRoZSBoYW5kbGUgZGlyZWN0aW9uLiBGb3IgY29ybmVyIGhhbmRsZXMsIGJvdGggZGltZW5zaW9uc1xuICAgKiBhcmUgYWZmZWN0ZWQuIEZvciBlZGdlIGhhbmRsZXMsIG9ubHkgb25lIGRpbWVuc2lvbiBjaGFuZ2VzLiBJZiBhc3BlY3RcbiAgICogcmF0aW8gc2hvdWxkIGJlIHByZXNlcnZlZCwgZGVsZWdhdGVzIHRvIGFwcGx5QXNwZWN0UmF0aW8uXG4gICAqXG4gICAqIEBwYXJhbSBkaXJlY3Rpb24gLSBUaGUgYWN0aXZlIHJlc2l6ZSBoYW5kbGUgZGlyZWN0aW9uXG4gICAqIEBwYXJhbSBkZWx0YVggLSBIb3Jpem9udGFsIG1vdXNlIG1vdmVtZW50IHNpbmNlIHJlc2l6ZSBzdGFydFxuICAgKiBAcGFyYW0gZGVsdGFZIC0gVmVydGljYWwgbW91c2UgbW92ZW1lbnQgc2luY2UgcmVzaXplIHN0YXJ0XG4gICAqIEByZXR1cm5zIFRoZSBjYWxjdWxhdGVkIHdpZHRoIGFuZCBoZWlnaHRcbiAgICovXG4gIGNhbGN1bGF0ZU5ld0RpbWVuc2lvbnMoZGlyZWN0aW9uLCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIGxldCBuZXdXaWR0aCA9IHRoaXMuc3RhcnRXaWR0aDtcbiAgICBsZXQgbmV3SGVpZ2h0ID0gdGhpcy5zdGFydEhlaWdodDtcbiAgICBjb25zdCBpc1JpZ2h0ID0gZGlyZWN0aW9uLmluY2x1ZGVzKFwicmlnaHRcIik7XG4gICAgY29uc3QgaXNMZWZ0ID0gZGlyZWN0aW9uLmluY2x1ZGVzKFwibGVmdFwiKTtcbiAgICBjb25zdCBpc0JvdHRvbSA9IGRpcmVjdGlvbi5pbmNsdWRlcyhcImJvdHRvbVwiKTtcbiAgICBjb25zdCBpc1RvcCA9IGRpcmVjdGlvbi5pbmNsdWRlcyhcInRvcFwiKTtcbiAgICBpZiAoaXNSaWdodCkge1xuICAgICAgbmV3V2lkdGggPSB0aGlzLnN0YXJ0V2lkdGggKyBkZWx0YVg7XG4gICAgfSBlbHNlIGlmIChpc0xlZnQpIHtcbiAgICAgIG5ld1dpZHRoID0gdGhpcy5zdGFydFdpZHRoIC0gZGVsdGFYO1xuICAgIH1cbiAgICBpZiAoaXNCb3R0b20pIHtcbiAgICAgIG5ld0hlaWdodCA9IHRoaXMuc3RhcnRIZWlnaHQgKyBkZWx0YVk7XG4gICAgfSBlbHNlIGlmIChpc1RvcCkge1xuICAgICAgbmV3SGVpZ2h0ID0gdGhpcy5zdGFydEhlaWdodCAtIGRlbHRhWTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJyaWdodFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgIG5ld1dpZHRoID0gdGhpcy5zdGFydFdpZHRoICsgKGlzUmlnaHQgPyBkZWx0YVggOiAtZGVsdGFYKTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ0b3BcIiB8fCBkaXJlY3Rpb24gPT09IFwiYm90dG9tXCIpIHtcbiAgICAgIG5ld0hlaWdodCA9IHRoaXMuc3RhcnRIZWlnaHQgKyAoaXNCb3R0b20gPyBkZWx0YVkgOiAtZGVsdGFZKTtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkUHJlc2VydmVBc3BlY3RSYXRpbyA9IHRoaXMucHJlc2VydmVBc3BlY3RSYXRpbyB8fCB0aGlzLmlzU2hpZnRLZXlQcmVzc2VkO1xuICAgIGlmIChzaG91bGRQcmVzZXJ2ZUFzcGVjdFJhdGlvKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseUFzcGVjdFJhdGlvKG5ld1dpZHRoLCBuZXdIZWlnaHQsIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB7IHdpZHRoOiBuZXdXaWR0aCwgaGVpZ2h0OiBuZXdIZWlnaHQgfTtcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBtaW4vbWF4IGNvbnN0cmFpbnRzIHRvIGRpbWVuc2lvbnMuXG4gICAqXG4gICAqIFdoZW4gYXNwZWN0IHJhdGlvIGlzIE5PVCBwcmVzZXJ2ZWQsIGNvbnN0cmFpbnRzIGFyZSBhcHBsaWVkIGluZGVwZW5kZW50bHlcbiAgICogdG8gd2lkdGggYW5kIGhlaWdodC4gV2hlbiBhc3BlY3QgcmF0aW8gSVMgcHJlc2VydmVkLCBjb25zdHJhaW50cyBhcmVcbiAgICogYXBwbGllZCB3aGlsZSBtYWludGFpbmluZyB0aGUgYXNwZWN0IHJhdGlv4oCUaWYgb25lIGRpbWVuc2lvbiBoaXRzIGEgbGltaXQsXG4gICAqIHRoZSBvdGhlciBpcyByZWNhbGN1bGF0ZWQgcHJvcG9ydGlvbmFsbHkuXG4gICAqXG4gICAqIFRoaXMgZW5zdXJlcyB0aGF0IGFzcGVjdCByYXRpbyBpcyBuZXZlciBicm9rZW4gd2hlbiBjb25zdHJhaW5lZC5cbiAgICpcbiAgICogQHBhcmFtIHdpZHRoIC0gVGhlIHVuY29uc3RyYWluZWQgd2lkdGhcbiAgICogQHBhcmFtIGhlaWdodCAtIFRoZSB1bmNvbnN0cmFpbmVkIGhlaWdodFxuICAgKiBAcGFyYW0gcHJlc2VydmVBc3BlY3RSYXRpbyAtIFdoZXRoZXIgdG8gbWFpbnRhaW4gYXNwZWN0IHJhdGlvIHdoaWxlIGNvbnN0cmFpbmluZ1xuICAgKiBAcmV0dXJucyBUaGUgY29uc3RyYWluZWQgZGltZW5zaW9uc1xuICAgKi9cbiAgYXBwbHlDb25zdHJhaW50cyh3aWR0aCwgaGVpZ2h0LCBwcmVzZXJ2ZUFzcGVjdFJhdGlvKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGlmICghcHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgICAgbGV0IGNvbnN0cmFpbmVkV2lkdGgyID0gTWF0aC5tYXgodGhpcy5taW5TaXplLndpZHRoLCB3aWR0aCk7XG4gICAgICBsZXQgY29uc3RyYWluZWRIZWlnaHQyID0gTWF0aC5tYXgodGhpcy5taW5TaXplLmhlaWdodCwgaGVpZ2h0KTtcbiAgICAgIGlmICgoX2EgPSB0aGlzLm1heFNpemUpID09IG51bGwgPyB2b2lkIDAgOiBfYS53aWR0aCkge1xuICAgICAgICBjb25zdHJhaW5lZFdpZHRoMiA9IE1hdGgubWluKHRoaXMubWF4U2l6ZS53aWR0aCwgY29uc3RyYWluZWRXaWR0aDIpO1xuICAgICAgfVxuICAgICAgaWYgKChfYiA9IHRoaXMubWF4U2l6ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmhlaWdodCkge1xuICAgICAgICBjb25zdHJhaW5lZEhlaWdodDIgPSBNYXRoLm1pbih0aGlzLm1heFNpemUuaGVpZ2h0LCBjb25zdHJhaW5lZEhlaWdodDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgd2lkdGg6IGNvbnN0cmFpbmVkV2lkdGgyLCBoZWlnaHQ6IGNvbnN0cmFpbmVkSGVpZ2h0MiB9O1xuICAgIH1cbiAgICBsZXQgY29uc3RyYWluZWRXaWR0aCA9IHdpZHRoO1xuICAgIGxldCBjb25zdHJhaW5lZEhlaWdodCA9IGhlaWdodDtcbiAgICBpZiAoY29uc3RyYWluZWRXaWR0aCA8IHRoaXMubWluU2l6ZS53aWR0aCkge1xuICAgICAgY29uc3RyYWluZWRXaWR0aCA9IHRoaXMubWluU2l6ZS53aWR0aDtcbiAgICAgIGNvbnN0cmFpbmVkSGVpZ2h0ID0gY29uc3RyYWluZWRXaWR0aCAvIHRoaXMuYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW5lZEhlaWdodCA8IHRoaXMubWluU2l6ZS5oZWlnaHQpIHtcbiAgICAgIGNvbnN0cmFpbmVkSGVpZ2h0ID0gdGhpcy5taW5TaXplLmhlaWdodDtcbiAgICAgIGNvbnN0cmFpbmVkV2lkdGggPSBjb25zdHJhaW5lZEhlaWdodCAqIHRoaXMuYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIGlmICgoKF9jID0gdGhpcy5tYXhTaXplKSA9PSBudWxsID8gdm9pZCAwIDogX2Mud2lkdGgpICYmIGNvbnN0cmFpbmVkV2lkdGggPiB0aGlzLm1heFNpemUud2lkdGgpIHtcbiAgICAgIGNvbnN0cmFpbmVkV2lkdGggPSB0aGlzLm1heFNpemUud2lkdGg7XG4gICAgICBjb25zdHJhaW5lZEhlaWdodCA9IGNvbnN0cmFpbmVkV2lkdGggLyB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICBpZiAoKChfZCA9IHRoaXMubWF4U2l6ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmhlaWdodCkgJiYgY29uc3RyYWluZWRIZWlnaHQgPiB0aGlzLm1heFNpemUuaGVpZ2h0KSB7XG4gICAgICBjb25zdHJhaW5lZEhlaWdodCA9IHRoaXMubWF4U2l6ZS5oZWlnaHQ7XG4gICAgICBjb25zdHJhaW5lZFdpZHRoID0gY29uc3RyYWluZWRIZWlnaHQgKiB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4geyB3aWR0aDogY29uc3RyYWluZWRXaWR0aCwgaGVpZ2h0OiBjb25zdHJhaW5lZEhlaWdodCB9O1xuICB9XG4gIC8qKlxuICAgKiBBZGp1c3RzIGRpbWVuc2lvbnMgdG8gbWFpbnRhaW4gdGhlIG9yaWdpbmFsIGFzcGVjdCByYXRpby5cbiAgICpcbiAgICogRm9yIGhvcml6b250YWwgaGFuZGxlcyAobGVmdC9yaWdodCksIHVzZXMgd2lkdGggYXMgdGhlIHByaW1hcnkgZGltZW5zaW9uXG4gICAqIGFuZCBjYWxjdWxhdGVzIGhlaWdodCBmcm9tIGl0LiBGb3IgdmVydGljYWwgaGFuZGxlcyAodG9wL2JvdHRvbSksIHVzZXNcbiAgICogaGVpZ2h0IGFzIHByaW1hcnkgYW5kIGNhbGN1bGF0ZXMgd2lkdGguIEZvciBjb3JuZXIgaGFuZGxlcywgdXNlcyB3aWR0aFxuICAgKiBhcyB0aGUgcHJpbWFyeSBkaW1lbnNpb24uXG4gICAqXG4gICAqIEBwYXJhbSB3aWR0aCAtIFRoZSBuZXcgd2lkdGhcbiAgICogQHBhcmFtIGhlaWdodCAtIFRoZSBuZXcgaGVpZ2h0XG4gICAqIEBwYXJhbSBkaXJlY3Rpb24gLSBUaGUgYWN0aXZlIHJlc2l6ZSBkaXJlY3Rpb25cbiAgICogQHJldHVybnMgRGltZW5zaW9ucyBhZGp1c3RlZCB0byBwcmVzZXJ2ZSBhc3BlY3QgcmF0aW9cbiAgICovXG4gIGFwcGx5QXNwZWN0UmF0aW8od2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImxlZnRcIiB8fCBkaXJlY3Rpb24gPT09IFwicmlnaHRcIjtcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gZGlyZWN0aW9uID09PSBcInRvcFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJib3R0b21cIjtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB3aWR0aCAvIHRoaXMuYXNwZWN0UmF0aW9cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogaGVpZ2h0ICogdGhpcy5hc3BlY3RSYXRpbyxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IHdpZHRoIC8gdGhpcy5hc3BlY3RSYXRpb1xuICAgIH07XG4gIH1cbn07XG52YXIgUmVzaXphYmxlTm9kZXZpZXcgPSBSZXNpemFibGVOb2RlVmlldztcblxuLy8gc3JjL3V0aWxpdGllcy9jYW5JbnNlcnROb2RlLnRzXG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uIGFzIE5vZGVTZWxlY3Rpb240IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmZ1bmN0aW9uIGNhbkluc2VydE5vZGUoc3RhdGUsIG5vZGVUeXBlKSB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgY29uc3QgeyAkZnJvbSB9ID0gc2VsZWN0aW9uO1xuICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbjQpIHtcbiAgICBjb25zdCBpbmRleCA9ICRmcm9tLmluZGV4KCk7XG4gICAgY29uc3QgcGFyZW50ID0gJGZyb20ucGFyZW50O1xuICAgIHJldHVybiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4ICsgMSwgbm9kZVR5cGUpO1xuICB9XG4gIGxldCBkZXB0aCA9ICRmcm9tLmRlcHRoO1xuICB3aGlsZSAoZGVwdGggPj0gMCkge1xuICAgIGNvbnN0IGluZGV4ID0gJGZyb20uaW5kZXgoZGVwdGgpO1xuICAgIGNvbnN0IHBhcmVudCA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgIGNvbnN0IG1hdGNoID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KGluZGV4KTtcbiAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKG5vZGVUeXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRlcHRoIC09IDE7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2VzY2FwZUZvclJlZ0V4LnRzXG5mdW5jdGlvbiBlc2NhcGVGb3JSZWdFeChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9pc1N0cmluZy50c1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9tYXJrZG93bi9pbmRleC50c1xudmFyIG1hcmtkb3duX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG1hcmtkb3duX2V4cG9ydHMsIHtcbiAgY3JlYXRlQXRvbUJsb2NrTWFya2Rvd25TcGVjOiAoKSA9PiBjcmVhdGVBdG9tQmxvY2tNYXJrZG93blNwZWMsXG4gIGNyZWF0ZUJsb2NrTWFya2Rvd25TcGVjOiAoKSA9PiBjcmVhdGVCbG9ja01hcmtkb3duU3BlYyxcbiAgY3JlYXRlSW5saW5lTWFya2Rvd25TcGVjOiAoKSA9PiBjcmVhdGVJbmxpbmVNYXJrZG93blNwZWMsXG4gIHBhcnNlQXR0cmlidXRlczogKCkgPT4gcGFyc2VBdHRyaWJ1dGVzLFxuICBwYXJzZUluZGVudGVkQmxvY2tzOiAoKSA9PiBwYXJzZUluZGVudGVkQmxvY2tzLFxuICByZW5kZXJOZXN0ZWRNYXJrZG93bkNvbnRlbnQ6ICgpID0+IHJlbmRlck5lc3RlZE1hcmtkb3duQ29udGVudCxcbiAgc2VyaWFsaXplQXR0cmlidXRlczogKCkgPT4gc2VyaWFsaXplQXR0cmlidXRlc1xufSk7XG5cbi8vIHNyYy91dGlsaXRpZXMvbWFya2Rvd24vYXR0cmlidXRlVXRpbHMudHNcbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyhhdHRyU3RyaW5nKSB7XG4gIGlmICghKGF0dHJTdHJpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IGF0dHJTdHJpbmcudHJpbSgpKSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IHF1b3RlZFN0cmluZ3MgPSBbXTtcbiAgY29uc3QgdGVtcFN0cmluZyA9IGF0dHJTdHJpbmcucmVwbGFjZSgvW1wiJ10oW15cIiddKilbXCInXS9nLCAobWF0Y2gpID0+IHtcbiAgICBxdW90ZWRTdHJpbmdzLnB1c2gobWF0Y2gpO1xuICAgIHJldHVybiBgX19RVU9URURfJHtxdW90ZWRTdHJpbmdzLmxlbmd0aCAtIDF9X19gO1xuICB9KTtcbiAgY29uc3QgY2xhc3NNYXRjaGVzID0gdGVtcFN0cmluZy5tYXRjaCgvKD86XnxcXHMpXFwuKFthLXpBLVpdW1xcdy1dKikvZyk7XG4gIGlmIChjbGFzc01hdGNoZXMpIHtcbiAgICBjb25zdCBjbGFzc2VzID0gY2xhc3NNYXRjaGVzLm1hcCgobWF0Y2gpID0+IG1hdGNoLnRyaW0oKS5zbGljZSgxKSk7XG4gICAgYXR0cmlidXRlcy5jbGFzcyA9IGNsYXNzZXMuam9pbihcIiBcIik7XG4gIH1cbiAgY29uc3QgaWRNYXRjaCA9IHRlbXBTdHJpbmcubWF0Y2goLyg/Ol58XFxzKSMoW2EtekEtWl1bXFx3LV0qKS8pO1xuICBpZiAoaWRNYXRjaCkge1xuICAgIGF0dHJpYnV0ZXMuaWQgPSBpZE1hdGNoWzFdO1xuICB9XG4gIGNvbnN0IGt2UmVnZXggPSAvKFthLXpBLVpdW1xcdy1dKilcXHMqPVxccyooX19RVU9URURfXFxkK19fKS9nO1xuICBjb25zdCBrdk1hdGNoZXMgPSBBcnJheS5mcm9tKHRlbXBTdHJpbmcubWF0Y2hBbGwoa3ZSZWdleCkpO1xuICBrdk1hdGNoZXMuZm9yRWFjaCgoWywga2V5LCBxdW90ZWRSZWZdKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHF1b3RlZEluZGV4ID0gcGFyc2VJbnQoKChfYSA9IHF1b3RlZFJlZi5tYXRjaCgvX19RVU9URURfKFxcZCspX18vKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hWzFdKSB8fCBcIjBcIiwgMTApO1xuICAgIGNvbnN0IHF1b3RlZFZhbHVlID0gcXVvdGVkU3RyaW5nc1txdW90ZWRJbmRleF07XG4gICAgaWYgKHF1b3RlZFZhbHVlKSB7XG4gICAgICBhdHRyaWJ1dGVzW2tleV0gPSBxdW90ZWRWYWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgY2xlYW5TdHJpbmcgPSB0ZW1wU3RyaW5nLnJlcGxhY2UoLyg/Ol58XFxzKVxcLihbYS16QS1aXVtcXHctXSopL2csIFwiXCIpLnJlcGxhY2UoLyg/Ol58XFxzKSMoW2EtekEtWl1bXFx3LV0qKS9nLCBcIlwiKS5yZXBsYWNlKC8oW2EtekEtWl1bXFx3LV0qKVxccyo9XFxzKl9fUVVPVEVEX1xcZCtfXy9nLCBcIlwiKS50cmltKCk7XG4gIGlmIChjbGVhblN0cmluZykge1xuICAgIGNvbnN0IGJvb2xlYW5BdHRycyA9IGNsZWFuU3RyaW5nLnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGJvb2xlYW5BdHRycy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICBpZiAoYXR0ci5tYXRjaCgvXlthLXpBLVpdW1xcdy1dKiQvKSkge1xuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYXR0cmlidXRlcztcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICBpZiAoIWF0dHJpYnV0ZXMgfHwgT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgaWYgKGF0dHJpYnV0ZXMuY2xhc3MpIHtcbiAgICBjb25zdCBjbGFzc2VzID0gU3RyaW5nKGF0dHJpYnV0ZXMuY2xhc3MpLnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNsYXNzZXMuZm9yRWFjaCgoY2xzKSA9PiBwYXJ0cy5wdXNoKGAuJHtjbHN9YCkpO1xuICB9XG4gIGlmIChhdHRyaWJ1dGVzLmlkKSB7XG4gICAgcGFydHMucHVzaChgIyR7YXR0cmlidXRlcy5pZH1gKTtcbiAgfVxuICBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoa2V5ID09PSBcImNsYXNzXCIgfHwga2V5ID09PSBcImlkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICBwYXJ0cy5wdXNoKGtleSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gZmFsc2UgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgcGFydHMucHVzaChgJHtrZXl9PVwiJHtTdHJpbmcodmFsdWUpfVwiYCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBhcnRzLmpvaW4oXCIgXCIpO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL21hcmtkb3duL2NyZWF0ZUF0b21CbG9ja01hcmtkb3duU3BlYy50c1xuZnVuY3Rpb24gY3JlYXRlQXRvbUJsb2NrTWFya2Rvd25TcGVjKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIG5vZGVOYW1lLFxuICAgIG5hbWU6IG1hcmtkb3duTmFtZSxcbiAgICBwYXJzZUF0dHJpYnV0ZXM6IHBhcnNlQXR0cmlidXRlczIgPSBwYXJzZUF0dHJpYnV0ZXMsXG4gICAgc2VyaWFsaXplQXR0cmlidXRlczogc2VyaWFsaXplQXR0cmlidXRlczIgPSBzZXJpYWxpemVBdHRyaWJ1dGVzLFxuICAgIGRlZmF1bHRBdHRyaWJ1dGVzID0ge30sXG4gICAgcmVxdWlyZWRBdHRyaWJ1dGVzID0gW10sXG4gICAgYWxsb3dlZEF0dHJpYnV0ZXNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJsb2NrTmFtZSA9IG1hcmtkb3duTmFtZSB8fCBub2RlTmFtZTtcbiAgY29uc3QgZmlsdGVyQXR0cmlidXRlcyA9IChhdHRycykgPT4ge1xuICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybiBhdHRycztcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcbiAgICBhbGxvd2VkQXR0cmlidXRlcy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgZmlsdGVyZWRba2V5XSA9IGF0dHJzW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaDIpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJzID0geyAuLi5kZWZhdWx0QXR0cmlidXRlcywgLi4udG9rZW4uYXR0cmlidXRlcyB9O1xuICAgICAgcmV0dXJuIGgyLmNyZWF0ZU5vZGUobm9kZU5hbWUsIGF0dHJzLCBbXSk7XG4gICAgfSxcbiAgICBtYXJrZG93blRva2VuaXplcjoge1xuICAgICAgbmFtZTogbm9kZU5hbWUsXG4gICAgICBsZXZlbDogXCJibG9ja1wiLFxuICAgICAgc3RhcnQoc3JjKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeOjo6JHtibG9ja05hbWV9KD86XFxcXHN8JClgLCBcIm1cIik7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gKF9hID0gc3JjLm1hdGNoKHJlZ2V4KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluZGV4O1xuICAgICAgICByZXR1cm4gaW5kZXggIT09IHZvaWQgMCA/IGluZGV4IDogLTE7XG4gICAgICB9LFxuICAgICAgdG9rZW5pemUoc3JjLCBfdG9rZW5zLCBfbGV4ZXIpIHtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeOjo6JHtibG9ja05hbWV9KD86XFxcXHMrXFxcXHsoW159XSopXFxcXH0pP1xcXFxzKjo6Oig/OlxcXFxufCQpYCk7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc3JjLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0clN0cmluZyA9IG1hdGNoWzFdIHx8IFwiXCI7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMyKGF0dHJTdHJpbmcpO1xuICAgICAgICBjb25zdCBtaXNzaW5nUmVxdWlyZWQgPSByZXF1aXJlZEF0dHJpYnV0ZXMuZmluZCgocmVxdWlyZWQpID0+ICEocmVxdWlyZWQgaW4gYXR0cmlidXRlcykpO1xuICAgICAgICBpZiAobWlzc2luZ1JlcXVpcmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IG5vZGVOYW1lLFxuICAgICAgICAgIHJhdzogbWF0Y2hbMF0sXG4gICAgICAgICAgYXR0cmlidXRlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyTWFya2Rvd246IChub2RlKSA9PiB7XG4gICAgICBjb25zdCBmaWx0ZXJlZEF0dHJzID0gZmlsdGVyQXR0cmlidXRlcyhub2RlLmF0dHJzIHx8IHt9KTtcbiAgICAgIGNvbnN0IGF0dHJzID0gc2VyaWFsaXplQXR0cmlidXRlczIoZmlsdGVyZWRBdHRycyk7XG4gICAgICBjb25zdCBhdHRyU3RyaW5nID0gYXR0cnMgPyBgIHske2F0dHJzfX1gIDogXCJcIjtcbiAgICAgIHJldHVybiBgOjo6JHtibG9ja05hbWV9JHthdHRyU3RyaW5nfSA6OjpgO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9tYXJrZG93bi9jcmVhdGVCbG9ja01hcmtkb3duU3BlYy50c1xuZnVuY3Rpb24gY3JlYXRlQmxvY2tNYXJrZG93blNwZWMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbm9kZU5hbWUsXG4gICAgbmFtZTogbWFya2Rvd25OYW1lLFxuICAgIGdldENvbnRlbnQsXG4gICAgcGFyc2VBdHRyaWJ1dGVzOiBwYXJzZUF0dHJpYnV0ZXMyID0gcGFyc2VBdHRyaWJ1dGVzLFxuICAgIHNlcmlhbGl6ZUF0dHJpYnV0ZXM6IHNlcmlhbGl6ZUF0dHJpYnV0ZXMyID0gc2VyaWFsaXplQXR0cmlidXRlcyxcbiAgICBkZWZhdWx0QXR0cmlidXRlcyA9IHt9LFxuICAgIGNvbnRlbnQgPSBcImJsb2NrXCIsXG4gICAgYWxsb3dlZEF0dHJpYnV0ZXNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJsb2NrTmFtZSA9IG1hcmtkb3duTmFtZSB8fCBub2RlTmFtZTtcbiAgY29uc3QgZmlsdGVyQXR0cmlidXRlcyA9IChhdHRycykgPT4ge1xuICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybiBhdHRycztcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcbiAgICBhbGxvd2VkQXR0cmlidXRlcy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgZmlsdGVyZWRba2V5XSA9IGF0dHJzW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaDIpID0+IHtcbiAgICAgIGxldCBub2RlQ29udGVudDtcbiAgICAgIGlmIChnZXRDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRSZXN1bHQgPSBnZXRDb250ZW50KHRva2VuKTtcbiAgICAgICAgbm9kZUNvbnRlbnQgPSB0eXBlb2YgY29udGVudFJlc3VsdCA9PT0gXCJzdHJpbmdcIiA/IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjb250ZW50UmVzdWx0IH1dIDogY29udGVudFJlc3VsdDtcbiAgICAgIH0gZWxzZSBpZiAoY29udGVudCA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgIG5vZGVDb250ZW50ID0gaDIucGFyc2VDaGlsZHJlbih0b2tlbi50b2tlbnMgfHwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZUNvbnRlbnQgPSBoMi5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMgfHwgW10pO1xuICAgICAgfVxuICAgICAgY29uc3QgYXR0cnMgPSB7IC4uLmRlZmF1bHRBdHRyaWJ1dGVzLCAuLi50b2tlbi5hdHRyaWJ1dGVzIH07XG4gICAgICByZXR1cm4gaDIuY3JlYXRlTm9kZShub2RlTmFtZSwgYXR0cnMsIG5vZGVDb250ZW50KTtcbiAgICB9LFxuICAgIG1hcmtkb3duVG9rZW5pemVyOiB7XG4gICAgICBuYW1lOiBub2RlTmFtZSxcbiAgICAgIGxldmVsOiBcImJsb2NrXCIsXG4gICAgICBzdGFydChzcmMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF46Ojoke2Jsb2NrTmFtZX1gLCBcIm1cIik7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gKF9hID0gc3JjLm1hdGNoKHJlZ2V4KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluZGV4O1xuICAgICAgICByZXR1cm4gaW5kZXggIT09IHZvaWQgMCA/IGluZGV4IDogLTE7XG4gICAgICB9LFxuICAgICAgdG9rZW5pemUoc3JjLCBfdG9rZW5zLCBsZXhlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9wZW5pbmdSZWdleCA9IG5ldyBSZWdFeHAoYF46Ojoke2Jsb2NrTmFtZX0oPzpcXFxccytcXFxceyhbXn1dKilcXFxcfSk/XFxcXHMqXFxcXG5gKTtcbiAgICAgICAgY29uc3Qgb3BlbmluZ01hdGNoID0gc3JjLm1hdGNoKG9wZW5pbmdSZWdleCk7XG4gICAgICAgIGlmICghb3BlbmluZ01hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb3BlbmluZ1RhZywgYXR0clN0cmluZyA9IFwiXCJdID0gb3BlbmluZ01hdGNoO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzMihhdHRyU3RyaW5nKTtcbiAgICAgICAgbGV0IGxldmVsID0gMTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBvcGVuaW5nVGFnLmxlbmd0aDtcbiAgICAgICAgbGV0IG1hdGNoZWRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgY29uc3QgYmxvY2tQYXR0ZXJuID0gL146OjooW1xcdy1dKikoXFxzLiopPy9nbTtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gc3JjLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgICAgYmxvY2tQYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gYmxvY2tQYXR0ZXJuLmV4ZWMocmVtYWluaW5nKTtcbiAgICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBtYXRjaFBvcyA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgIGNvbnN0IGJsb2NrVHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICAgIGlmICgoX2EgPSBtYXRjaFsyXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmVuZHNXaXRoKFwiOjo6XCIpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJsb2NrVHlwZSkge1xuICAgICAgICAgICAgbGV2ZWwgKz0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV2ZWwgLT0gMTtcbiAgICAgICAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCByYXdDb250ZW50ID0gcmVtYWluaW5nLnNsaWNlKDAsIG1hdGNoUG9zKTtcbiAgICAgICAgICAgICAgbWF0Y2hlZENvbnRlbnQgPSByYXdDb250ZW50LnRyaW0oKTtcbiAgICAgICAgICAgICAgY29uc3QgZnVsbE1hdGNoID0gc3JjLnNsaWNlKDAsIHBvc2l0aW9uICsgbWF0Y2hQb3MgKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICBsZXQgY29udGVudFRva2VucyA9IFtdO1xuICAgICAgICAgICAgICBpZiAobWF0Y2hlZENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudCA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50VG9rZW5zID0gbGV4ZXIuYmxvY2tUb2tlbnMocmF3Q29udGVudCk7XG4gICAgICAgICAgICAgICAgICBjb250ZW50VG9rZW5zLmZvckVhY2goKHRva2VuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi50ZXh0ICYmICghdG9rZW4udG9rZW5zIHx8IHRva2VuLnRva2Vucy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW4udG9rZW5zID0gbGV4ZXIuaW5saW5lVG9rZW5zKHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChjb250ZW50VG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdFRva2VuID0gY29udGVudFRva2Vuc1tjb250ZW50VG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuLnR5cGUgPT09IFwicGFyYWdyYXBoXCIgJiYgKCFsYXN0VG9rZW4udGV4dCB8fCBsYXN0VG9rZW4udGV4dC50cmltKCkgPT09IFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudFRva2Vucy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50VG9rZW5zID0gbGV4ZXIuaW5saW5lVG9rZW5zKG1hdGNoZWRDb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBub2RlTmFtZSxcbiAgICAgICAgICAgICAgICByYXc6IGZ1bGxNYXRjaCxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG1hdGNoZWRDb250ZW50LFxuICAgICAgICAgICAgICAgIHRva2VuczogY29udGVudFRva2Vuc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoMikgPT4ge1xuICAgICAgY29uc3QgZmlsdGVyZWRBdHRycyA9IGZpbHRlckF0dHJpYnV0ZXMobm9kZS5hdHRycyB8fCB7fSk7XG4gICAgICBjb25zdCBhdHRycyA9IHNlcmlhbGl6ZUF0dHJpYnV0ZXMyKGZpbHRlcmVkQXR0cnMpO1xuICAgICAgY29uc3QgYXR0clN0cmluZyA9IGF0dHJzID8gYCB7JHthdHRyc319YCA6IFwiXCI7XG4gICAgICBjb25zdCByZW5kZXJlZENvbnRlbnQgPSBoMi5yZW5kZXJDaGlsZHJlbihub2RlLmNvbnRlbnQgfHwgW10sIFwiXFxuXFxuXCIpO1xuICAgICAgcmV0dXJuIGA6Ojoke2Jsb2NrTmFtZX0ke2F0dHJTdHJpbmd9XG5cbiR7cmVuZGVyZWRDb250ZW50fVxuXG46OjpgO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9tYXJrZG93bi9jcmVhdGVJbmxpbmVNYXJrZG93blNwZWMudHNcbmZ1bmN0aW9uIHBhcnNlU2hvcnRjb2RlQXR0cmlidXRlcyhhdHRyU3RyaW5nKSB7XG4gIGlmICghYXR0clN0cmluZy50cmltKCkpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCByZWdleCA9IC8oXFx3Kyk9KD86XCIoW15cIl0qKVwifCcoW14nXSopJykvZztcbiAgbGV0IG1hdGNoID0gcmVnZXguZXhlYyhhdHRyU3RyaW5nKTtcbiAgd2hpbGUgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgY29uc3QgWywga2V5LCBkb3VibGVRdW90ZWQsIHNpbmdsZVF1b3RlZF0gPSBtYXRjaDtcbiAgICBhdHRyaWJ1dGVzW2tleV0gPSBkb3VibGVRdW90ZWQgfHwgc2luZ2xlUXVvdGVkO1xuICAgIG1hdGNoID0gcmVnZXguZXhlYyhhdHRyU3RyaW5nKTtcbiAgfVxuICByZXR1cm4gYXR0cmlidXRlcztcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVNob3J0Y29kZUF0dHJpYnV0ZXMoYXR0cnMpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGF0dHJzKS5maWx0ZXIoKFssIHZhbHVlXSkgPT4gdmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbCkubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke2tleX09XCIke3ZhbHVlfVwiYCkuam9pbihcIiBcIik7XG59XG5mdW5jdGlvbiBjcmVhdGVJbmxpbmVNYXJrZG93blNwZWMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbm9kZU5hbWUsXG4gICAgbmFtZTogc2hvcnRjb2RlTmFtZSxcbiAgICBnZXRDb250ZW50LFxuICAgIHBhcnNlQXR0cmlidXRlczogcGFyc2VBdHRyaWJ1dGVzMiA9IHBhcnNlU2hvcnRjb2RlQXR0cmlidXRlcyxcbiAgICBzZXJpYWxpemVBdHRyaWJ1dGVzOiBzZXJpYWxpemVBdHRyaWJ1dGVzMiA9IHNlcmlhbGl6ZVNob3J0Y29kZUF0dHJpYnV0ZXMsXG4gICAgZGVmYXVsdEF0dHJpYnV0ZXMgPSB7fSxcbiAgICBzZWxmQ2xvc2luZyA9IGZhbHNlLFxuICAgIGFsbG93ZWRBdHRyaWJ1dGVzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBzaG9ydGNvZGUgPSBzaG9ydGNvZGVOYW1lIHx8IG5vZGVOYW1lO1xuICBjb25zdCBmaWx0ZXJBdHRyaWJ1dGVzID0gKGF0dHJzKSA9PiB7XG4gICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJlZCA9IHt9O1xuICAgIGFsbG93ZWRBdHRyaWJ1dGVzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBhdHRycykge1xuICAgICAgICBmaWx0ZXJlZFtrZXldID0gYXR0cnNba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmlsdGVyZWQ7XG4gIH07XG4gIGNvbnN0IGVzY2FwZWRTaG9ydGNvZGUgPSBzaG9ydGNvZGUucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xuICByZXR1cm4ge1xuICAgIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaDIpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJzID0geyAuLi5kZWZhdWx0QXR0cmlidXRlcywgLi4udG9rZW4uYXR0cmlidXRlcyB9O1xuICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XG4gICAgICAgIHJldHVybiBoMi5jcmVhdGVOb2RlKG5vZGVOYW1lLCBhdHRycyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb250ZW50ID0gZ2V0Q29udGVudCA/IGdldENvbnRlbnQodG9rZW4pIDogdG9rZW4uY29udGVudCB8fCBcIlwiO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGgyLmNyZWF0ZU5vZGUobm9kZU5hbWUsIGF0dHJzLCBbaDIuY3JlYXRlVGV4dE5vZGUoY29udGVudCldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoMi5jcmVhdGVOb2RlKG5vZGVOYW1lLCBhdHRycywgW10pO1xuICAgIH0sXG4gICAgbWFya2Rvd25Ub2tlbml6ZXI6IHtcbiAgICAgIG5hbWU6IG5vZGVOYW1lLFxuICAgICAgbGV2ZWw6IFwiaW5saW5lXCIsXG4gICAgICBzdGFydChzcmMpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQYXR0ZXJuID0gc2VsZkNsb3NpbmcgPyBuZXcgUmVnRXhwKGBcXFxcWyR7ZXNjYXBlZFNob3J0Y29kZX1cXFxccypbXlxcXFxdXSpcXFxcXWApIDogbmV3IFJlZ0V4cChgXFxcXFske2VzY2FwZWRTaG9ydGNvZGV9XFxcXHMqW15cXFxcXV0qXFxcXF1bXFxcXHNcXFxcU10qP1xcXFxbXFxcXC8ke2VzY2FwZWRTaG9ydGNvZGV9XFxcXF1gKTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBzcmMubWF0Y2goc3RhcnRQYXR0ZXJuKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBtYXRjaCA9PSBudWxsID8gdm9pZCAwIDogbWF0Y2guaW5kZXg7XG4gICAgICAgIHJldHVybiBpbmRleCAhPT0gdm9pZCAwID8gaW5kZXggOiAtMTtcbiAgICAgIH0sXG4gICAgICB0b2tlbml6ZShzcmMsIF90b2tlbnMsIF9sZXhlcikge1xuICAgICAgICBjb25zdCB0b2tlblBhdHRlcm4gPSBzZWxmQ2xvc2luZyA/IG5ldyBSZWdFeHAoYF5cXFxcWyR7ZXNjYXBlZFNob3J0Y29kZX1cXFxccyooW15cXFxcXV0qKVxcXFxdYCkgOiBuZXcgUmVnRXhwKGBeXFxcXFske2VzY2FwZWRTaG9ydGNvZGV9XFxcXHMqKFteXFxcXF1dKilcXFxcXShbXFxcXHNcXFxcU10qPylcXFxcW1xcXFwvJHtlc2NhcGVkU2hvcnRjb2RlfVxcXFxdYCk7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc3JjLm1hdGNoKHRva2VuUGF0dGVybik7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50ID0gXCJcIjtcbiAgICAgICAgbGV0IGF0dHJTdHJpbmcgPSBcIlwiO1xuICAgICAgICBpZiAoc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICBjb25zdCBbLCBhdHRyc10gPSBtYXRjaDtcbiAgICAgICAgICBhdHRyU3RyaW5nID0gYXR0cnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgWywgYXR0cnMsIGNvbnRlbnRNYXRjaF0gPSBtYXRjaDtcbiAgICAgICAgICBhdHRyU3RyaW5nID0gYXR0cnM7XG4gICAgICAgICAgY29udGVudCA9IGNvbnRlbnRNYXRjaCB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMyKGF0dHJTdHJpbmcudHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBub2RlTmFtZSxcbiAgICAgICAgICByYXc6IG1hdGNoWzBdLFxuICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQudHJpbSgpLFxuICAgICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlck1hcmtkb3duOiAobm9kZSkgPT4ge1xuICAgICAgbGV0IGNvbnRlbnQgPSBcIlwiO1xuICAgICAgaWYgKGdldENvbnRlbnQpIHtcbiAgICAgICAgY29udGVudCA9IGdldENvbnRlbnQobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY29udGVudCAmJiBub2RlLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb250ZW50ID0gbm9kZS5jb250ZW50LmZpbHRlcigoY2hpbGQpID0+IGNoaWxkLnR5cGUgPT09IFwidGV4dFwiKS5tYXAoKGNoaWxkKSA9PiBjaGlsZC50ZXh0KS5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlsdGVyZWRBdHRycyA9IGZpbHRlckF0dHJpYnV0ZXMobm9kZS5hdHRycyB8fCB7fSk7XG4gICAgICBjb25zdCBhdHRycyA9IHNlcmlhbGl6ZUF0dHJpYnV0ZXMyKGZpbHRlcmVkQXR0cnMpO1xuICAgICAgY29uc3QgYXR0clN0cmluZyA9IGF0dHJzID8gYCAke2F0dHJzfWAgOiBcIlwiO1xuICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XG4gICAgICAgIHJldHVybiBgWyR7c2hvcnRjb2RlfSR7YXR0clN0cmluZ31dYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgWyR7c2hvcnRjb2RlfSR7YXR0clN0cmluZ31dJHtjb250ZW50fVsvJHtzaG9ydGNvZGV9XWA7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL21hcmtkb3duL3BhcnNlSW5kZW50ZWRCbG9ja3MudHNcbmZ1bmN0aW9uIHBhcnNlSW5kZW50ZWRCbG9ja3Moc3JjLCBjb25maWcsIGxleGVyKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgbGluZXMgPSBzcmMuc3BsaXQoXCJcXG5cIik7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGxldCB0b3RhbFJhdyA9IFwiXCI7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgYmFzZUluZGVudFNpemUgPSBjb25maWcuYmFzZUluZGVudFNpemUgfHwgMjtcbiAgd2hpbGUgKGkgPCBsaW5lcy5sZW5ndGgpIHtcbiAgICBjb25zdCBjdXJyZW50TGluZSA9IGxpbmVzW2ldO1xuICAgIGNvbnN0IGl0ZW1NYXRjaCA9IGN1cnJlbnRMaW5lLm1hdGNoKGNvbmZpZy5pdGVtUGF0dGVybik7XG4gICAgaWYgKCFpdGVtTWF0Y2gpIHtcbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50TGluZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICB0b3RhbFJhdyA9IGAke3RvdGFsUmF3fSR7Y3VycmVudExpbmV9XG5gO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1EYXRhID0gY29uZmlnLmV4dHJhY3RJdGVtRGF0YShpdGVtTWF0Y2gpO1xuICAgIGNvbnN0IHsgaW5kZW50TGV2ZWwsIG1haW5Db250ZW50IH0gPSBpdGVtRGF0YTtcbiAgICB0b3RhbFJhdyA9IGAke3RvdGFsUmF3fSR7Y3VycmVudExpbmV9XG5gO1xuICAgIGNvbnN0IGl0ZW1Db250ZW50ID0gW21haW5Db250ZW50XTtcbiAgICBpICs9IDE7XG4gICAgd2hpbGUgKGkgPCBsaW5lcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5leHRMaW5lID0gbGluZXNbaV07XG4gICAgICBpZiAobmV4dExpbmUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IG5leHROb25FbXB0eUluZGV4ID0gbGluZXMuc2xpY2UoaSArIDEpLmZpbmRJbmRleCgobCkgPT4gbC50cmltKCkgIT09IFwiXCIpO1xuICAgICAgICBpZiAobmV4dE5vbkVtcHR5SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dE5vbkVtcHR5ID0gbGluZXNbaSArIDEgKyBuZXh0Tm9uRW1wdHlJbmRleF07XG4gICAgICAgIGNvbnN0IG5leHRJbmRlbnQyID0gKChfYiA9IChfYSA9IG5leHROb25FbXB0eS5tYXRjaCgvXihcXHMqKS8pKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5sZW5ndGgpIHx8IDA7XG4gICAgICAgIGlmIChuZXh0SW5kZW50MiA+IGluZGVudExldmVsKSB7XG4gICAgICAgICAgaXRlbUNvbnRlbnQucHVzaChuZXh0TGluZSk7XG4gICAgICAgICAgdG90YWxSYXcgPSBgJHt0b3RhbFJhd30ke25leHRMaW5lfVxuYDtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRJbmRlbnQgPSAoKF9kID0gKF9jID0gbmV4dExpbmUubWF0Y2goL14oXFxzKikvKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jWzFdKSA9PSBudWxsID8gdm9pZCAwIDogX2QubGVuZ3RoKSB8fCAwO1xuICAgICAgaWYgKG5leHRJbmRlbnQgPiBpbmRlbnRMZXZlbCkge1xuICAgICAgICBpdGVtQ29udGVudC5wdXNoKG5leHRMaW5lKTtcbiAgICAgICAgdG90YWxSYXcgPSBgJHt0b3RhbFJhd30ke25leHRMaW5lfVxuYDtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBuZXN0ZWRUb2tlbnM7XG4gICAgY29uc3QgbmVzdGVkQ29udGVudCA9IGl0ZW1Db250ZW50LnNsaWNlKDEpO1xuICAgIGlmIChuZXN0ZWRDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGRlZGVudGVkTmVzdGVkID0gbmVzdGVkQ29udGVudC5tYXAoKG5lc3RlZExpbmUpID0+IG5lc3RlZExpbmUuc2xpY2UoaW5kZW50TGV2ZWwgKyBiYXNlSW5kZW50U2l6ZSkpLmpvaW4oXCJcXG5cIik7XG4gICAgICBpZiAoZGVkZW50ZWROZXN0ZWQudHJpbSgpKSB7XG4gICAgICAgIGlmIChjb25maWcuY3VzdG9tTmVzdGVkUGFyc2VyKSB7XG4gICAgICAgICAgbmVzdGVkVG9rZW5zID0gY29uZmlnLmN1c3RvbU5lc3RlZFBhcnNlcihkZWRlbnRlZE5lc3RlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmVzdGVkVG9rZW5zID0gbGV4ZXIuYmxvY2tUb2tlbnMoZGVkZW50ZWROZXN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRva2VuID0gY29uZmlnLmNyZWF0ZVRva2VuKGl0ZW1EYXRhLCBuZXN0ZWRUb2tlbnMpO1xuICAgIGl0ZW1zLnB1c2godG9rZW4pO1xuICB9XG4gIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXRlbXMsXG4gICAgcmF3OiB0b3RhbFJhd1xuICB9O1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL21hcmtkb3duL3JlbmRlck5lc3RlZE1hcmtkb3duQ29udGVudC50c1xuZnVuY3Rpb24gcmVuZGVyTmVzdGVkTWFya2Rvd25Db250ZW50KG5vZGUsIGgyLCBwcmVmaXhPckdlbmVyYXRvciwgY3R4KSB7XG4gIGlmICghbm9kZSB8fCAhQXJyYXkuaXNBcnJheShub2RlLmNvbnRlbnQpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gdHlwZW9mIHByZWZpeE9yR2VuZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBwcmVmaXhPckdlbmVyYXRvcihjdHgpIDogcHJlZml4T3JHZW5lcmF0b3I7XG4gIGNvbnN0IFtjb250ZW50LCAuLi5jaGlsZHJlbl0gPSBub2RlLmNvbnRlbnQ7XG4gIGNvbnN0IG1haW5Db250ZW50ID0gaDIucmVuZGVyQ2hpbGRyZW4oW2NvbnRlbnRdKTtcbiAgY29uc3Qgb3V0cHV0ID0gW2Ake3ByZWZpeH0ke21haW5Db250ZW50fWBdO1xuICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjb25zdCBjaGlsZENvbnRlbnQgPSBoMi5yZW5kZXJDaGlsZHJlbihbY2hpbGRdKTtcbiAgICAgIGlmIChjaGlsZENvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgaW5kZW50ZWRDaGlsZCA9IGNoaWxkQ29udGVudC5zcGxpdChcIlxcblwiKS5tYXAoKGxpbmUpID0+IGxpbmUgPyBoMi5pbmRlbnQobGluZSkgOiBcIlwiKS5qb2luKFwiXFxuXCIpO1xuICAgICAgICBvdXRwdXQucHVzaChpbmRlbnRlZENoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcXG5cIik7XG59XG5cbi8vIHNyYy9NYXJrVmlldy50c1xuZnVuY3Rpb24gdXBkYXRlTWFya1ZpZXdBdHRyaWJ1dGVzKGNoZWNrTWFyaywgZWRpdG9yLCBhdHRycyA9IHt9KSB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcbiAgY29uc3QgeyBkb2MsIHRyIH0gPSBzdGF0ZTtcbiAgY29uc3QgdGhpc01hcmsgPSBjaGVja01hcms7XG4gIGRvYy5kZXNjZW5kYW50cygobm9kZSwgcG9zKSA9PiB7XG4gICAgY29uc3QgZnJvbSA9IHRyLm1hcHBpbmcubWFwKHBvcyk7XG4gICAgY29uc3QgdG8gPSB0ci5tYXBwaW5nLm1hcChwb3MpICsgbm9kZS5ub2RlU2l6ZTtcbiAgICBsZXQgZm91bmRNYXJrID0gbnVsbDtcbiAgICBub2RlLm1hcmtzLmZvckVhY2goKG1hcmspID0+IHtcbiAgICAgIGlmIChtYXJrICE9PSB0aGlzTWFyaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3VuZE1hcmsgPSBtYXJrO1xuICAgIH0pO1xuICAgIGlmICghZm91bmRNYXJrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICBpZiAoYXR0cnNba10gIT09IGZvdW5kTWFyay5hdHRyc1trXSkge1xuICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG5lZWRzVXBkYXRlKSB7XG4gICAgICBjb25zdCB1cGRhdGVkTWFyayA9IGNoZWNrTWFyay50eXBlLmNyZWF0ZSh7XG4gICAgICAgIC4uLmNoZWNrTWFyay5hdHRycyxcbiAgICAgICAgLi4uYXR0cnNcbiAgICAgIH0pO1xuICAgICAgdHIucmVtb3ZlTWFyayhmcm9tLCB0bywgY2hlY2tNYXJrLnR5cGUpO1xuICAgICAgdHIuYWRkTWFyayhmcm9tLCB0bywgdXBkYXRlZE1hcmspO1xuICAgIH1cbiAgfSk7XG4gIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xuICB9XG59XG52YXIgTWFya1ZpZXcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvcjtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICB0aGlzLm1hcmsgPSBwcm9wcy5tYXJrO1xuICAgIHRoaXMuSFRNTEF0dHJpYnV0ZXMgPSBwcm9wcy5IVE1MQXR0cmlidXRlcztcbiAgfVxuICBnZXQgZG9tKCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRvci52aWV3LmRvbTtcbiAgfVxuICBnZXQgY29udGVudERPTSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBtYXJrIGluIHRoZSBkb2N1bWVudC5cbiAgICogQHBhcmFtIGF0dHJzIFRoZSBhdHRyaWJ1dGVzIHRvIHVwZGF0ZS5cbiAgICovXG4gIHVwZGF0ZUF0dHJpYnV0ZXMoYXR0cnMsIGNoZWNrTWFyaykge1xuICAgIHVwZGF0ZU1hcmtWaWV3QXR0cmlidXRlcyhjaGVja01hcmsgfHwgdGhpcy5tYXJrLCB0aGlzLmVkaXRvciwgYXR0cnMpO1xuICB9XG4gIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaWdub3JlTXV0YXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbih7IG11dGF0aW9uIH0pO1xuICAgIH1cbiAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gXCJzZWxlY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5kb20uY29udGFpbnMobXV0YXRpb24udGFyZ2V0KSAmJiBtdXRhdGlvbi50eXBlID09PSBcImNoaWxkTGlzdFwiICYmIChpc2lPUygpIHx8IGlzQW5kcm9pZCgpKSAmJiB0aGlzLmVkaXRvci5pc0ZvY3VzZWQpIHtcbiAgICAgIGNvbnN0IGNoYW5nZWROb2RlcyA9IFsuLi5BcnJheS5mcm9tKG11dGF0aW9uLmFkZGVkTm9kZXMpLCAuLi5BcnJheS5mcm9tKG11dGF0aW9uLnJlbW92ZWROb2RlcyldO1xuICAgICAgaWYgKGNoYW5nZWROb2Rlcy5ldmVyeSgobm9kZSkgPT4gbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5jb250ZW50RE9NID09PSBtdXRhdGlvbi50YXJnZXQgJiYgbXV0YXRpb24udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9Ob2RlLnRzXG52YXIgTm9kZTMgPSBjbGFzcyBfTm9kZSBleHRlbmRzIEV4dGVuZGFibGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IFwibm9kZVwiO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTm9kZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0gY29uZmlnIC0gTm9kZSBjb25maWd1cmF0aW9uIG9iamVjdCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRDb25maWcgPSB0eXBlb2YgY29uZmlnID09PSBcImZ1bmN0aW9uXCIgPyBjb25maWcoKSA6IGNvbmZpZztcbiAgICByZXR1cm4gbmV3IF9Ob2RlKHJlc29sdmVkQ29uZmlnKTtcbiAgfVxuICBjb25maWd1cmUob3B0aW9ucykge1xuICAgIHJldHVybiBzdXBlci5jb25maWd1cmUob3B0aW9ucyk7XG4gIH1cbiAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRDb25maWcgPSB0eXBlb2YgZXh0ZW5kZWRDb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IGV4dGVuZGVkQ29uZmlnKCkgOiBleHRlbmRlZENvbmZpZztcbiAgICByZXR1cm4gc3VwZXIuZXh0ZW5kKHJlc29sdmVkQ29uZmlnKTtcbiAgfVxufTtcblxuLy8gc3JjL05vZGVWaWV3LnRzXG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uIGFzIE5vZGVTZWxlY3Rpb241IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBOb2RlVmlldyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucykge1xuICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHN0b3BFdmVudDogbnVsbCxcbiAgICAgIGlnbm9yZU11dGF0aW9uOiBudWxsLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgdGhpcy5leHRlbnNpb24gPSBwcm9wcy5leHRlbnNpb247XG4gICAgdGhpcy5ub2RlID0gcHJvcHMubm9kZTtcbiAgICB0aGlzLmRlY29yYXRpb25zID0gcHJvcHMuZGVjb3JhdGlvbnM7XG4gICAgdGhpcy5pbm5lckRlY29yYXRpb25zID0gcHJvcHMuaW5uZXJEZWNvcmF0aW9ucztcbiAgICB0aGlzLnZpZXcgPSBwcm9wcy52aWV3O1xuICAgIHRoaXMuSFRNTEF0dHJpYnV0ZXMgPSBwcm9wcy5IVE1MQXR0cmlidXRlcztcbiAgICB0aGlzLmdldFBvcyA9IHByb3BzLmdldFBvcztcbiAgICB0aGlzLm1vdW50KCk7XG4gIH1cbiAgbW91bnQoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGdldCBkb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tO1xuICB9XG4gIGdldCBjb250ZW50RE9NKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG9uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgIGNvbnN0IHsgdmlldyB9ID0gdGhpcy5lZGl0b3I7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGNvbnN0IGRyYWdIYW5kbGUgPSB0YXJnZXQubm9kZVR5cGUgPT09IDMgPyAoX2EgPSB0YXJnZXQucGFyZW50RWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNsb3Nlc3QoXCJbZGF0YS1kcmFnLWhhbmRsZV1cIikgOiB0YXJnZXQuY2xvc2VzdChcIltkYXRhLWRyYWctaGFuZGxlXVwiKTtcbiAgICBpZiAoIXRoaXMuZG9tIHx8ICgoX2IgPSB0aGlzLmNvbnRlbnRET00pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb250YWlucyh0YXJnZXQpKSB8fCAhZHJhZ0hhbmRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGlmICh0aGlzLmRvbSAhPT0gZHJhZ0hhbmRsZSkge1xuICAgICAgY29uc3QgZG9tQm94ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBoYW5kbGVCb3ggPSBkcmFnSGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3Qgb2Zmc2V0WCA9IChfZCA9IGV2ZW50Lm9mZnNldFgpICE9IG51bGwgPyBfZCA6IChfYyA9IGV2ZW50Lm5hdGl2ZUV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Mub2Zmc2V0WDtcbiAgICAgIGNvbnN0IG9mZnNldFkgPSAoX2YgPSBldmVudC5vZmZzZXRZKSAhPSBudWxsID8gX2YgOiAoX2UgPSBldmVudC5uYXRpdmVFdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm9mZnNldFk7XG4gICAgICB4ID0gaGFuZGxlQm94LnggLSBkb21Cb3gueCArIG9mZnNldFg7XG4gICAgICB5ID0gaGFuZGxlQm94LnkgLSBkb21Cb3gueSArIG9mZnNldFk7XG4gICAgfVxuICAgIGNvbnN0IGNsb25lZE5vZGUgPSB0aGlzLmRvbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRvbUJveCA9IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY2xvbmVkTm9kZS5zdHlsZS53aWR0aCA9IGAke01hdGgucm91bmQoZG9tQm94LndpZHRoKX1weGA7XG4gICAgICBjbG9uZWROb2RlLnN0eWxlLmhlaWdodCA9IGAke01hdGgucm91bmQoZG9tQm94LmhlaWdodCl9cHhgO1xuICAgICAgY2xvbmVkTm9kZS5zdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIjtcbiAgICAgIGNsb25lZE5vZGUuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICBsZXQgZHJhZ0ltYWdlV3JhcHBlciA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGRyYWdJbWFnZVdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZHJhZ0ltYWdlV3JhcHBlci5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIGRyYWdJbWFnZVdyYXBwZXIuc3R5bGUudG9wID0gXCItOTk5OXB4XCI7XG4gICAgICBkcmFnSW1hZ2VXcmFwcGVyLnN0eWxlLmxlZnQgPSBcIi05OTk5cHhcIjtcbiAgICAgIGRyYWdJbWFnZVdyYXBwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgZHJhZ0ltYWdlV3JhcHBlci5hcHBlbmRDaGlsZChjbG9uZWROb2RlKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZHJhZ0ltYWdlV3JhcHBlcik7XG4gICAgICAoX2cgPSBldmVudC5kYXRhVHJhbnNmZXIpID09IG51bGwgPyB2b2lkIDAgOiBfZy5zZXREcmFnSW1hZ2UoY2xvbmVkTm9kZSwgeCwgeSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChkcmFnSW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkcmFnSW1hZ2VXcmFwcGVyID09IG51bGwgPyB2b2lkIDAgOiBkcmFnSW1hZ2VXcmFwcGVyLnJlbW92ZSgpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgaWYgKHR5cGVvZiBwb3MgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbjUuY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBwb3MpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcbiAgfVxuICBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zdG9wRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdG9wRXZlbnQoeyBldmVudCB9KTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGNvbnN0IGlzSW5FbGVtZW50ID0gdGhpcy5kb20uY29udGFpbnModGFyZ2V0KSAmJiAhKChfYSA9IHRoaXMuY29udGVudERPTSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKHRhcmdldCkpO1xuICAgIGlmICghaXNJbkVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaXNEcmFnRXZlbnQgPSBldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJkcmFnXCIpO1xuICAgIGNvbnN0IGlzRHJvcEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gXCJkcm9wXCI7XG4gICAgY29uc3QgaXNJbnB1dCA9IFtcIklOUFVUXCIsIFwiQlVUVE9OXCIsIFwiU0VMRUNUXCIsIFwiVEVYVEFSRUFcIl0uaW5jbHVkZXModGFyZ2V0LnRhZ05hbWUpIHx8IHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgICBpZiAoaXNJbnB1dCAmJiAhaXNEcm9wRXZlbnQgJiYgIWlzRHJhZ0V2ZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgeyBpc0VkaXRhYmxlIH0gPSB0aGlzLmVkaXRvcjtcbiAgICBjb25zdCB7IGlzRHJhZ2dpbmcgfSA9IHRoaXM7XG4gICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlO1xuICAgIGNvbnN0IGlzU2VsZWN0YWJsZSA9IE5vZGVTZWxlY3Rpb241LmlzU2VsZWN0YWJsZSh0aGlzLm5vZGUpO1xuICAgIGNvbnN0IGlzQ29weUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gXCJjb3B5XCI7XG4gICAgY29uc3QgaXNQYXN0ZUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gXCJwYXN0ZVwiO1xuICAgIGNvbnN0IGlzQ3V0RXZlbnQgPSBldmVudC50eXBlID09PSBcImN1dFwiO1xuICAgIGNvbnN0IGlzQ2xpY2tFdmVudCA9IGV2ZW50LnR5cGUgPT09IFwibW91c2Vkb3duXCI7XG4gICAgaWYgKCFpc0RyYWdnYWJsZSAmJiBpc1NlbGVjdGFibGUgJiYgaXNEcmFnRXZlbnQgJiYgZXZlbnQudGFyZ2V0ID09PSB0aGlzLmRvbSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgaWYgKGlzRHJhZ2dhYmxlICYmIGlzRHJhZ0V2ZW50ICYmICFpc0RyYWdnaW5nICYmIGV2ZW50LnRhcmdldCA9PT0gdGhpcy5kb20pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc0RyYWdnYWJsZSAmJiBpc0VkaXRhYmxlICYmICFpc0RyYWdnaW5nICYmIGlzQ2xpY2tFdmVudCkge1xuICAgICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRhcmdldC5jbG9zZXN0KFwiW2RhdGEtZHJhZy1oYW5kbGVdXCIpO1xuICAgICAgY29uc3QgaXNWYWxpZERyYWdIYW5kbGUgPSBkcmFnSGFuZGxlICYmICh0aGlzLmRvbSA9PT0gZHJhZ0hhbmRsZSB8fCB0aGlzLmRvbS5jb250YWlucyhkcmFnSGFuZGxlKSk7XG4gICAgICBpZiAoaXNWYWxpZERyYWdIYW5kbGUpIHtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBcImRyYWdlbmRcIixcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgXCJkcm9wXCIsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIFwibW91c2V1cFwiLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRHJhZ2dpbmcgfHwgaXNEcm9wRXZlbnQgfHwgaXNDb3B5RXZlbnQgfHwgaXNQYXN0ZUV2ZW50IHx8IGlzQ3V0RXZlbnQgfHwgaXNDbGlja0V2ZW50ICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBET00gW211dGF0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTXV0YXRpb25PYnNlcnZlcikgb3IgYSBzZWxlY3Rpb24gY2hhbmdlIGhhcHBlbnMgd2l0aGluIHRoZSB2aWV3LlxuICAgKiBAcmV0dXJuIGBmYWxzZWAgaWYgdGhlIGVkaXRvciBzaG91bGQgcmUtcmVhZCB0aGUgc2VsZWN0aW9uIG9yIHJlLXBhcnNlIHRoZSByYW5nZSBhcm91bmQgdGhlIG11dGF0aW9uXG4gICAqIEByZXR1cm4gYHRydWVgIGlmIGl0IGNhbiBzYWZlbHkgYmUgaWdub3JlZC5cbiAgICovXG4gIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaWdub3JlTXV0YXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbih7IG11dGF0aW9uIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5ub2RlLmlzTGVhZiB8fCB0aGlzLm5vZGUuaXNBdG9tKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLnR5cGUgPT09IFwic2VsZWN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkgJiYgbXV0YXRpb24udHlwZSA9PT0gXCJjaGlsZExpc3RcIiAmJiAoaXNpT1MoKSB8fCBpc0FuZHJvaWQoKSkgJiYgdGhpcy5lZGl0b3IuaXNGb2N1c2VkKSB7XG4gICAgICBjb25zdCBjaGFuZ2VkTm9kZXMgPSBbLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5hZGRlZE5vZGVzKSwgLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5yZW1vdmVkTm9kZXMpXTtcbiAgICAgIGlmIChjaGFuZ2VkTm9kZXMuZXZlcnkoKG5vZGUpID0+IG5vZGUuaXNDb250ZW50RWRpdGFibGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuY29udGVudERPTSA9PT0gbXV0YXRpb24udGFyZ2V0ICYmIG11dGF0aW9uLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29udGVudERPTS5jb250YWlucyhtdXRhdGlvbi50YXJnZXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHByb3NlbWlycm9yIG5vZGUuXG4gICAqL1xuICB1cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgICBpZiAodHlwZW9mIHBvcyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdm9pZCAwLCB7XG4gICAgICAgIC4uLnRoaXMubm9kZS5hdHRycyxcbiAgICAgICAgLi4uYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIHRoZSBub2RlLlxuICAgKi9cbiAgZGVsZXRlTm9kZSgpIHtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5nZXRQb3MoKTtcbiAgICBpZiAodHlwZW9mIGZyb20gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5ub2RlLm5vZGVTaXplO1xuICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmRlbGV0ZVJhbmdlKHsgZnJvbSwgdG8gfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXN0ZVJ1bGVzL21hcmtQYXN0ZVJ1bGUudHNcbmZ1bmN0aW9uIG1hcmtQYXN0ZVJ1bGUoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoLCBwYXN0ZUV2ZW50IH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHZvaWQgMCwgbWF0Y2gsIHBhc3RlRXZlbnQpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGNhcHR1cmVHcm91cCA9IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMF07XG4gICAgICBsZXQgbWFya0VuZCA9IHJhbmdlLnRvO1xuICAgICAgaWYgKGNhcHR1cmVHcm91cCkge1xuICAgICAgICBjb25zdCBzdGFydFNwYWNlcyA9IGZ1bGxNYXRjaC5zZWFyY2goL1xcUy8pO1xuICAgICAgICBjb25zdCB0ZXh0U3RhcnQgPSByYW5nZS5mcm9tICsgZnVsbE1hdGNoLmluZGV4T2YoY2FwdHVyZUdyb3VwKTtcbiAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVkTWFya3MgPSBnZXRNYXJrc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHN0YXRlLmRvYykuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBpdGVtLm1hcmsudHlwZS5leGNsdWRlZDtcbiAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCgodHlwZSkgPT4gdHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgdHlwZSAhPT0gaXRlbS5tYXJrLnR5cGUpO1xuICAgICAgICB9KS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udG8gPiB0ZXh0U3RhcnQpO1xuICAgICAgICBpZiAoZXhjbHVkZWRNYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dEVuZCA8IHJhbmdlLnRvKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHRleHRFbmQsIHJhbmdlLnRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xuICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgbWFya0VuZCA9IHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcyArIGNhcHR1cmVHcm91cC5sZW5ndGg7XG4gICAgICAgIHRyLmFkZE1hcmsocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCBtYXJrRW5kLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyB8fCB7fSkpO1xuICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKGNvbmZpZy50eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvcGFzdGVSdWxlcy9ub2RlUGFzdGVSdWxlLnRzXG5mdW5jdGlvbiBub2RlUGFzdGVSdWxlKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcih7IG1hdGNoLCBjaGFpbiwgcmFuZ2UsIHBhc3RlRXZlbnQgfSkge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdm9pZCAwLCBtYXRjaCwgcGFzdGVFdmVudCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRDb250ZW50LCB2b2lkIDAsIGF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0geyB0eXBlOiBjb25maWcudHlwZS5uYW1lLCBhdHRyczogYXR0cmlidXRlcyB9O1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgbm9kZS5jb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5pbnB1dCkge1xuICAgICAgICBjaGFpbigpLmRlbGV0ZVJhbmdlKHJhbmdlKS5pbnNlcnRDb250ZW50QXQocmFuZ2UuZnJvbSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3Bhc3RlUnVsZXMvdGV4dFBhc3RlUnVsZS50c1xuZnVuY3Rpb24gdGV4dFBhc3RlUnVsZShjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgbGV0IGluc2VydCA9IGNvbmZpZy5yZXBsYWNlO1xuICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbTtcbiAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvO1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcbiAgICAgICAgaW5zZXJ0ICs9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCArIG1hdGNoWzFdLmxlbmd0aCk7XG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICAgICAgY29uc3QgY3V0T2ZmID0gc3RhcnQgLSBlbmQ7XG4gICAgICAgIGlmIChjdXRPZmYgPiAwKSB7XG4gICAgICAgICAgaW5zZXJ0ID0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0IC0gY3V0T2ZmLCBvZmZzZXQpICsgaW5zZXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS50ci5pbnNlcnRUZXh0KGluc2VydCwgc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL1RyYWNrZXIudHNcbnZhciBUcmFja2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0cmFuc2FjdGlvbikge1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwcy5sZW5ndGg7XG4gIH1cbiAgbWFwKHBvc2l0aW9uKSB7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBtYXBwZWRQb3NpdGlvbiA9IHRoaXMudHJhbnNhY3Rpb24uc3RlcHMuc2xpY2UodGhpcy5jdXJyZW50U3RlcCkucmVkdWNlKChuZXdQb3NpdGlvbiwgc3RlcCkgPT4ge1xuICAgICAgY29uc3QgbWFwUmVzdWx0ID0gc3RlcC5nZXRNYXAoKS5tYXBSZXN1bHQobmV3UG9zaXRpb24pO1xuICAgICAgaWYgKG1hcFJlc3VsdC5kZWxldGVkKSB7XG4gICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcFJlc3VsdC5wb3M7XG4gICAgfSwgcG9zaXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogbWFwcGVkUG9zaXRpb24sXG4gICAgICBkZWxldGVkXG4gICAgfTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIENvbW1hbmRNYW5hZ2VyLFxuICBFZGl0b3IsXG4gIEV4dGVuZGFibGUsXG4gIEV4dGVuc2lvbixcbiAgRnJhZ21lbnQ2IGFzIEZyYWdtZW50LFxuICBJbnB1dFJ1bGUsXG4gIE1hcHBhYmxlUG9zaXRpb24sXG4gIE1hcmssXG4gIE1hcmtWaWV3LFxuICBOb2RlMyBhcyBOb2RlLFxuICBOb2RlUG9zLFxuICBOb2RlVmlldyxcbiAgUGFzdGVSdWxlLFxuICBSZXNpemFibGVOb2RlVmlldyxcbiAgUmVzaXphYmxlTm9kZXZpZXcsXG4gIFRyYWNrZXIsXG4gIGNhbGxPclJldHVybixcbiAgY2FuSW5zZXJ0Tm9kZSxcbiAgY29tYmluZVRyYW5zYWN0aW9uU3RlcHMsXG4gIGNvbW1hbmRzX2V4cG9ydHMgYXMgY29tbWFuZHMsXG4gIGNyZWF0ZUF0b21CbG9ja01hcmtkb3duU3BlYyxcbiAgY3JlYXRlQmxvY2tNYXJrZG93blNwZWMsXG4gIGNyZWF0ZUNoYWluYWJsZVN0YXRlLFxuICBjcmVhdGVEb2N1bWVudCxcbiAgaCBhcyBjcmVhdGVFbGVtZW50LFxuICBjcmVhdGVJbmxpbmVNYXJrZG93blNwZWMsXG4gIGNyZWF0ZU1hcHBhYmxlUG9zaXRpb24sXG4gIGNyZWF0ZU5vZGVGcm9tQ29udGVudCxcbiAgY3JlYXRlU3R5bGVUYWcsXG4gIGRlZmF1bHRCbG9ja0F0LFxuICBkZWxldGVQcm9wcyxcbiAgZWxlbWVudEZyb21TdHJpbmcsXG4gIGVzY2FwZUZvclJlZ0V4LFxuICBleHRlbnNpb25zX2V4cG9ydHMgYXMgZXh0ZW5zaW9ucyxcbiAgZmluZENoaWxkcmVuLFxuICBmaW5kQ2hpbGRyZW5JblJhbmdlLFxuICBmaW5kRHVwbGljYXRlcyxcbiAgZmluZFBhcmVudE5vZGUsXG4gIGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zLFxuICBmbGF0dGVuRXh0ZW5zaW9ucyxcbiAgZnJvbVN0cmluZyxcbiAgZ2VuZXJhdGVIVE1MLFxuICBnZW5lcmF0ZUpTT04sXG4gIGdlbmVyYXRlVGV4dCxcbiAgZ2V0QXR0cmlidXRlcyxcbiAgZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zLFxuICBnZXRDaGFuZ2VkUmFuZ2VzLFxuICBnZXREZWJ1Z0pTT04sXG4gIGdldEV4dGVuc2lvbkZpZWxkLFxuICBnZXRIVE1MRnJvbUZyYWdtZW50LFxuICBnZXRNYXJrQXR0cmlidXRlcyxcbiAgZ2V0TWFya1JhbmdlLFxuICBnZXRNYXJrVHlwZSxcbiAgZ2V0TWFya3NCZXR3ZWVuLFxuICBnZXROb2RlQXRQb3NpdGlvbixcbiAgZ2V0Tm9kZUF0dHJpYnV0ZXMsXG4gIGdldE5vZGVUeXBlLFxuICBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMsXG4gIGdldFNjaGVtYSxcbiAgZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMsXG4gIGdldFNjaGVtYVR5cGVCeU5hbWUsXG4gIGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lLFxuICBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMsXG4gIGdldFRleHQsXG4gIGdldFRleHRCZXR3ZWVuLFxuICBnZXRUZXh0Q29udGVudEZyb21Ob2RlcyxcbiAgZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSxcbiAgZ2V0VXBkYXRlZFBvc2l0aW9uLFxuICBoLFxuICBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUsXG4gIGlucHV0UnVsZXNQbHVnaW4sXG4gIGlzQWN0aXZlLFxuICBpc0FuZHJvaWQsXG4gIGlzQXRFbmRPZk5vZGUsXG4gIGlzQXRTdGFydE9mTm9kZSxcbiAgaXNFbXB0eU9iamVjdCxcbiAgaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQsXG4gIGlzRnVuY3Rpb24sXG4gIGlzTGlzdCxcbiAgaXNNYWNPUyxcbiAgaXNNYXJrQWN0aXZlLFxuICBpc05vZGVBY3RpdmUsXG4gIGlzTm9kZUVtcHR5LFxuICBpc05vZGVTZWxlY3Rpb24sXG4gIGlzTnVtYmVyLFxuICBpc1BsYWluT2JqZWN0LFxuICBpc1JlZ0V4cCxcbiAgaXNTdHJpbmcsXG4gIGlzVGV4dFNlbGVjdGlvbixcbiAgaXNpT1MsXG4gIG1hcmtJbnB1dFJ1bGUsXG4gIG1hcmtQYXN0ZVJ1bGUsXG4gIG1hcmtkb3duX2V4cG9ydHMgYXMgbWFya2Rvd24sXG4gIG1lcmdlQXR0cmlidXRlcyxcbiAgbWVyZ2VEZWVwLFxuICBtaW5NYXgsXG4gIG5vZGVJbnB1dFJ1bGUsXG4gIG5vZGVQYXN0ZVJ1bGUsXG4gIG9iamVjdEluY2x1ZGVzLFxuICBwYXJzZUF0dHJpYnV0ZXMsXG4gIHBhcnNlSW5kZW50ZWRCbG9ja3MsXG4gIHBhc3RlUnVsZXNQbHVnaW4sXG4gIHBvc1RvRE9NUmVjdCxcbiAgcmVtb3ZlRHVwbGljYXRlcyxcbiAgcmVuZGVyTmVzdGVkTWFya2Rvd25Db250ZW50LFxuICByZXNvbHZlRXh0ZW5zaW9ucyxcbiAgcmVzb2x2ZUZvY3VzUG9zaXRpb24sXG4gIHJld3JpdGVVbmtub3duQ29udGVudCxcbiAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQsXG4gIHNlcmlhbGl6ZUF0dHJpYnV0ZXMsXG4gIHNvcnRFeHRlbnNpb25zLFxuICBzcGxpdEV4dGVuc2lvbnMsXG4gIHRleHRJbnB1dFJ1bGUsXG4gIHRleHRQYXN0ZVJ1bGUsXG4gIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUsXG4gIHVwZGF0ZU1hcmtWaWV3QXR0cmlidXRlcyxcbiAgd3JhcHBpbmdJbnB1dFJ1bGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   createElement: () => (/* binding */ h),\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   jsx: () => (/* binding */ h),\n/* harmony export */   jsxDEV: () => (/* binding */ h),\n/* harmony export */   jsxs: () => (/* binding */ h)\n/* harmony export */ });\n// src/jsx-runtime.ts\nfunction Fragment(props) {\n  return props.children;\n}\nvar h = (tag, attributes) => {\n  if (tag === \"slot\") {\n    return 0;\n  }\n  if (tag instanceof Function) {\n    return tag(attributes);\n  }\n  const { children, ...rest } = attributes != null ? attributes : {};\n  if (tag === \"svg\") {\n    throw new Error(\"SVG elements are not supported in the JSX syntax, use the array syntax instead\");\n  }\n  return [tag, rest, children];\n};\n\n//# sourceMappingURL=jsx-runtime.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvanN4LXJ1bnRpbWUvanN4LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FuYmFucHJvLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9kaXN0L2pzeC1ydW50aW1lL2pzeC1ydW50aW1lLmpzPzNhZjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2pzeC1ydW50aW1lLnRzXG5mdW5jdGlvbiBGcmFnbWVudChwcm9wcykge1xuICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG52YXIgaCA9ICh0YWcsIGF0dHJpYnV0ZXMpID0+IHtcbiAgaWYgKHRhZyA9PT0gXCJzbG90XCIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAodGFnIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGFnKGF0dHJpYnV0ZXMpO1xuICB9XG4gIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnJlc3QgfSA9IGF0dHJpYnV0ZXMgIT0gbnVsbCA/IGF0dHJpYnV0ZXMgOiB7fTtcbiAgaWYgKHRhZyA9PT0gXCJzdmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNWRyBlbGVtZW50cyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGUgSlNYIHN5bnRheCwgdXNlIHRoZSBhcnJheSBzeW50YXggaW5zdGVhZFwiKTtcbiAgfVxuICByZXR1cm4gW3RhZywgcmVzdCwgY2hpbGRyZW5dO1xufTtcbmV4cG9ydCB7XG4gIEZyYWdtZW50LFxuICBoIGFzIGNyZWF0ZUVsZW1lbnQsXG4gIGgsXG4gIGggYXMganN4LFxuICBoIGFzIGpzeERFVixcbiAgaCBhcyBqc3hzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anN4LXJ1bnRpbWUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-blockquote/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blockquote: () => (/* binding */ Blockquote),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core/jsx-runtime */ \"(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js\");\n// src/blockquote.tsx\n\n\nvar inputRegex = /^\\s*>\\s$/;\nvar Blockquote = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"blockquote\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  content: \"block+\",\n  group: \"block\",\n  defining: true,\n  parseHTML() {\n    return [{ tag: \"blockquote\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"blockquote\", { ...(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), children: /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"slot\", {}) });\n  },\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode(\"blockquote\", void 0, helpers.parseChildren(token.tokens || []));\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    const prefix = \">\";\n    const result = [];\n    node.content.forEach((child) => {\n      const childContent = h.renderChildren([child]);\n      const lines = childContent.split(\"\\n\");\n      const linesWithPrefix = lines.map((line) => {\n        if (line.trim() === \"\") {\n          return prefix;\n        }\n        return `${prefix} ${line}`;\n      });\n      result.push(linesWithPrefix.join(\"\\n\"));\n    });\n    return result.join(`\n${prefix}\n`);\n  },\n  addCommands() {\n    return {\n      setBlockquote: () => ({ commands }) => {\n        return commands.wrapIn(this.name);\n      },\n      toggleBlockquote: () => ({ commands }) => {\n        return commands.toggleWrap(this.name);\n      },\n      unsetBlockquote: () => ({ commands }) => {\n        return commands.lift(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-b\": () => this.editor.commands.toggleBlockquote()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: inputRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Blockquote;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDd0U7QUFDekI7QUFDL0M7QUFDQSxpQkFBaUIsOENBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQiwyQkFBMkIsNkRBQUcsaUJBQWlCLEdBQUcsNkRBQWUseUVBQXlFLDZEQUFHLFdBQVcsR0FBRztBQUMzSixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRLEVBQUUsS0FBSztBQUNqQyxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0EsT0FBTztBQUNQLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0EsT0FBTztBQUNQLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSwrREFBaUI7QUFDdkI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2thbmJhbnByby8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ibG9ja3F1b3RlL2Rpc3QvaW5kZXguanM/OWQ1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvYmxvY2txdW90ZS50c3hcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgd3JhcHBpbmdJbnB1dFJ1bGUgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwiQHRpcHRhcC9jb3JlL2pzeC1ydW50aW1lXCI7XG52YXIgaW5wdXRSZWdleCA9IC9eXFxzKj5cXHMkLztcbnZhciBCbG9ja3F1b3RlID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImJsb2NrcXVvdGVcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgY29udGVudDogXCJibG9jaytcIixcbiAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgZGVmaW5pbmc6IHRydWUsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiBcImJsb2NrcXVvdGVcIiB9XTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcImJsb2NrcXVvdGVcIiwgeyAuLi5tZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwic2xvdFwiLCB7fSkgfSk7XG4gIH0sXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIHJldHVybiBoZWxwZXJzLmNyZWF0ZU5vZGUoXCJibG9ja3F1b3RlXCIsIHZvaWQgMCwgaGVscGVycy5wYXJzZUNoaWxkcmVuKHRva2VuLnRva2VucyB8fCBbXSkpO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICBpZiAoIW5vZGUuY29udGVudCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeCA9IFwiPlwiO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIG5vZGUuY29udGVudC5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRDb250ZW50ID0gaC5yZW5kZXJDaGlsZHJlbihbY2hpbGRdKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gY2hpbGRDb250ZW50LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgY29uc3QgbGluZXNXaXRoUHJlZml4ID0gbGluZXMubWFwKChsaW5lKSA9PiB7XG4gICAgICAgIGlmIChsaW5lLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0gJHtsaW5lfWA7XG4gICAgICB9KTtcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmVzV2l0aFByZWZpeC5qb2luKFwiXFxuXCIpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oYFxuJHtwcmVmaXh9XG5gKTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLndyYXBJbih0aGlzLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZUJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZVdyYXAodGhpcy5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB1bnNldEJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmxpZnQodGhpcy5uYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtU2hpZnQtYlwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCbG9ja3F1b3RlKClcbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IEJsb2NrcXVvdGU7XG5leHBvcnQge1xuICBCbG9ja3F1b3RlLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGlucHV0UmVnZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-bold/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bold: () => (/* binding */ Bold),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core/jsx-runtime */ \"(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js\");\n// src/bold.tsx\n\n\nvar starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/;\nvar starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g;\nvar underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/;\nvar underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g;\nvar Bold = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"bold\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"strong\"\n      },\n      {\n        tag: \"b\",\n        getAttrs: (node) => node.style.fontWeight !== \"normal\" && null\n      },\n      {\n        style: \"font-weight=400\",\n        clearMark: (mark) => mark.type.name === this.name\n      },\n      {\n        style: \"font-weight\",\n        getAttrs: (value) => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"strong\", { ...(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), children: /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"slot\", {}) });\n  },\n  markdownTokenName: \"strong\",\n  parseMarkdown: (token, helpers) => {\n    return helpers.applyMark(\"bold\", helpers.parseInline(token.tokens || []));\n  },\n  renderMarkdown: (node, h) => {\n    return `**${h.renderChildren(node)}**`;\n  },\n  addCommands() {\n    return {\n      setBold: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleBold: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetBold: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-b\": () => this.editor.commands.toggleBold(),\n      \"Mod-B\": () => this.editor.commands.toggleBold()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: starInputRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: underscoreInputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: starPasteRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: underscorePasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Bold;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYm9sZC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDbUY7QUFDcEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUFJO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsZ0JBQWdCO0FBQy9CLDJCQUEyQiw2REFBRyxhQUFhLEdBQUcsNkRBQWUseUVBQXlFLDZEQUFHLFdBQVcsR0FBRztBQUN2SixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QyxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0EsT0FBTztBQUNQLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0EsT0FBTztBQUNQLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFRRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FuYmFucHJvLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJvbGQvZGlzdC9pbmRleC5qcz84ZWVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9ib2xkLnRzeFxuaW1wb3J0IHsgTWFyaywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcIkB0aXB0YXAvY29yZS9qc3gtcnVudGltZVwiO1xudmFyIHN0YXJJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShcXCpcXCooPyFcXHMrXFwqXFwqKSgoPzpbXipdKykpXFwqXFwqKD8hXFxzK1xcKlxcKikpJC87XG52YXIgc3RhclBhc3RlUmVnZXggPSAvKD86XnxcXHMpKFxcKlxcKig/IVxccytcXCpcXCopKCg/OlteKl0rKSlcXCpcXCooPyFcXHMrXFwqXFwqKSkvZztcbnZhciB1bmRlcnNjb3JlSW5wdXRSZWdleCA9IC8oPzpefFxccykoX18oPyFcXHMrX18pKCg/OlteX10rKSlfXyg/IVxccytfXykpJC87XG52YXIgdW5kZXJzY29yZVBhc3RlUmVnZXggPSAvKD86XnxcXHMpKF9fKD8hXFxzK19fKSgoPzpbXl9dKykpX18oPyFcXHMrX18pKS9nO1xudmFyIEJvbGQgPSBNYXJrLmNyZWF0ZSh7XG4gIG5hbWU6IFwiYm9sZFwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInN0cm9uZ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6IFwiYlwiLFxuICAgICAgICBnZXRBdHRyczogKG5vZGUpID0+IG5vZGUuc3R5bGUuZm9udFdlaWdodCAhPT0gXCJub3JtYWxcIiAmJiBudWxsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogXCJmb250LXdlaWdodD00MDBcIixcbiAgICAgICAgY2xlYXJNYXJrOiAobWFyaykgPT4gbWFyay50eXBlLm5hbWUgPT09IHRoaXMubmFtZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6IFwiZm9udC13ZWlnaHRcIixcbiAgICAgICAgZ2V0QXR0cnM6ICh2YWx1ZSkgPT4gL14oYm9sZChlcik/fFs1LTldXFxkezIsfSkkLy50ZXN0KHZhbHVlKSAmJiBudWxsXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcInN0cm9uZ1wiLCB7IC4uLm1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzbG90XCIsIHt9KSB9KTtcbiAgfSxcbiAgbWFya2Rvd25Ub2tlbk5hbWU6IFwic3Ryb25nXCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIHJldHVybiBoZWxwZXJzLmFwcGx5TWFyayhcImJvbGRcIiwgaGVscGVycy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMgfHwgW10pKTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgcmV0dXJuIGAqKiR7aC5yZW5kZXJDaGlsZHJlbihub2RlKX0qKmA7XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRCb2xkOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlQm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHVuc2V0Qm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLWJcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQm9sZCgpLFxuICAgICAgXCJNb2QtQlwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCb2xkKClcbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogc3RhcklucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSksXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9LFxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogc3RhclBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSksXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZVBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IEJvbGQ7XG5leHBvcnQge1xuICBCb2xkLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIHN0YXJJbnB1dFJlZ2V4LFxuICBzdGFyUGFzdGVSZWdleCxcbiAgdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gIHVuZGVyc2NvcmVQYXN0ZVJlZ2V4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-bullet-list/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bullet-list/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BulletList: () => (/* reexport safe */ _tiptap_extension_list__WEBPACK_IMPORTED_MODULE_0__.BulletList),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_extension_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-list */ \"(ssr)/./node_modules/@tiptap/extension-list/dist/index.js\");\n// src/index.ts\n\n\nvar index_default = _tiptap_extension_list__WEBPACK_IMPORTED_MODULE_0__.BulletList;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnVsbGV0LWxpc3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNvRDtBQUNlO0FBQ25FLG9CQUFvQiw4REFBVTtBQUk1QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FuYmFucHJvLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJ1bGxldC1saXN0L2Rpc3QvaW5kZXguanM/OTNhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IEJ1bGxldExpc3QgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tbGlzdFwiO1xuaW1wb3J0IHsgQnVsbGV0TGlzdCBhcyBCdWxsZXRMaXN0MiB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1saXN0XCI7XG52YXIgaW5kZXhfZGVmYXVsdCA9IEJ1bGxldExpc3Q7XG5leHBvcnQge1xuICBCdWxsZXRMaXN0MiBhcyBCdWxsZXRMaXN0LFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-bullet-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-code-block/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CodeBlock: () => (/* binding */ CodeBlock),\n/* harmony export */   backtickInputRegex: () => (/* binding */ backtickInputRegex),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   tildeInputRegex: () => (/* binding */ tildeInputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n// src/code-block.ts\n\n\nvar DEFAULT_TAB_SIZE = 4;\nvar backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/;\nvar tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/;\nvar CodeBlock = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n  name: \"codeBlock\",\n  addOptions() {\n    return {\n      languageClassPrefix: \"language-\",\n      exitOnTripleEnter: true,\n      exitOnArrowDown: true,\n      defaultLanguage: null,\n      enableTabIndentation: false,\n      tabSize: DEFAULT_TAB_SIZE,\n      HTMLAttributes: {}\n    };\n  },\n  content: \"text*\",\n  marks: \"\",\n  group: \"block\",\n  code: true,\n  defining: true,\n  addAttributes() {\n    return {\n      language: {\n        default: this.options.defaultLanguage,\n        parseHTML: (element) => {\n          var _a;\n          const { languageClassPrefix } = this.options;\n          if (!languageClassPrefix) {\n            return null;\n          }\n          const classNames = [...((_a = element.firstElementChild) == null ? void 0 : _a.classList) || []];\n          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, \"\"));\n          const language = languages[0];\n          if (!language) {\n            return null;\n          }\n          return language;\n        },\n        rendered: false\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"pre\",\n        preserveWhitespace: \"full\"\n      }\n    ];\n  },\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      \"pre\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n      [\n        \"code\",\n        {\n          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null\n        },\n        0\n      ]\n    ];\n  },\n  markdownTokenName: \"code\",\n  parseMarkdown: (token, helpers) => {\n    var _a;\n    if (((_a = token.raw) == null ? void 0 : _a.startsWith(\"```\")) === false && token.codeBlockStyle !== \"indented\") {\n      return [];\n    }\n    return helpers.createNode(\n      \"codeBlock\",\n      { language: token.lang || null },\n      token.text ? [helpers.createTextNode(token.text)] : []\n    );\n  },\n  renderMarkdown: (node, h) => {\n    var _a;\n    let output = \"\";\n    const language = ((_a = node.attrs) == null ? void 0 : _a.language) || \"\";\n    if (!node.content) {\n      output = `\\`\\`\\`${language}\n\n\\`\\`\\``;\n    } else {\n      const lines = [`\\`\\`\\`${language}`, h.renderChildren(node.content), \"```\"];\n      output = lines.join(\"\\n\");\n    }\n    return output;\n  },\n  addCommands() {\n    return {\n      setCodeBlock: (attributes) => ({ commands }) => {\n        return commands.setNode(this.name, attributes);\n      },\n      toggleCodeBlock: (attributes) => ({ commands }) => {\n        return commands.toggleNode(this.name, \"paragraph\", attributes);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-c\": () => this.editor.commands.toggleCodeBlock(),\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const { empty, $anchor } = this.editor.state.selection;\n        const isAtStart = $anchor.pos === 1;\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false;\n        }\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes();\n        }\n        return false;\n      },\n      // handle tab indentation\n      Tab: ({ editor }) => {\n        var _a;\n        if (!this.options.enableTabIndentation) {\n          return false;\n        }\n        const tabSize = (_a = this.options.tabSize) != null ? _a : DEFAULT_TAB_SIZE;\n        const { state } = editor;\n        const { selection } = state;\n        const { $from, empty } = selection;\n        if ($from.parent.type !== this.type) {\n          return false;\n        }\n        const indent = \" \".repeat(tabSize);\n        if (empty) {\n          return editor.commands.insertContent(indent);\n        }\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection;\n          const text = state.doc.textBetween(from, to, \"\\n\", \"\\n\");\n          const lines = text.split(\"\\n\");\n          const indentedText = lines.map((line) => indent + line).join(\"\\n\");\n          tr.replaceWith(from, to, state.schema.text(indentedText));\n          return true;\n        });\n      },\n      // handle shift+tab reverse indentation\n      \"Shift-Tab\": ({ editor }) => {\n        var _a;\n        if (!this.options.enableTabIndentation) {\n          return false;\n        }\n        const tabSize = (_a = this.options.tabSize) != null ? _a : DEFAULT_TAB_SIZE;\n        const { state } = editor;\n        const { selection } = state;\n        const { $from, empty } = selection;\n        if ($from.parent.type !== this.type) {\n          return false;\n        }\n        if (empty) {\n          return editor.commands.command(({ tr }) => {\n            var _a2;\n            const { pos } = $from;\n            const codeBlockStart = $from.start();\n            const codeBlockEnd = $from.end();\n            const allText = state.doc.textBetween(codeBlockStart, codeBlockEnd, \"\\n\", \"\\n\");\n            const lines = allText.split(\"\\n\");\n            let currentLineIndex = 0;\n            let charCount = 0;\n            const relativeCursorPos = pos - codeBlockStart;\n            for (let i = 0; i < lines.length; i += 1) {\n              if (charCount + lines[i].length >= relativeCursorPos) {\n                currentLineIndex = i;\n                break;\n              }\n              charCount += lines[i].length + 1;\n            }\n            const currentLine = lines[currentLineIndex];\n            const leadingSpaces = ((_a2 = currentLine.match(/^ */)) == null ? void 0 : _a2[0]) || \"\";\n            const spacesToRemove = Math.min(leadingSpaces.length, tabSize);\n            if (spacesToRemove === 0) {\n              return true;\n            }\n            let lineStartPos = codeBlockStart;\n            for (let i = 0; i < currentLineIndex; i += 1) {\n              lineStartPos += lines[i].length + 1;\n            }\n            tr.delete(lineStartPos, lineStartPos + spacesToRemove);\n            const cursorPosInLine = pos - lineStartPos;\n            if (cursorPosInLine <= spacesToRemove) {\n              tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, lineStartPos));\n            }\n            return true;\n          });\n        }\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection;\n          const text = state.doc.textBetween(from, to, \"\\n\", \"\\n\");\n          const lines = text.split(\"\\n\");\n          const reverseIndentText = lines.map((line) => {\n            var _a2;\n            const leadingSpaces = ((_a2 = line.match(/^ */)) == null ? void 0 : _a2[0]) || \"\";\n            const spacesToRemove = Math.min(leadingSpaces.length, tabSize);\n            return line.slice(spacesToRemove);\n          }).join(\"\\n\");\n          tr.replaceWith(from, to, state.schema.text(reverseIndentText));\n          return true;\n        });\n      },\n      // exit node on triple enter\n      Enter: ({ editor }) => {\n        if (!this.options.exitOnTripleEnter) {\n          return false;\n        }\n        const { state } = editor;\n        const { selection } = state;\n        const { $from, empty } = selection;\n        if (!empty || $from.parent.type !== this.type) {\n          return false;\n        }\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n        const endsWithDoubleNewline = $from.parent.textContent.endsWith(\"\\n\\n\");\n        if (!isAtEnd || !endsWithDoubleNewline) {\n          return false;\n        }\n        return editor.chain().command(({ tr }) => {\n          tr.delete($from.pos - 2, $from.pos);\n          return true;\n        }).exitCode().run();\n      },\n      // exit node on arrow down\n      ArrowDown: ({ editor }) => {\n        if (!this.options.exitOnArrowDown) {\n          return false;\n        }\n        const { state } = editor;\n        const { selection, doc } = state;\n        const { $from, empty } = selection;\n        if (!empty || $from.parent.type !== this.type) {\n          return false;\n        }\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n        if (!isAtEnd) {\n          return false;\n        }\n        const after = $from.after();\n        if (after === void 0) {\n          return false;\n        }\n        const nodeAfter = doc.nodeAt(after);\n        if (nodeAfter) {\n          return editor.commands.command(({ tr }) => {\n            tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(doc.resolve(after)));\n            return true;\n          });\n        }\n        return editor.commands.exitCode();\n      }\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n        find: backtickInputRegex,\n        type: this.type,\n        getAttributes: (match) => ({\n          language: match[1]\n        })\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n        find: tildeInputRegex,\n        type: this.type,\n        getAttributes: (match) => ({\n          language: match[1]\n        })\n      })\n    ];\n  },\n  addProseMirrorPlugins() {\n    return [\n      // this plugin creates a code block for pasted content from VS Code\n      // we can also detect the copied code language\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"codeBlockVSCodeHandler\"),\n        props: {\n          handlePaste: (view, event) => {\n            if (!event.clipboardData) {\n              return false;\n            }\n            if (this.editor.isActive(this.type.name)) {\n              return false;\n            }\n            const text = event.clipboardData.getData(\"text/plain\");\n            const vscode = event.clipboardData.getData(\"vscode-editor-data\");\n            const vscodeData = vscode ? JSON.parse(vscode) : void 0;\n            const language = vscodeData == null ? void 0 : vscodeData.mode;\n            if (!text || !language) {\n              return false;\n            }\n            const { tr, schema } = view.state;\n            const textNode = schema.text(text.replace(/\\r\\n?/g, \"\\n\"));\n            tr.replaceSelectionWith(this.type.create({ language }, textNode));\n            if (tr.selection.$from.parent.type !== this.type) {\n              tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));\n            }\n            tr.setMeta(\"paste\", true);\n            view.dispatch(tr);\n            return true;\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = CodeBlock;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQzZFO0FBQ0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQSxNQUFNLDZEQUFlO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4QkFBOEI7QUFDdEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBLE1BQU07QUFDTiw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVDQUF1QyxVQUFVO0FBQ2pEO0FBQ0EsT0FBTztBQUNQLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixZQUFZO0FBQzVCLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQ7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkRBQWE7QUFDM0M7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFlBQVk7QUFDNUIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hELDRCQUE0Qix1REFBUztBQUNyQztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSxvRUFBc0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU0sb0VBQXNCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQU07QUFDaEIsaUJBQWlCLHVEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0EsdURBQXVELFVBQVU7QUFDakU7QUFDQSw4QkFBOEIsMkRBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FuYmFucHJvLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUtYmxvY2svZGlzdC9pbmRleC5qcz8zOGE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb2RlLWJsb2NrLnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSwgU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBERUZBVUxUX1RBQl9TSVpFID0gNDtcbnZhciBiYWNrdGlja0lucHV0UmVnZXggPSAvXmBgYChbYS16XSspP1tcXHNcXG5dJC87XG52YXIgdGlsZGVJbnB1dFJlZ2V4ID0gL15+fn4oW2Etel0rKT9bXFxzXFxuXSQvO1xudmFyIENvZGVCbG9jayA9IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogXCJjb2RlQmxvY2tcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZ3VhZ2VDbGFzc1ByZWZpeDogXCJsYW5ndWFnZS1cIixcbiAgICAgIGV4aXRPblRyaXBsZUVudGVyOiB0cnVlLFxuICAgICAgZXhpdE9uQXJyb3dEb3duOiB0cnVlLFxuICAgICAgZGVmYXVsdExhbmd1YWdlOiBudWxsLFxuICAgICAgZW5hYmxlVGFiSW5kZW50YXRpb246IGZhbHNlLFxuICAgICAgdGFiU2l6ZTogREVGQVVMVF9UQUJfU0laRSxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIGNvbnRlbnQ6IFwidGV4dCpcIixcbiAgbWFya3M6IFwiXCIsXG4gIGdyb3VwOiBcImJsb2NrXCIsXG4gIGNvZGU6IHRydWUsXG4gIGRlZmluaW5nOiB0cnVlLFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsYW5ndWFnZToge1xuICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMuZGVmYXVsdExhbmd1YWdlLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGNvbnN0IHsgbGFuZ3VhZ2VDbGFzc1ByZWZpeCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgIGlmICghbGFuZ3VhZ2VDbGFzc1ByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBbLi4uKChfYSA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jbGFzc0xpc3QpIHx8IFtdXTtcbiAgICAgICAgICBjb25zdCBsYW5ndWFnZXMgPSBjbGFzc05hbWVzLmZpbHRlcigoY2xhc3NOYW1lKSA9PiBjbGFzc05hbWUuc3RhcnRzV2l0aChsYW5ndWFnZUNsYXNzUHJlZml4KSkubWFwKChjbGFzc05hbWUpID0+IGNsYXNzTmFtZS5yZXBsYWNlKGxhbmd1YWdlQ2xhc3NQcmVmaXgsIFwiXCIpKTtcbiAgICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGxhbmd1YWdlc1swXTtcbiAgICAgICAgICBpZiAoIWxhbmd1YWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxhbmd1YWdlO1xuICAgICAgICB9LFxuICAgICAgICByZW5kZXJlZDogZmFsc2VcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInByZVwiLFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6IFwiZnVsbFwiXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJwcmVcIixcbiAgICAgIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSxcbiAgICAgIFtcbiAgICAgICAgXCJjb2RlXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzczogbm9kZS5hdHRycy5sYW5ndWFnZSA/IHRoaXMub3B0aW9ucy5sYW5ndWFnZUNsYXNzUHJlZml4ICsgbm9kZS5hdHRycy5sYW5ndWFnZSA6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgMFxuICAgICAgXVxuICAgIF07XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5OYW1lOiBcImNvZGVcIixcbiAgcGFyc2VNYXJrZG93bjogKHRva2VuLCBoZWxwZXJzKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoKF9hID0gdG9rZW4ucmF3KSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RhcnRzV2l0aChcImBgYFwiKSkgPT09IGZhbHNlICYmIHRva2VuLmNvZGVCbG9ja1N0eWxlICE9PSBcImluZGVudGVkXCIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGhlbHBlcnMuY3JlYXRlTm9kZShcbiAgICAgIFwiY29kZUJsb2NrXCIsXG4gICAgICB7IGxhbmd1YWdlOiB0b2tlbi5sYW5nIHx8IG51bGwgfSxcbiAgICAgIHRva2VuLnRleHQgPyBbaGVscGVycy5jcmVhdGVUZXh0Tm9kZSh0b2tlbi50ZXh0KV0gOiBbXVxuICAgICk7XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBsZXQgb3V0cHV0ID0gXCJcIjtcbiAgICBjb25zdCBsYW5ndWFnZSA9ICgoX2EgPSBub2RlLmF0dHJzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGFuZ3VhZ2UpIHx8IFwiXCI7XG4gICAgaWYgKCFub2RlLmNvbnRlbnQpIHtcbiAgICAgIG91dHB1dCA9IGBcXGBcXGBcXGAke2xhbmd1YWdlfVxuXG5cXGBcXGBcXGBgO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsaW5lcyA9IFtgXFxgXFxgXFxgJHtsYW5ndWFnZX1gLCBoLnJlbmRlckNoaWxkcmVuKG5vZGUuY29udGVudCksIFwiYGBgXCJdO1xuICAgICAgb3V0cHV0ID0gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldENvZGVCbG9jazogKGF0dHJpYnV0ZXMpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVDb2RlQmxvY2s6IChhdHRyaWJ1dGVzKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVOb2RlKHRoaXMubmFtZSwgXCJwYXJhZ3JhcGhcIiwgYXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLUFsdC1jXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUNvZGVCbG9jaygpLFxuICAgICAgLy8gcmVtb3ZlIGNvZGUgYmxvY2sgd2hlbiBhdCBzdGFydCBvZiBkb2N1bWVudCBvciBjb2RlIGJsb2NrIGlzIGVtcHR5XG4gICAgICBCYWNrc3BhY2U6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBlbXB0eSwgJGFuY2hvciB9ID0gdGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCBpc0F0U3RhcnQgPSAkYW5jaG9yLnBvcyA9PT0gMTtcbiAgICAgICAgaWYgKCFlbXB0eSB8fCAkYW5jaG9yLnBhcmVudC50eXBlLm5hbWUgIT09IHRoaXMubmFtZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBdFN0YXJ0IHx8ICEkYW5jaG9yLnBhcmVudC50ZXh0Q29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IuY29tbWFuZHMuY2xlYXJOb2RlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICAvLyBoYW5kbGUgdGFiIGluZGVudGF0aW9uXG4gICAgICBUYWI6ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlVGFiSW5kZW50YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFiU2l6ZSA9IChfYSA9IHRoaXMub3B0aW9ucy50YWJTaXplKSAhPSBudWxsID8gX2EgOiBERUZBVUxUX1RBQl9TSVpFO1xuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3I7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyAkZnJvbSwgZW1wdHkgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgaWYgKCRmcm9tLnBhcmVudC50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZW50ID0gXCIgXCIucmVwZWF0KHRhYlNpemUpO1xuICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmluc2VydENvbnRlbnQoaW5kZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gc3RhdGUuZG9jLnRleHRCZXR3ZWVuKGZyb20sIHRvLCBcIlxcblwiLCBcIlxcblwiKTtcbiAgICAgICAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgY29uc3QgaW5kZW50ZWRUZXh0ID0gbGluZXMubWFwKChsaW5lKSA9PiBpbmRlbnQgKyBsaW5lKS5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKGZyb20sIHRvLCBzdGF0ZS5zY2hlbWEudGV4dChpbmRlbnRlZFRleHQpKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gaGFuZGxlIHNoaWZ0K3RhYiByZXZlcnNlIGluZGVudGF0aW9uXG4gICAgICBcIlNoaWZ0LVRhYlwiOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZVRhYkluZGVudGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhYlNpemUgPSAoX2EgPSB0aGlzLm9wdGlvbnMudGFiU2l6ZSkgIT0gbnVsbCA/IF9hIDogREVGQVVMVF9UQUJfU0laRTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yO1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgJGZyb20sIGVtcHR5IH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGlmICgkZnJvbS5wYXJlbnQudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICAgIHJldHVybiBlZGl0b3IuY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgY29uc3QgeyBwb3MgfSA9ICRmcm9tO1xuICAgICAgICAgICAgY29uc3QgY29kZUJsb2NrU3RhcnQgPSAkZnJvbS5zdGFydCgpO1xuICAgICAgICAgICAgY29uc3QgY29kZUJsb2NrRW5kID0gJGZyb20uZW5kKCk7XG4gICAgICAgICAgICBjb25zdCBhbGxUZXh0ID0gc3RhdGUuZG9jLnRleHRCZXR3ZWVuKGNvZGVCbG9ja1N0YXJ0LCBjb2RlQmxvY2tFbmQsIFwiXFxuXCIsIFwiXFxuXCIpO1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBhbGxUZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRMaW5lSW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IGNoYXJDb3VudCA9IDA7XG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZUN1cnNvclBvcyA9IHBvcyAtIGNvZGVCbG9ja1N0YXJ0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoY2hhckNvdW50ICsgbGluZXNbaV0ubGVuZ3RoID49IHJlbGF0aXZlQ3Vyc29yUG9zKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2hhckNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGluZSA9IGxpbmVzW2N1cnJlbnRMaW5lSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbGVhZGluZ1NwYWNlcyA9ICgoX2EyID0gY3VycmVudExpbmUubWF0Y2goL14gKi8pKSA9PSBudWxsID8gdm9pZCAwIDogX2EyWzBdKSB8fCBcIlwiO1xuICAgICAgICAgICAgY29uc3Qgc3BhY2VzVG9SZW1vdmUgPSBNYXRoLm1pbihsZWFkaW5nU3BhY2VzLmxlbmd0aCwgdGFiU2l6ZSk7XG4gICAgICAgICAgICBpZiAoc3BhY2VzVG9SZW1vdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGluZVN0YXJ0UG9zID0gY29kZUJsb2NrU3RhcnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRMaW5lSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBsaW5lU3RhcnRQb3MgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLmRlbGV0ZShsaW5lU3RhcnRQb3MsIGxpbmVTdGFydFBvcyArIHNwYWNlc1RvUmVtb3ZlKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvc0luTGluZSA9IHBvcyAtIGxpbmVTdGFydFBvcztcbiAgICAgICAgICAgIGlmIChjdXJzb3JQb3NJbkxpbmUgPD0gc3BhY2VzVG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgbGluZVN0YXJ0UG9zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gc3RhdGUuZG9jLnRleHRCZXR3ZWVuKGZyb20sIHRvLCBcIlxcblwiLCBcIlxcblwiKTtcbiAgICAgICAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgY29uc3QgcmV2ZXJzZUluZGVudFRleHQgPSBsaW5lcy5tYXAoKGxpbmUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICBjb25zdCBsZWFkaW5nU3BhY2VzID0gKChfYTIgPSBsaW5lLm1hdGNoKC9eICovKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMlswXSkgfHwgXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IHNwYWNlc1RvUmVtb3ZlID0gTWF0aC5taW4obGVhZGluZ1NwYWNlcy5sZW5ndGgsIHRhYlNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUuc2xpY2Uoc3BhY2VzVG9SZW1vdmUpO1xuICAgICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgdHIucmVwbGFjZVdpdGgoZnJvbSwgdG8sIHN0YXRlLnNjaGVtYS50ZXh0KHJldmVyc2VJbmRlbnRUZXh0KSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIC8vIGV4aXQgbm9kZSBvbiB0cmlwbGUgZW50ZXJcbiAgICAgIEVudGVyOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5leGl0T25UcmlwbGVFbnRlcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3I7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyAkZnJvbSwgZW1wdHkgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgaWYgKCFlbXB0eSB8fCAkZnJvbS5wYXJlbnQudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQXRFbmQgPSAkZnJvbS5wYXJlbnRPZmZzZXQgPT09ICRmcm9tLnBhcmVudC5ub2RlU2l6ZSAtIDI7XG4gICAgICAgIGNvbnN0IGVuZHNXaXRoRG91YmxlTmV3bGluZSA9ICRmcm9tLnBhcmVudC50ZXh0Q29udGVudC5lbmRzV2l0aChcIlxcblxcblwiKTtcbiAgICAgICAgaWYgKCFpc0F0RW5kIHx8ICFlbmRzV2l0aERvdWJsZU5ld2xpbmUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVkaXRvci5jaGFpbigpLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICAgIHRyLmRlbGV0ZSgkZnJvbS5wb3MgLSAyLCAkZnJvbS5wb3MpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KS5leGl0Q29kZSgpLnJ1bigpO1xuICAgICAgfSxcbiAgICAgIC8vIGV4aXQgbm9kZSBvbiBhcnJvdyBkb3duXG4gICAgICBBcnJvd0Rvd246ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmV4aXRPbkFycm93RG93bikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3I7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBpZiAoIWVtcHR5IHx8ICRmcm9tLnBhcmVudC50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBdEVuZCA9ICRmcm9tLnBhcmVudE9mZnNldCA9PT0gJGZyb20ucGFyZW50Lm5vZGVTaXplIC0gMjtcbiAgICAgICAgaWYgKCFpc0F0RW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFmdGVyID0gJGZyb20uYWZ0ZXIoKTtcbiAgICAgICAgaWYgKGFmdGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZUFmdGVyID0gZG9jLm5vZGVBdChhZnRlcik7XG4gICAgICAgIGlmIChub2RlQWZ0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKGRvYy5yZXNvbHZlKGFmdGVyKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVkaXRvci5jb21tYW5kcy5leGl0Q29kZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBiYWNrdGlja0lucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogKG1hdGNoKSA9PiAoe1xuICAgICAgICAgIGxhbmd1YWdlOiBtYXRjaFsxXVxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogdGlsZGVJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IChtYXRjaCkgPT4gKHtcbiAgICAgICAgICBsYW5ndWFnZTogbWF0Y2hbMV1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgXTtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyB0aGlzIHBsdWdpbiBjcmVhdGVzIGEgY29kZSBibG9jayBmb3IgcGFzdGVkIGNvbnRlbnQgZnJvbSBWUyBDb2RlXG4gICAgICAvLyB3ZSBjYW4gYWxzbyBkZXRlY3QgdGhlIGNvcGllZCBjb2RlIGxhbmd1YWdlXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KFwiY29kZUJsb2NrVlNDb2RlSGFuZGxlclwiKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVQYXN0ZTogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LmNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdG9yLmlzQWN0aXZlKHRoaXMudHlwZS5uYW1lKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKTtcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZSA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YShcInZzY29kZS1lZGl0b3ItZGF0YVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZURhdGEgPSB2c2NvZGUgPyBKU09OLnBhcnNlKHZzY29kZSkgOiB2b2lkIDA7XG4gICAgICAgICAgICBjb25zdCBsYW5ndWFnZSA9IHZzY29kZURhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHZzY29kZURhdGEubW9kZTtcbiAgICAgICAgICAgIGlmICghdGV4dCB8fCAhbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0ciwgc2NoZW1hIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBzY2hlbWEudGV4dCh0ZXh0LnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIikpO1xuICAgICAgICAgICAgdHIucmVwbGFjZVNlbGVjdGlvbldpdGgodGhpcy50eXBlLmNyZWF0ZSh7IGxhbmd1YWdlIH0sIHRleHROb2RlKSk7XG4gICAgICAgICAgICBpZiAodHIuc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCB0ci5zZWxlY3Rpb24uZnJvbSAtIDIpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIuc2V0TWV0YShcInBhc3RlXCIsIHRydWUpO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBDb2RlQmxvY2s7XG5leHBvcnQge1xuICBDb2RlQmxvY2ssXG4gIGJhY2t0aWNrSW5wdXRSZWdleCxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0LFxuICB0aWxkZUlucHV0UmVnZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-code/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-code/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Code: () => (/* binding */ Code),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/code.ts\n\nvar inputRegex = /(^|[^`])`([^`]+)`(?!`)$/;\nvar pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;\nvar Code = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"code\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  excludes: \"_\",\n  code: true,\n  exitable: true,\n  parseHTML() {\n    return [{ tag: \"code\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"code\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"codespan\",\n  parseMarkdown: (token, helpers) => {\n    return helpers.applyMark(\"code\", [{ type: \"text\", text: token.text || \"\" }]);\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return `\\`${h.renderChildren(node.content)}\\``;\n  },\n  addCommands() {\n    return {\n      setCode: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleCode: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetCode: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-e\": () => this.editor.commands.toggleCode()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: inputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: pasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Code;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDbUY7QUFDbkY7QUFDQTtBQUNBLFdBQVcsOENBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQixvQkFBb0IsNkRBQWU7QUFDbkMsR0FBRztBQUNIO0FBQ0E7QUFDQSx3Q0FBd0Msc0NBQXNDO0FBQzlFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBLE9BQU87QUFDUCwyQkFBMkIsVUFBVTtBQUNyQztBQUNBLE9BQU87QUFDUCwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sMkRBQWE7QUFDbkI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FuYmFucHJvLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUvZGlzdC9pbmRleC5qcz80ZWQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb2RlLnRzXG5pbXBvcnQgeyBNYXJrLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgaW5wdXRSZWdleCA9IC8oXnxbXmBdKWAoW15gXSspYCg/IWApJC87XG52YXIgcGFzdGVSZWdleCA9IC8oXnxbXmBdKWAoW15gXSspYCg/IWApL2c7XG52YXIgQ29kZSA9IE1hcmsuY3JlYXRlKHtcbiAgbmFtZTogXCJjb2RlXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIGV4Y2x1ZGVzOiBcIl9cIixcbiAgY29kZTogdHJ1ZSxcbiAgZXhpdGFibGU6IHRydWUsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiBcImNvZGVcIiB9XTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1wiY29kZVwiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBtYXJrZG93blRva2VuTmFtZTogXCJjb2Rlc3BhblwiLFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGhlbHBlcnMpID0+IHtcbiAgICByZXR1cm4gaGVscGVycy5hcHBseU1hcmsoXCJjb2RlXCIsIFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiB0b2tlbi50ZXh0IHx8IFwiXCIgfV0pO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICBpZiAoIW5vZGUuY29udGVudCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBgXFxgJHtoLnJlbmRlckNoaWxkcmVuKG5vZGUuY29udGVudCl9XFxgYDtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldENvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVDb2RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdW5zZXRDb2RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtZVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVDb2RlKClcbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBwYXN0ZVJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBDb2RlO1xuZXhwb3J0IHtcbiAgQ29kZSxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0LFxuICBpbnB1dFJlZ2V4LFxuICBwYXN0ZVJlZ2V4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-document/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tiptap/extension-document/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/document.ts\n\nvar Document = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"doc\",\n  topNode: true,\n  content: \"block+\",\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return h.renderChildren(node.content, \"\\n\\n\");\n  }\n});\n\n// src/index.ts\nvar index_default = Document;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNvQztBQUNwQyxlQUFlLDhDQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYW5iYW5wcm8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQvZGlzdC9pbmRleC5qcz9lZDBiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9kb2N1bWVudC50c1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBEb2N1bWVudCA9IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogXCJkb2NcIixcbiAgdG9wTm9kZTogdHJ1ZSxcbiAgY29udGVudDogXCJibG9jaytcIixcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgaWYgKCFub2RlLmNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gaC5yZW5kZXJDaGlsZHJlbihub2RlLmNvbnRlbnQsIFwiXFxuXFxuXCIpO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IERvY3VtZW50O1xuZXhwb3J0IHtcbiAgRG9jdW1lbnQsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-document/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-hard-break/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HardBreak: () => (/* binding */ HardBreak),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/hard-break.ts\n\nvar HardBreak = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"hardBreak\",\n  markdownTokenName: \"br\",\n  addOptions() {\n    return {\n      keepMarks: true,\n      HTMLAttributes: {}\n    };\n  },\n  inline: true,\n  group: \"inline\",\n  selectable: false,\n  linebreakReplacement: true,\n  parseHTML() {\n    return [{ tag: \"br\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"br\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  renderText() {\n    return \"\\n\";\n  },\n  renderMarkdown: () => `  \n`,\n  parseMarkdown: () => {\n    return {\n      type: \"hardBreak\"\n    };\n  },\n  addCommands() {\n    return {\n      setHardBreak: () => ({ commands, chain, state, editor }) => {\n        return commands.first([\n          () => commands.exitCode(),\n          () => commands.command(() => {\n            const { selection, storedMarks } = state;\n            if (selection.$from.parent.type.spec.isolating) {\n              return false;\n            }\n            const { keepMarks } = this.options;\n            const { splittableMarks } = editor.extensionManager;\n            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n            return chain().insertContent({ type: this.name }).command(({ tr, dispatch }) => {\n              if (dispatch && marks && keepMarks) {\n                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));\n                tr.ensureMarks(filteredMarks);\n              }\n              return true;\n            }).run();\n          })\n        ]);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Enter\": () => this.editor.commands.setHardBreak(),\n      \"Shift-Enter\": () => this.editor.commands.setHardBreak()\n    };\n  }\n});\n\n// src/index.ts\nvar index_default = HardBreak;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ3FEO0FBQ3JELGdCQUFnQiw4Q0FBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQixrQkFBa0IsNkRBQWU7QUFDakMsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLDJDQUEyQyxpQkFBaUIsYUFBYSxjQUFjO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FuYmFucHJvLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhhcmQtYnJlYWsvZGlzdC9pbmRleC5qcz84NmNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9oYXJkLWJyZWFrLnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgSGFyZEJyZWFrID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImhhcmRCcmVha1wiLFxuICBtYXJrZG93blRva2VuTmFtZTogXCJiclwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZWVwTWFya3M6IHRydWUsXG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBpbmxpbmU6IHRydWUsXG4gIGdyb3VwOiBcImlubGluZVwiLFxuICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgbGluZWJyZWFrUmVwbGFjZW1lbnQ6IHRydWUsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiBcImJyXCIgfV07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcImJyXCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKV07XG4gIH0sXG4gIHJlbmRlclRleHQoKSB7XG4gICAgcmV0dXJuIFwiXFxuXCI7XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAoKSA9PiBgICBcbmAsXG4gIHBhcnNlTWFya2Rvd246ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJoYXJkQnJlYWtcIlxuICAgIH07XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRIYXJkQnJlYWs6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiwgc3RhdGUsIGVkaXRvciB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5maXJzdChbXG4gICAgICAgICAgKCkgPT4gY29tbWFuZHMuZXhpdENvZGUoKSxcbiAgICAgICAgICAoKSA9PiBjb21tYW5kcy5jb21tYW5kKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGU7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsga2VlcE1hcmtzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXI7XG4gICAgICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpO1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluKCkuaW5zZXJ0Q29udGVudCh7IHR5cGU6IHRoaXMubmFtZSB9KS5jb21tYW5kKCh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChkaXNwYXRjaCAmJiBtYXJrcyAmJiBrZWVwTWFya3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcbiAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pLnJ1bigpO1xuICAgICAgICAgIH0pXG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1FbnRlclwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRIYXJkQnJlYWsoKSxcbiAgICAgIFwiU2hpZnQtRW50ZXJcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0SGFyZEJyZWFrKClcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IEhhcmRCcmVhaztcbmV4cG9ydCB7XG4gIEhhcmRCcmVhayxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-heading/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Heading: () => (/* binding */ Heading),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/heading.ts\n\nvar Heading = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"heading\",\n  addOptions() {\n    return {\n      levels: [1, 2, 3, 4, 5, 6],\n      HTMLAttributes: {}\n    };\n  },\n  content: \"inline*\",\n  group: \"block\",\n  defining: true,\n  addAttributes() {\n    return {\n      level: {\n        default: 1,\n        rendered: false\n      }\n    };\n  },\n  parseHTML() {\n    return this.options.levels.map((level) => ({\n      tag: `h${level}`,\n      attrs: { level }\n    }));\n  },\n  renderHTML({ node, HTMLAttributes }) {\n    const hasLevel = this.options.levels.includes(node.attrs.level);\n    const level = hasLevel ? node.attrs.level : this.options.levels[0];\n    return [`h${level}`, (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode(\"heading\", { level: token.depth || 1 }, helpers.parseInline(token.tokens || []));\n  },\n  renderMarkdown: (node, h) => {\n    var _a;\n    const level = ((_a = node.attrs) == null ? void 0 : _a.level) ? parseInt(node.attrs.level, 10) : 1;\n    const headingChars = \"#\".repeat(level);\n    if (!node.content) {\n      return \"\";\n    }\n    return `${headingChars} ${h.renderChildren(node.content)}`;\n  },\n  addCommands() {\n    return {\n      setHeading: (attributes) => ({ commands }) => {\n        if (!this.options.levels.includes(attributes.level)) {\n          return false;\n        }\n        return commands.setNode(this.name, attributes);\n      },\n      toggleHeading: (attributes) => ({ commands }) => {\n        if (!this.options.levels.includes(attributes.level)) {\n          return false;\n        }\n        return commands.toggleNode(this.name, \"paragraph\", attributes);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return this.options.levels.reduce(\n      (items, level) => ({\n        ...items,\n        ...{\n          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })\n        }\n      }),\n      {}\n    );\n  },\n  addInputRules() {\n    return this.options.levels.map((level) => {\n      return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textblockTypeInputRule)({\n        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\\\s$`),\n        type: this.type,\n        getAttributes: {\n          level\n        }\n      });\n    });\n  }\n});\n\n// src/index.ts\nvar index_default = Heading;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGVhZGluZy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQzZFO0FBQzdFLGNBQWMsOENBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZTtBQUNmLEtBQUs7QUFDTCxHQUFHO0FBQ0gsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBLGdCQUFnQixNQUFNLEdBQUcsNkRBQWU7QUFDeEMsR0FBRztBQUNIO0FBQ0EsMkNBQTJDLHlCQUF5QjtBQUNwRSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWMsRUFBRSwrQkFBK0I7QUFDN0QsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNLCtDQUErQyxPQUFPO0FBQ2xGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsb0VBQXNCO0FBQ25DLDhCQUE4QixFQUFFLGlDQUFpQyxHQUFHLE9BQU87QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2thbmJhbnByby8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oZWFkaW5nL2Rpc3QvaW5kZXguanM/OGViYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaGVhZGluZy50c1xuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIEhlYWRpbmcgPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6IFwiaGVhZGluZ1wiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbHM6IFsxLCAyLCAzLCA0LCA1LCA2XSxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICBncm91cDogXCJibG9ja1wiLFxuICBkZWZpbmluZzogdHJ1ZSxcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWw6IHtcbiAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgcmVuZGVyZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGV2ZWxzLm1hcCgobGV2ZWwpID0+ICh7XG4gICAgICB0YWc6IGBoJHtsZXZlbH1gLFxuICAgICAgYXR0cnM6IHsgbGV2ZWwgfVxuICAgIH0pKTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICBjb25zdCBoYXNMZXZlbCA9IHRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMobm9kZS5hdHRycy5sZXZlbCk7XG4gICAgY29uc3QgbGV2ZWwgPSBoYXNMZXZlbCA/IG5vZGUuYXR0cnMubGV2ZWwgOiB0aGlzLm9wdGlvbnMubGV2ZWxzWzBdO1xuICAgIHJldHVybiBbYGgke2xldmVsfWAsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gIH0sXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIHJldHVybiBoZWxwZXJzLmNyZWF0ZU5vZGUoXCJoZWFkaW5nXCIsIHsgbGV2ZWw6IHRva2VuLmRlcHRoIHx8IDEgfSwgaGVscGVycy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMgfHwgW10pKTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxldmVsID0gKChfYSA9IG5vZGUuYXR0cnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5sZXZlbCkgPyBwYXJzZUludChub2RlLmF0dHJzLmxldmVsLCAxMCkgOiAxO1xuICAgIGNvbnN0IGhlYWRpbmdDaGFycyA9IFwiI1wiLnJlcGVhdChsZXZlbCk7XG4gICAgaWYgKCFub2RlLmNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gYCR7aGVhZGluZ0NoYXJzfSAke2gucmVuZGVyQ2hpbGRyZW4obm9kZS5jb250ZW50KX1gO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SGVhZGluZzogKGF0dHJpYnV0ZXMpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKGF0dHJpYnV0ZXMubGV2ZWwpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSwgYXR0cmlidXRlcyk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlSGVhZGluZzogKGF0dHJpYnV0ZXMpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKGF0dHJpYnV0ZXMubGV2ZWwpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVOb2RlKHRoaXMubmFtZSwgXCJwYXJhZ3JhcGhcIiwgYXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHMucmVkdWNlKFxuICAgICAgKGl0ZW1zLCBsZXZlbCkgPT4gKHtcbiAgICAgICAgLi4uaXRlbXMsXG4gICAgICAgIC4uLntcbiAgICAgICAgICBbYE1vZC1BbHQtJHtsZXZlbH1gXTogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSGVhZGluZyh7IGxldmVsIH0pXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGV2ZWxzLm1hcCgobGV2ZWwpID0+IHtcbiAgICAgIHJldHVybiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogbmV3IFJlZ0V4cChgXigjeyR7TWF0aC5taW4oLi4udGhpcy5vcHRpb25zLmxldmVscyl9LCR7bGV2ZWx9fSlcXFxccyRgKSxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgbGV2ZWxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gSGVhZGluZztcbmV4cG9ydCB7XG4gIEhlYWRpbmcsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-horizontal-rule/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HorizontalRule: () => (/* binding */ HorizontalRule),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n// src/horizontal-rule.ts\n\n\nvar HorizontalRule = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n  name: \"horizontalRule\",\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      nextNodeType: \"paragraph\"\n    };\n  },\n  group: \"block\",\n  parseHTML() {\n    return [{ tag: \"hr\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"hr\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  markdownTokenName: \"hr\",\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode(\"horizontalRule\");\n  },\n  renderMarkdown: () => {\n    return \"---\";\n  },\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({ chain, state }) => {\n        if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.canInsertNode)(state, state.schema.nodes[this.name])) {\n          return false;\n        }\n        const { selection } = state;\n        const { $to: $originTo } = selection;\n        const currentChain = chain();\n        if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(selection)) {\n          currentChain.insertContentAt($originTo.pos, {\n            type: this.name\n          });\n        } else {\n          currentChain.insertContent({ type: this.name });\n        }\n        return currentChain.command(({ state: chainState, tr, dispatch }) => {\n          if (dispatch) {\n            const { $to } = tr.selection;\n            const posAfter = $to.end();\n            if ($to.nodeAfter) {\n              if ($to.nodeAfter.isTextblock) {\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos + 1));\n              } else if ($to.nodeAfter.isBlock) {\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(tr.doc, $to.pos));\n              } else {\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos));\n              }\n            } else {\n              const nodeType = chainState.schema.nodes[this.options.nextNodeType] || $to.parent.type.contentMatch.defaultType;\n              const node = nodeType == null ? void 0 : nodeType.create();\n              if (node) {\n                tr.insert(posAfter, node);\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, posAfter + 1));\n              }\n            }\n            tr.scrollIntoView();\n          }\n          return true;\n        }).run();\n      }\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.nodeInputRule)({\n        find: /^(?:---|-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = HorizontalRule;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ29HO0FBQ3BDO0FBQ2hFLHFCQUFxQiw4Q0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQixrQkFBa0IsNkRBQWU7QUFDakMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRCxhQUFhLDJEQUFhO0FBQzFCO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsWUFBWSw2REFBZTtBQUMzQjtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVix1Q0FBdUMsaUJBQWlCO0FBQ3hEO0FBQ0EsdUNBQXVDLGlDQUFpQztBQUN4RTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyREFBYTtBQUM3QyxnQkFBZ0I7QUFDaEIsZ0NBQWdDLDJEQUFhO0FBQzdDLGdCQUFnQjtBQUNoQixnQ0FBZ0MsMkRBQWE7QUFDN0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYW5iYW5wcm8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlL2Rpc3QvaW5kZXguanM/ZGNiYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaG9yaXpvbnRhbC1ydWxlLnRzXG5pbXBvcnQgeyBjYW5JbnNlcnROb2RlLCBpc05vZGVTZWxlY3Rpb24sIG1lcmdlQXR0cmlidXRlcywgTm9kZSwgbm9kZUlucHV0UnVsZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIEhvcml6b250YWxSdWxlID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImhvcml6b250YWxSdWxlXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIG5leHROb2RlVHlwZTogXCJwYXJhZ3JhcGhcIlxuICAgIH07XG4gIH0sXG4gIGdyb3VwOiBcImJsb2NrXCIsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiBcImhyXCIgfV07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcImhyXCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKV07XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5OYW1lOiBcImhyXCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIHJldHVybiBoZWxwZXJzLmNyZWF0ZU5vZGUoXCJob3Jpem9udGFsUnVsZVwiKTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246ICgpID0+IHtcbiAgICByZXR1cm4gXCItLS1cIjtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEhvcml6b250YWxSdWxlOiAoKSA9PiAoeyBjaGFpbiwgc3RhdGUgfSkgPT4ge1xuICAgICAgICBpZiAoIWNhbkluc2VydE5vZGUoc3RhdGUsIHN0YXRlLnNjaGVtYS5ub2Rlc1t0aGlzLm5hbWVdKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgJHRvOiAkb3JpZ2luVG8gfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgY29uc3QgY3VycmVudENoYWluID0gY2hhaW4oKTtcbiAgICAgICAgaWYgKGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgY3VycmVudENoYWluLmluc2VydENvbnRlbnRBdCgkb3JpZ2luVG8ucG9zLCB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50Q2hhaW4uaW5zZXJ0Q29udGVudCh7IHR5cGU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudENoYWluLmNvbW1hbmQoKHsgc3RhdGU6IGNoYWluU3RhdGUsIHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBjb25zdCB7ICR0byB9ID0gdHIuc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgcG9zQWZ0ZXIgPSAkdG8uZW5kKCk7XG4gICAgICAgICAgICBpZiAoJHRvLm5vZGVBZnRlcikge1xuICAgICAgICAgICAgICBpZiAoJHRvLm5vZGVBZnRlci5pc1RleHRibG9jaykge1xuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICR0by5wb3MgKyAxKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHRvLm5vZGVBZnRlci5pc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJHRvLnBvcykpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICR0by5wb3MpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZVR5cGUgPSBjaGFpblN0YXRlLnNjaGVtYS5ub2Rlc1t0aGlzLm9wdGlvbnMubmV4dE5vZGVUeXBlXSB8fCAkdG8ucGFyZW50LnR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlO1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZVR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGVUeXBlLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRyLmluc2VydChwb3NBZnRlciwgbm9kZSk7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9zQWZ0ZXIgKyAxKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KS5ydW4oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBub2RlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogL14oPzotLS184oCULXxfX19cXHN8XFwqXFwqXFwqXFxzKSQvLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBIb3Jpem9udGFsUnVsZTtcbmV4cG9ydCB7XG4gIEhvcml6b250YWxSdWxlLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-italic/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Italic: () => (/* binding */ Italic),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/italic.ts\n\nvar starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/;\nvar starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g;\nvar underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/;\nvar underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g;\nvar Italic = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"italic\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"em\"\n      },\n      {\n        tag: \"i\",\n        getAttrs: (node) => node.style.fontStyle !== \"normal\" && null\n      },\n      {\n        style: \"font-style=normal\",\n        clearMark: (mark) => mark.type.name === this.name\n      },\n      {\n        style: \"font-style=italic\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"em\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setItalic: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleItalic: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetItalic: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  markdownTokenName: \"em\",\n  parseMarkdown: (token, helpers) => {\n    return helpers.applyMark(\"italic\", helpers.parseInline(token.tokens || []));\n  },\n  renderMarkdown: (node, h) => {\n    return `*${h.renderChildren(node)}*`;\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-i\": () => this.editor.commands.toggleItalic(),\n      \"Mod-I\": () => this.editor.commands.toggleItalic()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: starInputRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: underscoreInputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: starPasteRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: underscorePasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Italic;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taXRhbGljL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ21GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4Q0FBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZSxnQkFBZ0I7QUFDL0Isa0JBQWtCLDZEQUFlO0FBQ2pDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQSxPQUFPO0FBQ1AsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFRRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FuYmFucHJvLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWl0YWxpYy9kaXN0L2luZGV4LmpzP2VkYzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2l0YWxpYy50c1xuaW1wb3J0IHsgTWFyaywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIHN0YXJJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShcXCooPyFcXHMrXFwqKSgoPzpbXipdKykpXFwqKD8hXFxzK1xcKikpJC87XG52YXIgc3RhclBhc3RlUmVnZXggPSAvKD86XnxcXHMpKFxcKig/IVxccytcXCopKCg/OlteKl0rKSlcXCooPyFcXHMrXFwqKSkvZztcbnZhciB1bmRlcnNjb3JlSW5wdXRSZWdleCA9IC8oPzpefFxccykoXyg/IVxccytfKSgoPzpbXl9dKykpXyg/IVxccytfKSkkLztcbnZhciB1bmRlcnNjb3JlUGFzdGVSZWdleCA9IC8oPzpefFxccykoXyg/IVxccytfKSgoPzpbXl9dKykpXyg/IVxccytfKSkvZztcbnZhciBJdGFsaWMgPSBNYXJrLmNyZWF0ZSh7XG4gIG5hbWU6IFwiaXRhbGljXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwiZW1cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImlcIixcbiAgICAgICAgZ2V0QXR0cnM6IChub2RlKSA9PiBub2RlLnN0eWxlLmZvbnRTdHlsZSAhPT0gXCJub3JtYWxcIiAmJiBudWxsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogXCJmb250LXN0eWxlPW5vcm1hbFwiLFxuICAgICAgICBjbGVhck1hcms6IChtYXJrKSA9PiBtYXJrLnR5cGUubmFtZSA9PT0gdGhpcy5uYW1lXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogXCJmb250LXN0eWxlPWl0YWxpY1wiXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1wiZW1cIiwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEl0YWxpYzogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZUl0YWxpYzogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHVuc2V0SXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBtYXJrZG93blRva2VuTmFtZTogXCJlbVwiLFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGhlbHBlcnMpID0+IHtcbiAgICByZXR1cm4gaGVscGVycy5hcHBseU1hcmsoXCJpdGFsaWNcIiwgaGVscGVycy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMgfHwgW10pKTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgcmV0dXJuIGAqJHtoLnJlbmRlckNoaWxkcmVuKG5vZGUpfSpgO1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtaVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVJdGFsaWMoKSxcbiAgICAgIFwiTW9kLUlcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSXRhbGljKClcbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogc3RhcklucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSksXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9LFxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogc3RhclBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSksXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZVBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IEl0YWxpYztcbmV4cG9ydCB7XG4gIEl0YWxpYyxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0LFxuICBzdGFySW5wdXRSZWdleCxcbiAgc3RhclBhc3RlUmVnZXgsXG4gIHVuZGVyc2NvcmVJbnB1dFJlZ2V4LFxuICB1bmRlcnNjb3JlUGFzdGVSZWdleFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-link/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-link/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   isAllowedUri: () => (/* binding */ isAllowedUri),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var linkifyjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! linkifyjs */ \"(ssr)/./node_modules/linkifyjs/dist/linkify.mjs\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n// src/link.ts\n\n\n\n// src/helpers/autolink.ts\n\n\n\n\n// src/helpers/whitespace.ts\nvar UNICODE_WHITESPACE_PATTERN = \"[\\0- \\xA0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]\";\nvar UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN);\nvar UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`);\nvar UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, \"g\");\n\n// src/helpers/autolink.ts\nfunction isValidLinkStructure(tokens) {\n  if (tokens.length === 1) {\n    return tokens[0].isLink;\n  }\n  if (tokens.length === 3 && tokens[1].isLink) {\n    return [\"()\", \"[]\"].includes(tokens[0].value + tokens[2].value);\n  }\n  return false;\n}\nfunction autolink(options) {\n  return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n    key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"autolink\"),\n    appendTransaction: (transactions, oldState, newState) => {\n      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n      const preventAutolink = transactions.some((transaction) => transaction.getMeta(\"preventAutolink\"));\n      if (!docChanges || preventAutolink) {\n        return;\n      }\n      const { tr } = newState;\n      const transform = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.combineTransactionSteps)(oldState.doc, [...transactions]);\n      const changes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getChangedRanges)(transform);\n      changes.forEach(({ newRange }) => {\n        const nodesInChangedRanges = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildrenInRange)(newState.doc, newRange, (node) => node.isTextblock);\n        let textBlock;\n        let textBeforeWhitespace;\n        if (nodesInChangedRanges.length > 1) {\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            textBlock.pos + textBlock.node.nodeSize,\n            void 0,\n            \" \"\n          );\n        } else if (nodesInChangedRanges.length) {\n          const endText = newState.doc.textBetween(newRange.from, newRange.to, \" \", \" \");\n          if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {\n            return;\n          }\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, \" \");\n        }\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean);\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false;\n          }\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n          if (!lastWordBeforeSpace) {\n            return false;\n          }\n          const linksBeforeSpace = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.tokenize)(lastWordBeforeSpace).map((t) => t.toObject(options.defaultProtocol));\n          if (!isValidLinkStructure(linksBeforeSpace)) {\n            return false;\n          }\n          linksBeforeSpace.filter((link) => link.isLink).map((link) => ({\n            ...link,\n            from: lastWordAndBlockOffset + link.start + 1,\n            to: lastWordAndBlockOffset + link.end + 1\n          })).filter((link) => {\n            if (!newState.schema.marks.code) {\n              return true;\n            }\n            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);\n          }).filter((link) => options.validate(link.value)).filter((link) => options.shouldAutoLink(link.value)).forEach((link) => {\n            if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarksBetween)(link.from, link.to, newState.doc).some((item) => item.mark.type === options.type)) {\n              return;\n            }\n            tr.addMark(\n              link.from,\n              link.to,\n              options.type.create({\n                href: link.href\n              })\n            );\n          });\n        }\n      });\n      if (!tr.steps.length) {\n        return;\n      }\n      return tr;\n    }\n  });\n}\n\n// src/helpers/clickHandler.ts\n\n\nfunction clickHandler(options) {\n  return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n    key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"handleClickLink\"),\n    props: {\n      handleClick: (view, pos, event) => {\n        var _a, _b;\n        if (event.button !== 0) {\n          return false;\n        }\n        if (!view.editable) {\n          return false;\n        }\n        let link = null;\n        if (event.target instanceof HTMLAnchorElement) {\n          link = event.target;\n        } else {\n          let a = event.target;\n          const els = [];\n          while (a.nodeName !== \"DIV\") {\n            els.push(a);\n            a = a.parentNode;\n          }\n          link = els.find((value) => value.nodeName === \"A\");\n        }\n        if (!link) {\n          return false;\n        }\n        const attrs = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributes)(view.state, options.type.name);\n        const href = (_a = link == null ? void 0 : link.href) != null ? _a : attrs.href;\n        const target = (_b = link == null ? void 0 : link.target) != null ? _b : attrs.target;\n        if (options.enableClickSelection) {\n          options.editor.commands.extendMarkRange(options.type.name);\n        }\n        if (link && href) {\n          window.open(href, target);\n          return true;\n        }\n        return false;\n      }\n    }\n  });\n}\n\n// src/helpers/pasteHandler.ts\n\n\nfunction pasteHandler(options) {\n  return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n    key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"handlePasteLink\"),\n    props: {\n      handlePaste: (view, _event, slice) => {\n        const { shouldAutoLink } = options;\n        const { state } = view;\n        const { selection } = state;\n        const { empty } = selection;\n        if (empty) {\n          return false;\n        }\n        let textContent = \"\";\n        slice.content.forEach((node) => {\n          textContent += node.textContent;\n        });\n        const link = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(textContent, { defaultProtocol: options.defaultProtocol }).find(\n          (item) => item.isLink && item.value === textContent\n        );\n        if (!textContent || !link || shouldAutoLink !== void 0 && !shouldAutoLink(link.href)) {\n          return false;\n        }\n        return options.editor.commands.setMark(options.type, {\n          href: link.href\n        });\n      }\n    }\n  });\n}\n\n// src/link.ts\nvar pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;\nfunction isAllowedUri(uri, protocols) {\n  const allowedProtocols = [\"http\", \"https\", \"ftp\", \"ftps\", \"mailto\", \"tel\", \"callto\", \"sms\", \"cid\", \"xmpp\"];\n  if (protocols) {\n    protocols.forEach((protocol) => {\n      const nextProtocol = typeof protocol === \"string\" ? protocol : protocol.scheme;\n      if (nextProtocol) {\n        allowedProtocols.push(nextProtocol);\n      }\n    });\n  }\n  return !uri || uri.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, \"\").match(\n    new RegExp(\n      // eslint-disable-next-line no-useless-escape\n      `^(?:(?:${allowedProtocols.join(\"|\")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,\n      \"i\"\n    )\n  );\n}\nvar Link = _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Mark.create({\n  name: \"link\",\n  priority: 1e3,\n  keepOnSplit: false,\n  exitable: true,\n  onCreate() {\n    if (this.options.validate && !this.options.shouldAutoLink) {\n      this.options.shouldAutoLink = this.options.validate;\n      console.warn(\"The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.\");\n    }\n    this.options.protocols.forEach((protocol) => {\n      if (typeof protocol === \"string\") {\n        (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.registerCustomProtocol)(protocol);\n        return;\n      }\n      (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.registerCustomProtocol)(protocol.scheme, protocol.optionalSlashes);\n    });\n  },\n  onDestroy() {\n    (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.reset)();\n  },\n  inclusive() {\n    return this.options.autolink;\n  },\n  addOptions() {\n    return {\n      openOnClick: true,\n      enableClickSelection: false,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      defaultProtocol: \"http\",\n      HTMLAttributes: {\n        target: \"_blank\",\n        rel: \"noopener noreferrer nofollow\",\n        class: null\n      },\n      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),\n      validate: (url) => !!url,\n      shouldAutoLink: (url) => !!url\n    };\n  },\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n        parseHTML(element) {\n          return element.getAttribute(\"href\");\n        }\n      },\n      target: {\n        default: this.options.HTMLAttributes.target\n      },\n      rel: {\n        default: this.options.HTMLAttributes.rel\n      },\n      class: {\n        default: this.options.HTMLAttributes.class\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"a[href]\",\n        getAttrs: (dom) => {\n          const href = dom.getAttribute(\"href\");\n          if (!href || !this.options.isAllowedUri(href, {\n            defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),\n            protocols: this.options.protocols,\n            defaultProtocol: this.options.defaultProtocol\n          })) {\n            return false;\n          }\n          return null;\n        }\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    if (!this.options.isAllowedUri(HTMLAttributes.href, {\n      defaultValidate: (href) => !!isAllowedUri(href, this.options.protocols),\n      protocols: this.options.protocols,\n      defaultProtocol: this.options.defaultProtocol\n    })) {\n      return [\"a\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, { ...HTMLAttributes, href: \"\" }), 0];\n    }\n    return [\"a\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"link\",\n  parseMarkdown: (token, helpers) => {\n    return helpers.applyMark(\"link\", helpers.parseInline(token.tokens || []), {\n      href: token.href,\n      title: token.title || null\n    });\n  },\n  renderMarkdown: (node, h) => {\n    var _a;\n    const href = ((_a = node.attrs) == null ? void 0 : _a.href) || \"\";\n    const text = h.renderChildren(node);\n    return `[${text}](${href})`;\n  },\n  addCommands() {\n    return {\n      setLink: (attributes) => ({ chain }) => {\n        const { href } = attributes;\n        if (!this.options.isAllowedUri(href, {\n          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),\n          protocols: this.options.protocols,\n          defaultProtocol: this.options.defaultProtocol\n        })) {\n          return false;\n        }\n        return chain().setMark(this.name, attributes).setMeta(\"preventAutolink\", true).run();\n      },\n      toggleLink: (attributes) => ({ chain }) => {\n        const { href } = attributes || {};\n        if (href && !this.options.isAllowedUri(href, {\n          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),\n          protocols: this.options.protocols,\n          defaultProtocol: this.options.defaultProtocol\n        })) {\n          return false;\n        }\n        return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta(\"preventAutolink\", true).run();\n      },\n      unsetLink: () => ({ chain }) => {\n        return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta(\"preventAutolink\", true).run();\n      }\n    };\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markPasteRule)({\n        find: (text) => {\n          const foundLinks = [];\n          if (text) {\n            const { protocols, defaultProtocol } = this.options;\n            const links = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(text).filter(\n              (item) => item.isLink && this.options.isAllowedUri(item.value, {\n                defaultValidate: (href) => !!isAllowedUri(href, protocols),\n                protocols,\n                defaultProtocol\n              })\n            );\n            if (links.length) {\n              links.forEach((link) => {\n                if (!this.options.shouldAutoLink(link.value)) {\n                  return;\n                }\n                foundLinks.push({\n                  text: link.value,\n                  data: {\n                    href: link.href\n                  },\n                  index: link.start\n                });\n              });\n            }\n          }\n          return foundLinks;\n        },\n        type: this.type,\n        getAttributes: (match) => {\n          var _a;\n          return {\n            href: (_a = match.data) == null ? void 0 : _a.href\n          };\n        }\n      })\n    ];\n  },\n  addProseMirrorPlugins() {\n    const plugins = [];\n    const { protocols, defaultProtocol } = this.options;\n    if (this.options.autolink) {\n      plugins.push(\n        autolink({\n          type: this.type,\n          defaultProtocol: this.options.defaultProtocol,\n          validate: (url) => this.options.isAllowedUri(url, {\n            defaultValidate: (href) => !!isAllowedUri(href, protocols),\n            protocols,\n            defaultProtocol\n          }),\n          shouldAutoLink: this.options.shouldAutoLink\n        })\n      );\n    }\n    if (this.options.openOnClick === true) {\n      plugins.push(\n        clickHandler({\n          type: this.type,\n          editor: this.editor,\n          enableClickSelection: this.options.enableClickSelection\n        })\n      );\n    }\n    if (this.options.linkOnPaste) {\n      plugins.push(\n        pasteHandler({\n          editor: this.editor,\n          defaultProtocol: this.options.defaultProtocol,\n          type: this.type,\n          shouldAutoLink: this.options.shouldAutoLink\n        })\n      );\n    }\n    return plugins;\n  }\n});\n\n// src/index.ts\nvar index_default = Link;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNvRTtBQUNLOztBQUV6RTtBQUMrRztBQUMxRDtBQUNoQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJCQUEyQjtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvREFBTTtBQUNuQixhQUFhLHVEQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQix3QkFBd0IscUVBQXVCO0FBQy9DLHNCQUFzQiw4REFBZ0I7QUFDdEMseUJBQXlCLFVBQVU7QUFDbkMscUNBQXFDLGlFQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1EQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGdCQUFnQiw2REFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQzZDO0FBQ2lDO0FBQzlFO0FBQ0EsYUFBYSxvREFBTztBQUNwQixhQUFhLHVEQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYW5iYW5wcm8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9kaXN0L2luZGV4LmpzP2FlNjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xpbmsudHNcbmltcG9ydCB7IE1hcmssIG1hcmtQYXN0ZVJ1bGUsIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IGZpbmQgYXMgZmluZDIsIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wsIHJlc2V0IH0gZnJvbSBcImxpbmtpZnlqc1wiO1xuXG4vLyBzcmMvaGVscGVycy9hdXRvbGluay50c1xuaW1wb3J0IHsgY29tYmluZVRyYW5zYWN0aW9uU3RlcHMsIGZpbmRDaGlsZHJlbkluUmFuZ2UsIGdldENoYW5nZWRSYW5nZXMsIGdldE1hcmtzQmV0d2VlbiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmltcG9ydCB7IHRva2VuaXplIH0gZnJvbSBcImxpbmtpZnlqc1wiO1xuXG4vLyBzcmMvaGVscGVycy93aGl0ZXNwYWNlLnRzXG52YXIgVU5JQ09ERV9XSElURVNQQUNFX1BBVFRFUk4gPSBcIltcXDAtIFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMjlcXHUyMDVGXFx1MzAwMF1cIjtcbnZhciBVTklDT0RFX1dISVRFU1BBQ0VfUkVHRVggPSBuZXcgUmVnRXhwKFVOSUNPREVfV0hJVEVTUEFDRV9QQVRURVJOKTtcbnZhciBVTklDT0RFX1dISVRFU1BBQ0VfUkVHRVhfRU5EID0gbmV3IFJlZ0V4cChgJHtVTklDT0RFX1dISVRFU1BBQ0VfUEFUVEVSTn0kYCk7XG52YXIgVU5JQ09ERV9XSElURVNQQUNFX1JFR0VYX0dMT0JBTCA9IG5ldyBSZWdFeHAoVU5JQ09ERV9XSElURVNQQUNFX1BBVFRFUk4sIFwiZ1wiKTtcblxuLy8gc3JjL2hlbHBlcnMvYXV0b2xpbmsudHNcbmZ1bmN0aW9uIGlzVmFsaWRMaW5rU3RydWN0dXJlKHRva2Vucykge1xuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0b2tlbnNbMF0uaXNMaW5rO1xuICB9XG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAzICYmIHRva2Vuc1sxXS5pc0xpbmspIHtcbiAgICByZXR1cm4gW1wiKClcIiwgXCJbXVwiXS5pbmNsdWRlcyh0b2tlbnNbMF0udmFsdWUgKyB0b2tlbnNbMl0udmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGF1dG9saW5rKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgIGtleTogbmV3IFBsdWdpbktleShcImF1dG9saW5rXCIpLFxuICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSB0cmFuc2FjdGlvbnMuc29tZSgodHJhbnNhY3Rpb24pID0+IHRyYW5zYWN0aW9uLmRvY0NoYW5nZWQpICYmICFvbGRTdGF0ZS5kb2MuZXEobmV3U3RhdGUuZG9jKTtcbiAgICAgIGNvbnN0IHByZXZlbnRBdXRvbGluayA9IHRyYW5zYWN0aW9ucy5zb21lKCh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24uZ2V0TWV0YShcInByZXZlbnRBdXRvbGlua1wiKSk7XG4gICAgICBpZiAoIWRvY0NoYW5nZXMgfHwgcHJldmVudEF1dG9saW5rKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdHIgfSA9IG5ld1N0YXRlO1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gY29tYmluZVRyYW5zYWN0aW9uU3RlcHMob2xkU3RhdGUuZG9jLCBbLi4udHJhbnNhY3Rpb25zXSk7XG4gICAgICBjb25zdCBjaGFuZ2VzID0gZ2V0Q2hhbmdlZFJhbmdlcyh0cmFuc2Zvcm0pO1xuICAgICAgY2hhbmdlcy5mb3JFYWNoKCh7IG5ld1JhbmdlIH0pID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZXNJbkNoYW5nZWRSYW5nZXMgPSBmaW5kQ2hpbGRyZW5JblJhbmdlKG5ld1N0YXRlLmRvYywgbmV3UmFuZ2UsIChub2RlKSA9PiBub2RlLmlzVGV4dGJsb2NrKTtcbiAgICAgICAgbGV0IHRleHRCbG9jaztcbiAgICAgICAgbGV0IHRleHRCZWZvcmVXaGl0ZXNwYWNlO1xuICAgICAgICBpZiAobm9kZXNJbkNoYW5nZWRSYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRleHRCbG9jayA9IG5vZGVzSW5DaGFuZ2VkUmFuZ2VzWzBdO1xuICAgICAgICAgIHRleHRCZWZvcmVXaGl0ZXNwYWNlID0gbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKFxuICAgICAgICAgICAgdGV4dEJsb2NrLnBvcyxcbiAgICAgICAgICAgIHRleHRCbG9jay5wb3MgKyB0ZXh0QmxvY2subm9kZS5ub2RlU2l6ZSxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIFwiIFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2Rlc0luQ2hhbmdlZFJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBlbmRUZXh0ID0gbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKG5ld1JhbmdlLmZyb20sIG5ld1JhbmdlLnRvLCBcIiBcIiwgXCIgXCIpO1xuICAgICAgICAgIGlmICghVU5JQ09ERV9XSElURVNQQUNFX1JFR0VYX0VORC50ZXN0KGVuZFRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHRCbG9jayA9IG5vZGVzSW5DaGFuZ2VkUmFuZ2VzWzBdO1xuICAgICAgICAgIHRleHRCZWZvcmVXaGl0ZXNwYWNlID0gbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKHRleHRCbG9jay5wb3MsIG5ld1JhbmdlLnRvLCB2b2lkIDAsIFwiIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dEJsb2NrICYmIHRleHRCZWZvcmVXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgY29uc3Qgd29yZHNCZWZvcmVXaGl0ZXNwYWNlID0gdGV4dEJlZm9yZVdoaXRlc3BhY2Uuc3BsaXQoVU5JQ09ERV9XSElURVNQQUNFX1JFR0VYKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgICAgaWYgKHdvcmRzQmVmb3JlV2hpdGVzcGFjZS5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBsYXN0V29yZEJlZm9yZVNwYWNlID0gd29yZHNCZWZvcmVXaGl0ZXNwYWNlW3dvcmRzQmVmb3JlV2hpdGVzcGFjZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBjb25zdCBsYXN0V29yZEFuZEJsb2NrT2Zmc2V0ID0gdGV4dEJsb2NrLnBvcyArIHRleHRCZWZvcmVXaGl0ZXNwYWNlLmxhc3RJbmRleE9mKGxhc3RXb3JkQmVmb3JlU3BhY2UpO1xuICAgICAgICAgIGlmICghbGFzdFdvcmRCZWZvcmVTcGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBsaW5rc0JlZm9yZVNwYWNlID0gdG9rZW5pemUobGFzdFdvcmRCZWZvcmVTcGFjZSkubWFwKCh0KSA9PiB0LnRvT2JqZWN0KG9wdGlvbnMuZGVmYXVsdFByb3RvY29sKSk7XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkTGlua1N0cnVjdHVyZShsaW5rc0JlZm9yZVNwYWNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaW5rc0JlZm9yZVNwYWNlLmZpbHRlcigobGluaykgPT4gbGluay5pc0xpbmspLm1hcCgobGluaykgPT4gKHtcbiAgICAgICAgICAgIC4uLmxpbmssXG4gICAgICAgICAgICBmcm9tOiBsYXN0V29yZEFuZEJsb2NrT2Zmc2V0ICsgbGluay5zdGFydCArIDEsXG4gICAgICAgICAgICB0bzogbGFzdFdvcmRBbmRCbG9ja09mZnNldCArIGxpbmsuZW5kICsgMVxuICAgICAgICAgIH0pKS5maWx0ZXIoKGxpbmspID0+IHtcbiAgICAgICAgICAgIGlmICghbmV3U3RhdGUuc2NoZW1hLm1hcmtzLmNvZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIW5ld1N0YXRlLmRvYy5yYW5nZUhhc01hcmsobGluay5mcm9tLCBsaW5rLnRvLCBuZXdTdGF0ZS5zY2hlbWEubWFya3MuY29kZSk7XG4gICAgICAgICAgfSkuZmlsdGVyKChsaW5rKSA9PiBvcHRpb25zLnZhbGlkYXRlKGxpbmsudmFsdWUpKS5maWx0ZXIoKGxpbmspID0+IG9wdGlvbnMuc2hvdWxkQXV0b0xpbmsobGluay52YWx1ZSkpLmZvckVhY2goKGxpbmspID0+IHtcbiAgICAgICAgICAgIGlmIChnZXRNYXJrc0JldHdlZW4obGluay5mcm9tLCBsaW5rLnRvLCBuZXdTdGF0ZS5kb2MpLnNvbWUoKGl0ZW0pID0+IGl0ZW0ubWFyay50eXBlID09PSBvcHRpb25zLnR5cGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgIGxpbmsuZnJvbSxcbiAgICAgICAgICAgICAgbGluay50byxcbiAgICAgICAgICAgICAgb3B0aW9ucy50eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgaHJlZjogbGluay5ocmVmXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cjtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvaGVscGVycy9jbGlja0hhbmRsZXIudHNcbmltcG9ydCB7IGdldEF0dHJpYnV0ZXMgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luMiwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTIgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuZnVuY3Rpb24gY2xpY2tIYW5kbGVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQbHVnaW4yKHtcbiAgICBrZXk6IG5ldyBQbHVnaW5LZXkyKFwiaGFuZGxlQ2xpY2tMaW5rXCIpLFxuICAgIHByb3BzOiB7XG4gICAgICBoYW5kbGVDbGljazogKHZpZXcsIHBvcywgZXZlbnQpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZpZXcuZWRpdGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmsgPSBudWxsO1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQpIHtcbiAgICAgICAgICBsaW5rID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBhID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgIGNvbnN0IGVscyA9IFtdO1xuICAgICAgICAgIHdoaWxlIChhLm5vZGVOYW1lICE9PSBcIkRJVlwiKSB7XG4gICAgICAgICAgICBlbHMucHVzaChhKTtcbiAgICAgICAgICAgIGEgPSBhLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbmsgPSBlbHMuZmluZCgodmFsdWUpID0+IHZhbHVlLm5vZGVOYW1lID09PSBcIkFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJzID0gZ2V0QXR0cmlidXRlcyh2aWV3LnN0YXRlLCBvcHRpb25zLnR5cGUubmFtZSk7XG4gICAgICAgIGNvbnN0IGhyZWYgPSAoX2EgPSBsaW5rID09IG51bGwgPyB2b2lkIDAgOiBsaW5rLmhyZWYpICE9IG51bGwgPyBfYSA6IGF0dHJzLmhyZWY7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IChfYiA9IGxpbmsgPT0gbnVsbCA/IHZvaWQgMCA6IGxpbmsudGFyZ2V0KSAhPSBudWxsID8gX2IgOiBhdHRycy50YXJnZXQ7XG4gICAgICAgIGlmIChvcHRpb25zLmVuYWJsZUNsaWNrU2VsZWN0aW9uKSB7XG4gICAgICAgICAgb3B0aW9ucy5lZGl0b3IuY29tbWFuZHMuZXh0ZW5kTWFya1JhbmdlKG9wdGlvbnMudHlwZS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluayAmJiBocmVmKSB7XG4gICAgICAgICAgd2luZG93Lm9wZW4oaHJlZiwgdGFyZ2V0KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvcGFzdGVIYW5kbGVyLnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luMywgUGx1Z2luS2V5IGFzIFBsdWdpbktleTMgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgZmluZCB9IGZyb20gXCJsaW5raWZ5anNcIjtcbmZ1bmN0aW9uIHBhc3RlSGFuZGxlcihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUGx1Z2luMyh7XG4gICAga2V5OiBuZXcgUGx1Z2luS2V5MyhcImhhbmRsZVBhc3RlTGlua1wiKSxcbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlUGFzdGU6ICh2aWV3LCBfZXZlbnQsIHNsaWNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2hvdWxkQXV0b0xpbmsgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgc2xpY2UuY29udGVudC5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgKz0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGxpbmsgPSBmaW5kKHRleHRDb250ZW50LCB7IGRlZmF1bHRQcm90b2NvbDogb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgfSkuZmluZChcbiAgICAgICAgICAoaXRlbSkgPT4gaXRlbS5pc0xpbmsgJiYgaXRlbS52YWx1ZSA9PT0gdGV4dENvbnRlbnRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCF0ZXh0Q29udGVudCB8fCAhbGluayB8fCBzaG91bGRBdXRvTGluayAhPT0gdm9pZCAwICYmICFzaG91bGRBdXRvTGluayhsaW5rLmhyZWYpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zLmVkaXRvci5jb21tYW5kcy5zZXRNYXJrKG9wdGlvbnMudHlwZSwge1xuICAgICAgICAgIGhyZWY6IGxpbmsuaHJlZlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbGluay50c1xudmFyIHBhc3RlUmVnZXggPSAvaHR0cHM/OlxcL1xcLyg/Ond3d1xcLik/Wy1hLXpBLVowLTlAOiUuXyt+Iz1dezEsMjU2fVxcLlthLXpBLVpdezIsfVxcYig/OlstYS16QS1aMC05QDolLl8rfiM9PyEmL10qKSg/OlstYS16QS1aMC05QDolLl8rfiM9PyEmL10qKS9naTtcbmZ1bmN0aW9uIGlzQWxsb3dlZFVyaSh1cmksIHByb3RvY29scykge1xuICBjb25zdCBhbGxvd2VkUHJvdG9jb2xzID0gW1wiaHR0cFwiLCBcImh0dHBzXCIsIFwiZnRwXCIsIFwiZnRwc1wiLCBcIm1haWx0b1wiLCBcInRlbFwiLCBcImNhbGx0b1wiLCBcInNtc1wiLCBcImNpZFwiLCBcInhtcHBcIl07XG4gIGlmIChwcm90b2NvbHMpIHtcbiAgICBwcm90b2NvbHMuZm9yRWFjaCgocHJvdG9jb2wpID0+IHtcbiAgICAgIGNvbnN0IG5leHRQcm90b2NvbCA9IHR5cGVvZiBwcm90b2NvbCA9PT0gXCJzdHJpbmdcIiA/IHByb3RvY29sIDogcHJvdG9jb2wuc2NoZW1lO1xuICAgICAgaWYgKG5leHRQcm90b2NvbCkge1xuICAgICAgICBhbGxvd2VkUHJvdG9jb2xzLnB1c2gobmV4dFByb3RvY29sKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gIXVyaSB8fCB1cmkucmVwbGFjZShVTklDT0RFX1dISVRFU1BBQ0VfUkVHRVhfR0xPQkFMLCBcIlwiKS5tYXRjaChcbiAgICBuZXcgUmVnRXhwKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgICBgXig/Oig/OiR7YWxsb3dlZFByb3RvY29scy5qb2luKFwifFwiKX0pOnxbXmEtel18W2EtejAtOSsuLV0rKD86W15hLXorLi06XXwkKSlgLFxuICAgICAgXCJpXCJcbiAgICApXG4gICk7XG59XG52YXIgTGluayA9IE1hcmsuY3JlYXRlKHtcbiAgbmFtZTogXCJsaW5rXCIsXG4gIHByaW9yaXR5OiAxZTMsXG4gIGtlZXBPblNwbGl0OiBmYWxzZSxcbiAgZXhpdGFibGU6IHRydWUsXG4gIG9uQ3JlYXRlKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmFsaWRhdGUgJiYgIXRoaXMub3B0aW9ucy5zaG91bGRBdXRvTGluaykge1xuICAgICAgdGhpcy5vcHRpb25zLnNob3VsZEF1dG9MaW5rID0gdGhpcy5vcHRpb25zLnZhbGlkYXRlO1xuICAgICAgY29uc29sZS53YXJuKFwiVGhlIGB2YWxpZGF0ZWAgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFJlbmFtZSB0byB0aGUgYHNob3VsZEF1dG9MaW5rYCBvcHRpb24gaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucy5wcm90b2NvbHMuZm9yRWFjaCgocHJvdG9jb2wpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2wgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbChwcm90b2NvbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wocHJvdG9jb2wuc2NoZW1lLCBwcm90b2NvbC5vcHRpb25hbFNsYXNoZXMpO1xuICAgIH0pO1xuICB9LFxuICBvbkRlc3Ryb3koKSB7XG4gICAgcmVzZXQoKTtcbiAgfSxcbiAgaW5jbHVzaXZlKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXV0b2xpbms7XG4gIH0sXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZW5PbkNsaWNrOiB0cnVlLFxuICAgICAgZW5hYmxlQ2xpY2tTZWxlY3Rpb246IGZhbHNlLFxuICAgICAgbGlua09uUGFzdGU6IHRydWUsXG4gICAgICBhdXRvbGluazogdHJ1ZSxcbiAgICAgIHByb3RvY29sczogW10sXG4gICAgICBkZWZhdWx0UHJvdG9jb2w6IFwiaHR0cFwiLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlciBub2ZvbGxvd1wiLFxuICAgICAgICBjbGFzczogbnVsbFxuICAgICAgfSxcbiAgICAgIGlzQWxsb3dlZFVyaTogKHVybCwgY3R4KSA9PiAhIWlzQWxsb3dlZFVyaSh1cmwsIGN0eC5wcm90b2NvbHMpLFxuICAgICAgdmFsaWRhdGU6ICh1cmwpID0+ICEhdXJsLFxuICAgICAgc2hvdWxkQXV0b0xpbms6ICh1cmwpID0+ICEhdXJsXG4gICAgfTtcbiAgfSxcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaHJlZjoge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUwoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0YXJnZXQ6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLnRhcmdldFxuICAgICAgfSxcbiAgICAgIHJlbDoge1xuICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMucmVsXG4gICAgICB9LFxuICAgICAgY2xhc3M6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLmNsYXNzXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJhW2hyZWZdXCIsXG4gICAgICAgIGdldEF0dHJzOiAoZG9tKSA9PiB7XG4gICAgICAgICAgY29uc3QgaHJlZiA9IGRvbS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgICAgICAgIGlmICghaHJlZiB8fCAhdGhpcy5vcHRpb25zLmlzQWxsb3dlZFVyaShocmVmLCB7XG4gICAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6ICh1cmwpID0+ICEhaXNBbGxvd2VkVXJpKHVybCwgdGhpcy5vcHRpb25zLnByb3RvY29scyksXG4gICAgICAgICAgICBwcm90b2NvbHM6IHRoaXMub3B0aW9ucy5wcm90b2NvbHMsXG4gICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2xcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKEhUTUxBdHRyaWJ1dGVzLmhyZWYsIHtcbiAgICAgIGRlZmF1bHRWYWxpZGF0ZTogKGhyZWYpID0+ICEhaXNBbGxvd2VkVXJpKGhyZWYsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgcHJvdG9jb2xzOiB0aGlzLm9wdGlvbnMucHJvdG9jb2xzLFxuICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sXG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBbXCJhXCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIHsgLi4uSFRNTEF0dHJpYnV0ZXMsIGhyZWY6IFwiXCIgfSksIDBdO1xuICAgIH1cbiAgICByZXR1cm4gW1wiYVwiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBtYXJrZG93blRva2VuTmFtZTogXCJsaW5rXCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIHJldHVybiBoZWxwZXJzLmFwcGx5TWFyayhcImxpbmtcIiwgaGVscGVycy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMgfHwgW10pLCB7XG4gICAgICBocmVmOiB0b2tlbi5ocmVmLFxuICAgICAgdGl0bGU6IHRva2VuLnRpdGxlIHx8IG51bGxcbiAgICB9KTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGhyZWYgPSAoKF9hID0gbm9kZS5hdHRycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmhyZWYpIHx8IFwiXCI7XG4gICAgY29uc3QgdGV4dCA9IGgucmVuZGVyQ2hpbGRyZW4obm9kZSk7XG4gICAgcmV0dXJuIGBbJHt0ZXh0fV0oJHtocmVmfSlgO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0TGluazogKGF0dHJpYnV0ZXMpID0+ICh7IGNoYWluIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyBocmVmIH0gPSBhdHRyaWJ1dGVzO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoaHJlZiwge1xuICAgICAgICAgIGRlZmF1bHRWYWxpZGF0ZTogKHVybCkgPT4gISFpc0FsbG93ZWRVcmkodXJsLCB0aGlzLm9wdGlvbnMucHJvdG9jb2xzKSxcbiAgICAgICAgICBwcm90b2NvbHM6IHRoaXMub3B0aW9ucy5wcm90b2NvbHMsXG4gICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFpbigpLnNldE1hcmsodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKS5zZXRNZXRhKFwicHJldmVudEF1dG9saW5rXCIsIHRydWUpLnJ1bigpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZUxpbms6IChhdHRyaWJ1dGVzKSA9PiAoeyBjaGFpbiB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgaHJlZiB9ID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICAgICAgaWYgKGhyZWYgJiYgIXRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoaHJlZiwge1xuICAgICAgICAgIGRlZmF1bHRWYWxpZGF0ZTogKHVybCkgPT4gISFpc0FsbG93ZWRVcmkodXJsLCB0aGlzLm9wdGlvbnMucHJvdG9jb2xzKSxcbiAgICAgICAgICBwcm90b2NvbHM6IHRoaXMub3B0aW9ucy5wcm90b2NvbHMsXG4gICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFpbigpLnRvZ2dsZU1hcmsodGhpcy5uYW1lLCBhdHRyaWJ1dGVzLCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlOiB0cnVlIH0pLnNldE1ldGEoXCJwcmV2ZW50QXV0b2xpbmtcIiwgdHJ1ZSkucnVuKCk7XG4gICAgICB9LFxuICAgICAgdW5zZXRMaW5rOiAoKSA9PiAoeyBjaGFpbiB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjaGFpbigpLnVuc2V0TWFyayh0aGlzLm5hbWUsIHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2U6IHRydWUgfSkuc2V0TWV0YShcInByZXZlbnRBdXRvbGlua1wiLCB0cnVlKS5ydW4oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogKHRleHQpID0+IHtcbiAgICAgICAgICBjb25zdCBmb3VuZExpbmtzID0gW107XG4gICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvdG9jb2xzLCBkZWZhdWx0UHJvdG9jb2wgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gZmluZDIodGV4dCkuZmlsdGVyKFxuICAgICAgICAgICAgICAoaXRlbSkgPT4gaXRlbS5pc0xpbmsgJiYgdGhpcy5vcHRpb25zLmlzQWxsb3dlZFVyaShpdGVtLnZhbHVlLCB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiAoaHJlZikgPT4gISFpc0FsbG93ZWRVcmkoaHJlZiwgcHJvdG9jb2xzKSxcbiAgICAgICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBsaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvdWxkQXV0b0xpbmsobGluay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm91bmRMaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxpbmsudmFsdWUsXG4gICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IGxpbmsuaHJlZlxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGluZGV4OiBsaW5rLnN0YXJ0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZm91bmRMaW5rcztcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiAobWF0Y2gpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhyZWY6IChfYSA9IG1hdGNoLmRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYS5ocmVmXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgY29uc3QgcGx1Z2lucyA9IFtdO1xuICAgIGNvbnN0IHsgcHJvdG9jb2xzLCBkZWZhdWx0UHJvdG9jb2wgfSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9saW5rKSB7XG4gICAgICBwbHVnaW5zLnB1c2goXG4gICAgICAgIGF1dG9saW5rKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sLFxuICAgICAgICAgIHZhbGlkYXRlOiAodXJsKSA9PiB0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKHVybCwge1xuICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiAoaHJlZikgPT4gISFpc0FsbG93ZWRVcmkoaHJlZiwgcHJvdG9jb2xzKSxcbiAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgIGRlZmF1bHRQcm90b2NvbFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHNob3VsZEF1dG9MaW5rOiB0aGlzLm9wdGlvbnMuc2hvdWxkQXV0b0xpbmtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub3Blbk9uQ2xpY2sgPT09IHRydWUpIHtcbiAgICAgIHBsdWdpbnMucHVzaChcbiAgICAgICAgY2xpY2tIYW5kbGVyKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICBlbmFibGVDbGlja1NlbGVjdGlvbjogdGhpcy5vcHRpb25zLmVuYWJsZUNsaWNrU2VsZWN0aW9uXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpbmtPblBhc3RlKSB7XG4gICAgICBwbHVnaW5zLnB1c2goXG4gICAgICAgIHBhc3RlSGFuZGxlcih7XG4gICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wsXG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIHNob3VsZEF1dG9MaW5rOiB0aGlzLm9wdGlvbnMuc2hvdWxkQXV0b0xpbmtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBwbHVnaW5zO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IExpbms7XG5leHBvcnQge1xuICBMaW5rLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGlzQWxsb3dlZFVyaSxcbiAgcGFzdGVSZWdleFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-link/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-list-item/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-list-item/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListItem: () => (/* reexport safe */ _tiptap_extension_list__WEBPACK_IMPORTED_MODULE_0__.ListItem),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_extension_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-list */ \"(ssr)/./node_modules/@tiptap/extension-list/dist/index.js\");\n// src/index.ts\n\n\nvar index_default = _tiptap_extension_list__WEBPACK_IMPORTED_MODULE_0__.ListItem;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC1pdGVtL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDa0Q7QUFDYTtBQUMvRCxvQkFBb0IsNERBQVE7QUFJMUI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2thbmJhbnByby8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saXN0LWl0ZW0vZGlzdC9pbmRleC5qcz80OWY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgTGlzdEl0ZW0gfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tbGlzdFwiO1xuaW1wb3J0IHsgTGlzdEl0ZW0gYXMgTGlzdEl0ZW0yIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWxpc3RcIjtcbnZhciBpbmRleF9kZWZhdWx0ID0gTGlzdEl0ZW07XG5leHBvcnQge1xuICBMaXN0SXRlbTIgYXMgTGlzdEl0ZW0sXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-list-item/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-list/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-list/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BulletList: () => (/* binding */ BulletList),\n/* harmony export */   ListItem: () => (/* binding */ ListItem),\n/* harmony export */   ListKeymap: () => (/* binding */ ListKeymap),\n/* harmony export */   ListKit: () => (/* binding */ ListKit),\n/* harmony export */   OrderedList: () => (/* binding */ OrderedList),\n/* harmony export */   TaskItem: () => (/* binding */ TaskItem),\n/* harmony export */   TaskList: () => (/* binding */ TaskList),\n/* harmony export */   bulletListInputRegex: () => (/* binding */ bulletListInputRegex),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   listHelpers: () => (/* binding */ listHelpers_exports),\n/* harmony export */   orderedListInputRegex: () => (/* binding */ orderedListInputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/bullet-list/bullet-list.ts\n\nvar ListItemName = \"listItem\";\nvar TextStyleName = \"textStyle\";\nvar bulletListInputRegex = /^\\s*([-+*])\\s$/;\nvar BulletList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"bulletList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [{ tag: \"ul\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"ul\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"list\",\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== \"list\" || token.ordered) {\n      return [];\n    }\n    return {\n      type: \"bulletList\",\n      content: token.items ? helpers.parseChildren(token.items) : []\n    };\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return h.renderChildren(node.content, \"\\n\");\n  },\n  markdownOptions: {\n    indentsContent: true\n  },\n  addCommands() {\n    return {\n      toggleBulletList: () => ({ commands, chain }) => {\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-8\": () => this.editor.commands.toggleBulletList()\n    };\n  },\n  addInputRules() {\n    let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n      find: bulletListInputRegex,\n      type: this.type\n    });\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName);\n        },\n        editor: this.editor\n      });\n    }\n    return [inputRule];\n  }\n});\n\n// src/item/list-item.ts\n\nvar ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"listItem\",\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: \"bulletList\",\n      orderedListTypeName: \"orderedList\"\n    };\n  },\n  content: \"paragraph block*\",\n  defining: true,\n  parseHTML() {\n    return [\n      {\n        tag: \"li\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"li\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"list_item\",\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== \"list_item\") {\n      return [];\n    }\n    let content = [];\n    if (token.tokens && token.tokens.length > 0) {\n      const hasParagraphTokens = token.tokens.some((t) => t.type === \"paragraph\");\n      if (hasParagraphTokens) {\n        content = helpers.parseChildren(token.tokens);\n      } else {\n        const firstToken = token.tokens[0];\n        if (firstToken && firstToken.type === \"text\" && firstToken.tokens && firstToken.tokens.length > 0) {\n          const inlineContent = helpers.parseInline(firstToken.tokens);\n          content = [\n            {\n              type: \"paragraph\",\n              content: inlineContent\n            }\n          ];\n          if (token.tokens.length > 1) {\n            const remainingTokens = token.tokens.slice(1);\n            const additionalContent = helpers.parseChildren(remainingTokens);\n            content.push(...additionalContent);\n          }\n        } else {\n          content = helpers.parseChildren(token.tokens);\n        }\n      }\n    }\n    if (content.length === 0) {\n      content = [\n        {\n          type: \"paragraph\",\n          content: []\n        }\n      ];\n    }\n    return {\n      type: \"listItem\",\n      content\n    };\n  },\n  renderMarkdown: (node, h, ctx) => {\n    return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.renderNestedMarkdownContent)(\n      node,\n      h,\n      (context) => {\n        if (context.parentType === \"bulletList\") {\n          return \"- \";\n        }\n        if (context.parentType === \"orderedList\") {\n          return `${context.index + 1}. `;\n        }\n        return \"- \";\n      },\n      ctx\n    );\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n  }\n});\n\n// src/keymap/list-keymap.ts\n\n\n// src/keymap/listHelpers/index.ts\nvar listHelpers_exports = {};\n__export(listHelpers_exports, {\n  findListItemPos: () => findListItemPos,\n  getNextListDepth: () => getNextListDepth,\n  handleBackspace: () => handleBackspace,\n  handleDelete: () => handleDelete,\n  hasListBefore: () => hasListBefore,\n  hasListItemAfter: () => hasListItemAfter,\n  hasListItemBefore: () => hasListItemBefore,\n  listItemHasSubList: () => listItemHasSubList,\n  nextListIsDeeper: () => nextListIsDeeper,\n  nextListIsHigher: () => nextListIsHigher\n});\n\n// src/keymap/listHelpers/findListItemPos.ts\n\nvar findListItemPos = (typeOrName, state) => {\n  const { $from } = state.selection;\n  const nodeType = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeType)(typeOrName, state.schema);\n  let currentNode = null;\n  let currentDepth = $from.depth;\n  let currentPos = $from.pos;\n  let targetDepth = null;\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth);\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth;\n    } else {\n      currentDepth -= 1;\n      currentPos -= 1;\n    }\n  }\n  if (targetDepth === null) {\n    return null;\n  }\n  return { $pos: state.doc.resolve(currentPos), depth: targetDepth };\n};\n\n// src/keymap/listHelpers/getNextListDepth.ts\n\nvar getNextListDepth = (typeOrName, state) => {\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos) {\n    return false;\n  }\n  const [, depth] = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeAtPosition)(state, typeOrName, listItemPos.$pos.pos + 4);\n  return depth;\n};\n\n// src/keymap/listHelpers/handleBackspace.ts\n\n\n// src/keymap/listHelpers/hasListBefore.ts\nvar hasListBefore = (editorState, name, parentListTypes) => {\n  const { $anchor } = editorState.selection;\n  const previousNodePos = Math.max(0, $anchor.pos - 2);\n  const previousNode = editorState.doc.resolve(previousNodePos).node();\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/listHelpers/hasListItemBefore.ts\nvar hasListItemBefore = (typeOrName, state) => {\n  var _a;\n  const { $anchor } = state.selection;\n  const $targetPos = state.doc.resolve($anchor.pos - 2);\n  if ($targetPos.index() === 0) {\n    return false;\n  }\n  if (((_a = $targetPos.nodeBefore) == null ? void 0 : _a.type.name) !== typeOrName) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/listHelpers/listItemHasSubList.ts\n\nvar listItemHasSubList = (typeOrName, state, node) => {\n  if (!node) {\n    return false;\n  }\n  const nodeType = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeType)(typeOrName, state.schema);\n  let hasSubList = false;\n  node.descendants((child) => {\n    if (child.type === nodeType) {\n      hasSubList = true;\n    }\n  });\n  return hasSubList;\n};\n\n// src/keymap/listHelpers/handleBackspace.ts\nvar handleBackspace = (editor, name, parentListTypes) => {\n  if (editor.commands.undoInputRule()) {\n    return true;\n  }\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false;\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const { $anchor } = editor.state.selection;\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1);\n    const listDescendants = [];\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({ node, pos });\n      }\n    });\n    const lastItem = listDescendants.at(-1);\n    if (!lastItem) {\n      return false;\n    }\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1);\n    return editor.chain().cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end()).joinForward().run();\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name)) {\n    return false;\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isAtStartOfNode)(editor.state)) {\n    return false;\n  }\n  const listItemPos = findListItemPos(name, editor.state);\n  if (!listItemPos) {\n    return false;\n  }\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2);\n  const prevNode = $prev.node(listItemPos.depth);\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode);\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward();\n  }\n  return editor.chain().liftListItem(name).run();\n};\n\n// src/keymap/listHelpers/handleDelete.ts\n\n\n// src/keymap/listHelpers/nextListIsDeeper.ts\nvar nextListIsDeeper = (typeOrName, state) => {\n  const listDepth = getNextListDepth(typeOrName, state);\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos || !listDepth) {\n    return false;\n  }\n  if (listDepth > listItemPos.depth) {\n    return true;\n  }\n  return false;\n};\n\n// src/keymap/listHelpers/nextListIsHigher.ts\nvar nextListIsHigher = (typeOrName, state) => {\n  const listDepth = getNextListDepth(typeOrName, state);\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos || !listDepth) {\n    return false;\n  }\n  if (listDepth < listItemPos.depth) {\n    return true;\n  }\n  return false;\n};\n\n// src/keymap/listHelpers/handleDelete.ts\nvar handleDelete = (editor, name) => {\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name)) {\n    return false;\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isAtEndOfNode)(editor.state, name)) {\n    return false;\n  }\n  const { selection } = editor.state;\n  const { $from, $to } = selection;\n  if (!selection.empty && $from.sameParent($to)) {\n    return false;\n  }\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor.chain().focus(editor.state.selection.from + 4).lift(name).joinBackward().run();\n  }\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run();\n  }\n  return editor.commands.joinItemForward();\n};\n\n// src/keymap/listHelpers/hasListItemAfter.ts\nvar hasListItemAfter = (typeOrName, state) => {\n  var _a;\n  const { $anchor } = state.selection;\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2);\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false;\n  }\n  if (((_a = $targetPos.nodeAfter) == null ? void 0 : _a.type.name) !== typeOrName) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/list-keymap.ts\nvar ListKeymap = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n  name: \"listKeymap\",\n  addOptions() {\n    return {\n      listTypes: [\n        {\n          itemName: \"listItem\",\n          wrapperNames: [\"bulletList\", \"orderedList\"]\n        },\n        {\n          itemName: \"taskItem\",\n          wrapperNames: [\"taskList\"]\n        }\n      ]\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleDelete(editor, itemName)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      \"Mod-Delete\": ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleDelete(editor, itemName)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      Backspace: ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      \"Mod-Backspace\": ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true;\n          }\n        });\n        return handled;\n      }\n    };\n  }\n});\n\n// src/kit/index.ts\n\n\n// src/ordered-list/ordered-list.ts\n\n\n// src/ordered-list/utils.ts\nvar ORDERED_LIST_ITEM_REGEX = /^(\\s*)(\\d+)\\.\\s+(.*)$/;\nvar INDENTED_LINE_REGEX = /^\\s/;\nfunction collectOrderedListItems(lines) {\n  const listItems = [];\n  let currentLineIndex = 0;\n  let consumed = 0;\n  while (currentLineIndex < lines.length) {\n    const line = lines[currentLineIndex];\n    const match = line.match(ORDERED_LIST_ITEM_REGEX);\n    if (!match) {\n      break;\n    }\n    const [, indent, number, content] = match;\n    const indentLevel = indent.length;\n    let itemContent = content;\n    let nextLineIndex = currentLineIndex + 1;\n    const itemLines = [line];\n    while (nextLineIndex < lines.length) {\n      const nextLine = lines[nextLineIndex];\n      const nextMatch = nextLine.match(ORDERED_LIST_ITEM_REGEX);\n      if (nextMatch) {\n        break;\n      }\n      if (nextLine.trim() === \"\") {\n        itemLines.push(nextLine);\n        itemContent += \"\\n\";\n        nextLineIndex += 1;\n      } else if (nextLine.match(INDENTED_LINE_REGEX)) {\n        itemLines.push(nextLine);\n        itemContent += `\n${nextLine.slice(indentLevel + 2)}`;\n        nextLineIndex += 1;\n      } else {\n        break;\n      }\n    }\n    listItems.push({\n      indent: indentLevel,\n      number: parseInt(number, 10),\n      content: itemContent.trim(),\n      raw: itemLines.join(\"\\n\")\n    });\n    consumed = nextLineIndex;\n    currentLineIndex = nextLineIndex;\n  }\n  return [listItems, consumed];\n}\nfunction buildNestedStructure(items, baseIndent, lexer) {\n  var _a;\n  const result = [];\n  let currentIndex = 0;\n  while (currentIndex < items.length) {\n    const item = items[currentIndex];\n    if (item.indent === baseIndent) {\n      const contentLines = item.content.split(\"\\n\");\n      const mainText = ((_a = contentLines[0]) == null ? void 0 : _a.trim()) || \"\";\n      const tokens = [];\n      if (mainText) {\n        tokens.push({\n          type: \"paragraph\",\n          raw: mainText,\n          tokens: lexer.inlineTokens(mainText)\n        });\n      }\n      const additionalContent = contentLines.slice(1).join(\"\\n\").trim();\n      if (additionalContent) {\n        const blockTokens = lexer.blockTokens(additionalContent);\n        tokens.push(...blockTokens);\n      }\n      let lookAheadIndex = currentIndex + 1;\n      const nestedItems = [];\n      while (lookAheadIndex < items.length && items[lookAheadIndex].indent > baseIndent) {\n        nestedItems.push(items[lookAheadIndex]);\n        lookAheadIndex += 1;\n      }\n      if (nestedItems.length > 0) {\n        const nextIndent = Math.min(...nestedItems.map((nestedItem) => nestedItem.indent));\n        const nestedListItems = buildNestedStructure(nestedItems, nextIndent, lexer);\n        tokens.push({\n          type: \"list\",\n          ordered: true,\n          start: nestedItems[0].number,\n          items: nestedListItems,\n          raw: nestedItems.map((nestedItem) => nestedItem.raw).join(\"\\n\")\n        });\n      }\n      result.push({\n        type: \"list_item\",\n        raw: item.raw,\n        tokens\n      });\n      currentIndex = lookAheadIndex;\n    } else {\n      currentIndex += 1;\n    }\n  }\n  return result;\n}\nfunction parseListItems(items, helpers) {\n  return items.map((item) => {\n    if (item.type !== \"list_item\") {\n      return helpers.parseChildren([item])[0];\n    }\n    const content = [];\n    if (item.tokens && item.tokens.length > 0) {\n      item.tokens.forEach((itemToken) => {\n        if (itemToken.type === \"paragraph\" || itemToken.type === \"list\" || itemToken.type === \"blockquote\" || itemToken.type === \"code\") {\n          content.push(...helpers.parseChildren([itemToken]));\n        } else if (itemToken.type === \"text\" && itemToken.tokens) {\n          const inlineContent = helpers.parseChildren([itemToken]);\n          content.push({\n            type: \"paragraph\",\n            content: inlineContent\n          });\n        } else {\n          const parsed = helpers.parseChildren([itemToken]);\n          if (parsed.length > 0) {\n            content.push(...parsed);\n          }\n        }\n      });\n    }\n    return {\n      type: \"listItem\",\n      content\n    };\n  });\n}\n\n// src/ordered-list/ordered-list.ts\nvar ListItemName2 = \"listItem\";\nvar TextStyleName2 = \"textStyle\";\nvar orderedListInputRegex = /^(\\d+)\\.\\s$/;\nvar OrderedList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"orderedList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: (element) => {\n          return element.hasAttribute(\"start\") ? parseInt(element.getAttribute(\"start\") || \"\", 10) : 1;\n        }\n      },\n      type: {\n        default: null,\n        parseHTML: (element) => element.getAttribute(\"type\")\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"ol\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes;\n    return start === 1 ? [\"ol\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, attributesWithoutStart), 0] : [\"ol\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"list\",\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== \"list\" || !token.ordered) {\n      return [];\n    }\n    const startValue = token.start || 1;\n    const content = token.items ? parseListItems(token.items, helpers) : [];\n    if (startValue !== 1) {\n      return {\n        type: \"orderedList\",\n        attrs: { start: startValue },\n        content\n      };\n    }\n    return {\n      type: \"orderedList\",\n      content\n    };\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return h.renderChildren(node.content, \"\\n\");\n  },\n  markdownTokenizer: {\n    name: \"orderedList\",\n    level: \"block\",\n    start: (src) => {\n      const match = src.match(/^(\\s*)(\\d+)\\.\\s+/);\n      const index = match == null ? void 0 : match.index;\n      return index !== void 0 ? index : -1;\n    },\n    tokenize: (src, _tokens, lexer) => {\n      var _a;\n      const lines = src.split(\"\\n\");\n      const [listItems, consumed] = collectOrderedListItems(lines);\n      if (listItems.length === 0) {\n        return void 0;\n      }\n      const items = buildNestedStructure(listItems, 0, lexer);\n      if (items.length === 0) {\n        return void 0;\n      }\n      const startValue = ((_a = listItems[0]) == null ? void 0 : _a.number) || 1;\n      return {\n        type: \"list\",\n        ordered: true,\n        start: startValue,\n        items,\n        raw: lines.slice(0, consumed).join(\"\\n\")\n      };\n    }\n  },\n  markdownOptions: {\n    indentsContent: true\n  },\n  addCommands() {\n    return {\n      toggleOrderedList: () => ({ commands, chain }) => {\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-7\": () => this.editor.commands.toggleOrderedList()\n    };\n  },\n  addInputRules() {\n    let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: (match) => ({ start: +match[1] }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]\n    });\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName2) }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor\n      });\n    }\n    return [inputRule];\n  }\n});\n\n// src/task-item/task-item.ts\n\nvar inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/;\nvar TaskItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"taskItem\",\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: \"taskList\",\n      a11y: void 0\n    };\n  },\n  content() {\n    return this.options.nested ? \"paragraph block*\" : \"paragraph+\";\n  },\n  defining: true,\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: (element) => {\n          const dataChecked = element.getAttribute(\"data-checked\");\n          return dataChecked === \"\" || dataChecked === \"true\";\n        },\n        renderHTML: (attributes) => ({\n          \"data-checked\": attributes.checked\n        })\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: `li[data-type=\"${this.name}\"]`,\n        priority: 51\n      }\n    ];\n  },\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      \"li\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, {\n        \"data-type\": this.name\n      }),\n      [\n        \"label\",\n        [\n          \"input\",\n          {\n            type: \"checkbox\",\n            checked: node.attrs.checked ? \"checked\" : null\n          }\n        ],\n        [\"span\"]\n      ],\n      [\"div\", 0]\n    ];\n  },\n  parseMarkdown: (token, h) => {\n    const content = [];\n    if (token.tokens && token.tokens.length > 0) {\n      content.push(h.createNode(\"paragraph\", {}, h.parseInline(token.tokens)));\n    } else if (token.text) {\n      content.push(h.createNode(\"paragraph\", {}, [h.createNode(\"text\", { text: token.text })]));\n    } else {\n      content.push(h.createNode(\"paragraph\", {}, []));\n    }\n    if (token.nestedTokens && token.nestedTokens.length > 0) {\n      const nestedContent = h.parseChildren(token.nestedTokens);\n      content.push(...nestedContent);\n    }\n    return h.createNode(\"taskItem\", { checked: token.checked || false }, content);\n  },\n  renderMarkdown: (node, h) => {\n    var _a;\n    const checkedChar = ((_a = node.attrs) == null ? void 0 : _a.checked) ? \"x\" : \" \";\n    const prefix = `- [${checkedChar}] `;\n    return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.renderNestedMarkdownContent)(node, h, prefix);\n  },\n  addKeyboardShortcuts() {\n    const shortcuts = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n    if (!this.options.nested) {\n      return shortcuts;\n    }\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name)\n    };\n  },\n  addNodeView() {\n    return ({ node, HTMLAttributes, getPos, editor }) => {\n      const listItem = document.createElement(\"li\");\n      const checkboxWrapper = document.createElement(\"label\");\n      const checkboxStyler = document.createElement(\"span\");\n      const checkbox = document.createElement(\"input\");\n      const content = document.createElement(\"div\");\n      const updateA11Y = (currentNode) => {\n        var _a, _b;\n        checkbox.ariaLabel = ((_b = (_a = this.options.a11y) == null ? void 0 : _a.checkboxLabel) == null ? void 0 : _b.call(_a, currentNode, checkbox.checked)) || `Task item checkbox for ${currentNode.textContent || \"empty task item\"}`;\n      };\n      updateA11Y(node);\n      checkboxWrapper.contentEditable = \"false\";\n      checkbox.type = \"checkbox\";\n      checkbox.addEventListener(\"mousedown\", (event) => event.preventDefault());\n      checkbox.addEventListener(\"change\", (event) => {\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked;\n          return;\n        }\n        const { checked } = event.target;\n        if (editor.isEditable && typeof getPos === \"function\") {\n          editor.chain().focus(void 0, { scrollIntoView: false }).command(({ tr }) => {\n            const position = getPos();\n            if (typeof position !== \"number\") {\n              return false;\n            }\n            const currentNode = tr.doc.nodeAt(position);\n            tr.setNodeMarkup(position, void 0, {\n              ...currentNode == null ? void 0 : currentNode.attrs,\n              checked\n            });\n            return true;\n          }).run();\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked;\n          }\n        }\n      });\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value);\n      });\n      listItem.dataset.checked = node.attrs.checked;\n      checkbox.checked = node.attrs.checked;\n      checkboxWrapper.append(checkbox, checkboxStyler);\n      listItem.append(checkboxWrapper, content);\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value);\n      });\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: (updatedNode) => {\n          if (updatedNode.type !== this.type) {\n            return false;\n          }\n          listItem.dataset.checked = updatedNode.attrs.checked;\n          checkbox.checked = updatedNode.attrs.checked;\n          updateA11Y(updatedNode);\n          return true;\n        }\n      };\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: (match) => ({\n          checked: match[match.length - 1] === \"x\"\n        })\n      })\n    ];\n  }\n});\n\n// src/task-list/task-list.ts\n\nvar TaskList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"taskList\",\n  addOptions() {\n    return {\n      itemTypeName: \"taskItem\",\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [\n      {\n        tag: `ul[data-type=\"${this.name}\"]`,\n        priority: 51\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"ul\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, { \"data-type\": this.name }), 0];\n  },\n  parseMarkdown: (token, h) => {\n    return h.createNode(\"taskList\", {}, h.parseChildren(token.items || []));\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return h.renderChildren(node.content, \"\\n\");\n  },\n  markdownTokenizer: {\n    name: \"taskList\",\n    level: \"block\",\n    start(src) {\n      var _a;\n      const index = (_a = src.match(/^\\s*[-+*]\\s+\\[([ xX])\\]\\s+/)) == null ? void 0 : _a.index;\n      return index !== void 0 ? index : -1;\n    },\n    tokenize(src, tokens, lexer) {\n      const parseTaskListContent = (content) => {\n        const nestedResult = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.parseIndentedBlocks)(\n          content,\n          {\n            itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n            extractItemData: (match) => ({\n              indentLevel: match[1].length,\n              mainContent: match[4],\n              checked: match[3].toLowerCase() === \"x\"\n            }),\n            createToken: (data, nestedTokens) => ({\n              type: \"taskItem\",\n              raw: \"\",\n              mainContent: data.mainContent,\n              indentLevel: data.indentLevel,\n              checked: data.checked,\n              text: data.mainContent,\n              tokens: lexer.inlineTokens(data.mainContent),\n              nestedTokens\n            }),\n            // Allow recursive nesting\n            customNestedParser: parseTaskListContent\n          },\n          lexer\n        );\n        if (nestedResult) {\n          return [\n            {\n              type: \"taskList\",\n              raw: nestedResult.raw,\n              items: nestedResult.items\n            }\n          ];\n        }\n        return lexer.blockTokens(content);\n      };\n      const result = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.parseIndentedBlocks)(\n        src,\n        {\n          itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n          extractItemData: (match) => ({\n            indentLevel: match[1].length,\n            mainContent: match[4],\n            checked: match[3].toLowerCase() === \"x\"\n          }),\n          createToken: (data, nestedTokens) => ({\n            type: \"taskItem\",\n            raw: \"\",\n            mainContent: data.mainContent,\n            indentLevel: data.indentLevel,\n            checked: data.checked,\n            text: data.mainContent,\n            tokens: lexer.inlineTokens(data.mainContent),\n            nestedTokens\n          }),\n          // Use the recursive parser for nested content\n          customNestedParser: parseTaskListContent\n        },\n        lexer\n      );\n      if (!result) {\n        return void 0;\n      }\n      return {\n        type: \"taskList\",\n        raw: result.raw,\n        items: result.items\n      };\n    }\n  },\n  markdownOptions: {\n    indentsContent: true\n  },\n  addCommands() {\n    return {\n      toggleTaskList: () => ({ commands }) => {\n        return commands.toggleList(this.name, this.options.itemTypeName);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-9\": () => this.editor.commands.toggleTaskList()\n    };\n  }\n});\n\n// src/kit/index.ts\nvar ListKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n  name: \"listKit\",\n  addExtensions() {\n    const extensions = [];\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList));\n    }\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem));\n    }\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap));\n    }\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList));\n    }\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem));\n    }\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList));\n    }\n    return extensions;\n  }\n});\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEMsR0FBRztBQUNIO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQixrQkFBa0IsNkRBQWU7QUFDakMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CLCtEQUFpQjtBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWtCLCtEQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUMrRztBQUMvRyxlQUFlLDhDQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQixrQkFBa0IsNkRBQWdCO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlFQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsbURBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFhQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FuYmFucHJvLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3QvZGlzdC9pbmRleC5qcz81MzkxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy9idWxsZXQtbGlzdC9idWxsZXQtbGlzdC50c1xuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB3cmFwcGluZ0lucHV0UnVsZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBMaXN0SXRlbU5hbWUgPSBcImxpc3RJdGVtXCI7XG52YXIgVGV4dFN0eWxlTmFtZSA9IFwidGV4dFN0eWxlXCI7XG52YXIgYnVsbGV0TGlzdElucHV0UmVnZXggPSAvXlxccyooWy0rKl0pXFxzJC87XG52YXIgQnVsbGV0TGlzdCA9IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogXCJidWxsZXRMaXN0XCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1UeXBlTmFtZTogXCJsaXN0SXRlbVwiLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAga2VlcE1hcmtzOiBmYWxzZSxcbiAgICAgIGtlZXBBdHRyaWJ1dGVzOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGdyb3VwOiBcImJsb2NrIGxpc3RcIixcbiAgY29udGVudCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZX0rYDtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6IFwidWxcIiB9XTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1widWxcIiwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgfSxcbiAgbWFya2Rvd25Ub2tlbk5hbWU6IFwibGlzdFwiLFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGhlbHBlcnMpID0+IHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gXCJsaXN0XCIgfHwgdG9rZW4ub3JkZXJlZCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJidWxsZXRMaXN0XCIsXG4gICAgICBjb250ZW50OiB0b2tlbi5pdGVtcyA/IGhlbHBlcnMucGFyc2VDaGlsZHJlbih0b2tlbi5pdGVtcykgOiBbXVxuICAgIH07XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaCkgPT4ge1xuICAgIGlmICghbm9kZS5jb250ZW50KSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGgucmVuZGVyQ2hpbGRyZW4obm9kZS5jb250ZW50LCBcIlxcblwiKTtcbiAgfSxcbiAgbWFya2Rvd25PcHRpb25zOiB7XG4gICAgaW5kZW50c0NvbnRlbnQ6IHRydWVcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvZ2dsZUJ1bGxldExpc3Q6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiB9KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oKS50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcykudXBkYXRlQXR0cmlidXRlcyhMaXN0SXRlbU5hbWUsIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZSkpLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLVNoaWZ0LThcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQnVsbGV0TGlzdCgpXG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICBsZXQgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgZmluZDogYnVsbGV0TGlzdElucHV0UmVnZXgsXG4gICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICB9KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBNYXJrcyB8fCB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogYnVsbGV0TGlzdElucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAga2VlcE1hcmtzOiB0aGlzLm9wdGlvbnMua2VlcE1hcmtzLFxuICAgICAgICBrZWVwQXR0cmlidXRlczogdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW2lucHV0UnVsZV07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaXRlbS9saXN0LWl0ZW0udHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcyBhcyBtZXJnZUF0dHJpYnV0ZXMyLCBOb2RlIGFzIE5vZGUyLCByZW5kZXJOZXN0ZWRNYXJrZG93bkNvbnRlbnQgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgTGlzdEl0ZW0gPSBOb2RlMi5jcmVhdGUoe1xuICBuYW1lOiBcImxpc3RJdGVtXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGJ1bGxldExpc3RUeXBlTmFtZTogXCJidWxsZXRMaXN0XCIsXG4gICAgICBvcmRlcmVkTGlzdFR5cGVOYW1lOiBcIm9yZGVyZWRMaXN0XCJcbiAgICB9O1xuICB9LFxuICBjb250ZW50OiBcInBhcmFncmFwaCBibG9jaypcIixcbiAgZGVmaW5pbmc6IHRydWUsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwibGlcIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcImxpXCIsIG1lcmdlQXR0cmlidXRlczIodGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBtYXJrZG93blRva2VuTmFtZTogXCJsaXN0X2l0ZW1cIixcbiAgcGFyc2VNYXJrZG93bjogKHRva2VuLCBoZWxwZXJzKSA9PiB7XG4gICAgaWYgKHRva2VuLnR5cGUgIT09IFwibGlzdF9pdGVtXCIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSBbXTtcbiAgICBpZiAodG9rZW4udG9rZW5zICYmIHRva2VuLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBoYXNQYXJhZ3JhcGhUb2tlbnMgPSB0b2tlbi50b2tlbnMuc29tZSgodCkgPT4gdC50eXBlID09PSBcInBhcmFncmFwaFwiKTtcbiAgICAgIGlmIChoYXNQYXJhZ3JhcGhUb2tlbnMpIHtcbiAgICAgICAgY29udGVudCA9IGhlbHBlcnMucGFyc2VDaGlsZHJlbih0b2tlbi50b2tlbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmlyc3RUb2tlbiA9IHRva2VuLnRva2Vuc1swXTtcbiAgICAgICAgaWYgKGZpcnN0VG9rZW4gJiYgZmlyc3RUb2tlbi50eXBlID09PSBcInRleHRcIiAmJiBmaXJzdFRva2VuLnRva2VucyAmJiBmaXJzdFRva2VuLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgaW5saW5lQ29udGVudCA9IGhlbHBlcnMucGFyc2VJbmxpbmUoZmlyc3RUb2tlbi50b2tlbnMpO1xuICAgICAgICAgIGNvbnRlbnQgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGlubGluZUNvbnRlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdO1xuICAgICAgICAgIGlmICh0b2tlbi50b2tlbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nVG9rZW5zID0gdG9rZW4udG9rZW5zLnNsaWNlKDEpO1xuICAgICAgICAgICAgY29uc3QgYWRkaXRpb25hbENvbnRlbnQgPSBoZWxwZXJzLnBhcnNlQ2hpbGRyZW4ocmVtYWluaW5nVG9rZW5zKTtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaCguLi5hZGRpdGlvbmFsQ29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRlbnQgPSBoZWxwZXJzLnBhcnNlQ2hpbGRyZW4odG9rZW4udG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRlbnQgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcInBhcmFncmFwaFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFtdXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxpc3RJdGVtXCIsXG4gICAgICBjb250ZW50XG4gICAgfTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoLCBjdHgpID0+IHtcbiAgICByZXR1cm4gcmVuZGVyTmVzdGVkTWFya2Rvd25Db250ZW50KFxuICAgICAgbm9kZSxcbiAgICAgIGgsXG4gICAgICAoY29udGV4dCkgPT4ge1xuICAgICAgICBpZiAoY29udGV4dC5wYXJlbnRUeXBlID09PSBcImJ1bGxldExpc3RcIikge1xuICAgICAgICAgIHJldHVybiBcIi0gXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQucGFyZW50VHlwZSA9PT0gXCJvcmRlcmVkTGlzdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGAke2NvbnRleHQuaW5kZXggKyAxfS4gYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCItIFwiO1xuICAgICAgfSxcbiAgICAgIGN0eFxuICAgICk7XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBFbnRlcjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc3BsaXRMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgVGFiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zaW5rTGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgIFwiU2hpZnQtVGFiXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmxpZnRMaXN0SXRlbSh0aGlzLm5hbWUpXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9rZXltYXAvbGlzdC1rZXltYXAudHNcbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9pbmRleC50c1xudmFyIGxpc3RIZWxwZXJzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGxpc3RIZWxwZXJzX2V4cG9ydHMsIHtcbiAgZmluZExpc3RJdGVtUG9zOiAoKSA9PiBmaW5kTGlzdEl0ZW1Qb3MsXG4gIGdldE5leHRMaXN0RGVwdGg6ICgpID0+IGdldE5leHRMaXN0RGVwdGgsXG4gIGhhbmRsZUJhY2tzcGFjZTogKCkgPT4gaGFuZGxlQmFja3NwYWNlLFxuICBoYW5kbGVEZWxldGU6ICgpID0+IGhhbmRsZURlbGV0ZSxcbiAgaGFzTGlzdEJlZm9yZTogKCkgPT4gaGFzTGlzdEJlZm9yZSxcbiAgaGFzTGlzdEl0ZW1BZnRlcjogKCkgPT4gaGFzTGlzdEl0ZW1BZnRlcixcbiAgaGFzTGlzdEl0ZW1CZWZvcmU6ICgpID0+IGhhc0xpc3RJdGVtQmVmb3JlLFxuICBsaXN0SXRlbUhhc1N1Ykxpc3Q6ICgpID0+IGxpc3RJdGVtSGFzU3ViTGlzdCxcbiAgbmV4dExpc3RJc0RlZXBlcjogKCkgPT4gbmV4dExpc3RJc0RlZXBlcixcbiAgbmV4dExpc3RJc0hpZ2hlcjogKCkgPT4gbmV4dExpc3RJc0hpZ2hlclxufSk7XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvZmluZExpc3RJdGVtUG9zLnRzXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBmaW5kTGlzdEl0ZW1Qb3MgPSAodHlwZU9yTmFtZSwgc3RhdGUpID0+IHtcbiAgY29uc3QgeyAkZnJvbSB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCBub2RlVHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGxldCBjdXJyZW50Tm9kZSA9IG51bGw7XG4gIGxldCBjdXJyZW50RGVwdGggPSAkZnJvbS5kZXB0aDtcbiAgbGV0IGN1cnJlbnRQb3MgPSAkZnJvbS5wb3M7XG4gIGxldCB0YXJnZXREZXB0aCA9IG51bGw7XG4gIHdoaWxlIChjdXJyZW50RGVwdGggPiAwICYmIHRhcmdldERlcHRoID09PSBudWxsKSB7XG4gICAgY3VycmVudE5vZGUgPSAkZnJvbS5ub2RlKGN1cnJlbnREZXB0aCk7XG4gICAgaWYgKGN1cnJlbnROb2RlLnR5cGUgPT09IG5vZGVUeXBlKSB7XG4gICAgICB0YXJnZXREZXB0aCA9IGN1cnJlbnREZXB0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudERlcHRoIC09IDE7XG4gICAgICBjdXJyZW50UG9zIC09IDE7XG4gICAgfVxuICB9XG4gIGlmICh0YXJnZXREZXB0aCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7ICRwb3M6IHN0YXRlLmRvYy5yZXNvbHZlKGN1cnJlbnRQb3MpLCBkZXB0aDogdGFyZ2V0RGVwdGggfTtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvZ2V0TmV4dExpc3REZXB0aC50c1xuaW1wb3J0IHsgZ2V0Tm9kZUF0UG9zaXRpb24gfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgZ2V0TmV4dExpc3REZXB0aCA9ICh0eXBlT3JOYW1lLCBzdGF0ZSkgPT4ge1xuICBjb25zdCBsaXN0SXRlbVBvcyA9IGZpbmRMaXN0SXRlbVBvcyh0eXBlT3JOYW1lLCBzdGF0ZSk7XG4gIGlmICghbGlzdEl0ZW1Qb3MpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgWywgZGVwdGhdID0gZ2V0Tm9kZUF0UG9zaXRpb24oc3RhdGUsIHR5cGVPck5hbWUsIGxpc3RJdGVtUG9zLiRwb3MucG9zICsgNCk7XG4gIHJldHVybiBkZXB0aDtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvaGFuZGxlQmFja3NwYWNlLnRzXG5pbXBvcnQgeyBpc0F0U3RhcnRPZk5vZGUsIGlzTm9kZUFjdGl2ZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9oYXNMaXN0QmVmb3JlLnRzXG52YXIgaGFzTGlzdEJlZm9yZSA9IChlZGl0b3JTdGF0ZSwgbmFtZSwgcGFyZW50TGlzdFR5cGVzKSA9PiB7XG4gIGNvbnN0IHsgJGFuY2hvciB9ID0gZWRpdG9yU3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCBwcmV2aW91c05vZGVQb3MgPSBNYXRoLm1heCgwLCAkYW5jaG9yLnBvcyAtIDIpO1xuICBjb25zdCBwcmV2aW91c05vZGUgPSBlZGl0b3JTdGF0ZS5kb2MucmVzb2x2ZShwcmV2aW91c05vZGVQb3MpLm5vZGUoKTtcbiAgaWYgKCFwcmV2aW91c05vZGUgfHwgIXBhcmVudExpc3RUeXBlcy5pbmNsdWRlcyhwcmV2aW91c05vZGUudHlwZS5uYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvaGFzTGlzdEl0ZW1CZWZvcmUudHNcbnZhciBoYXNMaXN0SXRlbUJlZm9yZSA9ICh0eXBlT3JOYW1lLCBzdGF0ZSkgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IHsgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCAkdGFyZ2V0UG9zID0gc3RhdGUuZG9jLnJlc29sdmUoJGFuY2hvci5wb3MgLSAyKTtcbiAgaWYgKCR0YXJnZXRQb3MuaW5kZXgoKSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKChfYSA9ICR0YXJnZXRQb3Mubm9kZUJlZm9yZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnR5cGUubmFtZSkgIT09IHR5cGVPck5hbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2xpc3RJdGVtSGFzU3ViTGlzdC50c1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgYXMgZ2V0Tm9kZVR5cGUyIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIGxpc3RJdGVtSGFzU3ViTGlzdCA9ICh0eXBlT3JOYW1lLCBzdGF0ZSwgbm9kZSkgPT4ge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgbm9kZVR5cGUgPSBnZXROb2RlVHlwZTIodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgbGV0IGhhc1N1Ykxpc3QgPSBmYWxzZTtcbiAgbm9kZS5kZXNjZW5kYW50cygoY2hpbGQpID0+IHtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gbm9kZVR5cGUpIHtcbiAgICAgIGhhc1N1Ykxpc3QgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBoYXNTdWJMaXN0O1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9oYW5kbGVCYWNrc3BhY2UudHNcbnZhciBoYW5kbGVCYWNrc3BhY2UgPSAoZWRpdG9yLCBuYW1lLCBwYXJlbnRMaXN0VHlwZXMpID0+IHtcbiAgaWYgKGVkaXRvci5jb21tYW5kcy51bmRvSW5wdXRSdWxlKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5mcm9tICE9PSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLnRvKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghaXNOb2RlQWN0aXZlKGVkaXRvci5zdGF0ZSwgbmFtZSkgJiYgaGFzTGlzdEJlZm9yZShlZGl0b3Iuc3RhdGUsIG5hbWUsIHBhcmVudExpc3RUeXBlcykpIHtcbiAgICBjb25zdCB7ICRhbmNob3IgfSA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgY29uc3QgJGxpc3RQb3MgPSBlZGl0b3Iuc3RhdGUuZG9jLnJlc29sdmUoJGFuY2hvci5iZWZvcmUoKSAtIDEpO1xuICAgIGNvbnN0IGxpc3REZXNjZW5kYW50cyA9IFtdO1xuICAgICRsaXN0UG9zLm5vZGUoKS5kZXNjZW5kYW50cygobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAobm9kZS50eXBlLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdERlc2NlbmRhbnRzLnB1c2goeyBub2RlLCBwb3MgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgbGFzdEl0ZW0gPSBsaXN0RGVzY2VuZGFudHMuYXQoLTEpO1xuICAgIGlmICghbGFzdEl0ZW0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgJGxhc3RJdGVtUG9zID0gZWRpdG9yLnN0YXRlLmRvYy5yZXNvbHZlKCRsaXN0UG9zLnN0YXJ0KCkgKyBsYXN0SXRlbS5wb3MgKyAxKTtcbiAgICByZXR1cm4gZWRpdG9yLmNoYWluKCkuY3V0KHsgZnJvbTogJGFuY2hvci5zdGFydCgpIC0gMSwgdG86ICRhbmNob3IuZW5kKCkgKyAxIH0sICRsYXN0SXRlbVBvcy5lbmQoKSkuam9pbkZvcndhcmQoKS5ydW4oKTtcbiAgfVxuICBpZiAoIWlzTm9kZUFjdGl2ZShlZGl0b3Iuc3RhdGUsIG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghaXNBdFN0YXJ0T2ZOb2RlKGVkaXRvci5zdGF0ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbGlzdEl0ZW1Qb3MgPSBmaW5kTGlzdEl0ZW1Qb3MobmFtZSwgZWRpdG9yLnN0YXRlKTtcbiAgaWYgKCFsaXN0SXRlbVBvcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCAkcHJldiA9IGVkaXRvci5zdGF0ZS5kb2MucmVzb2x2ZShsaXN0SXRlbVBvcy4kcG9zLnBvcyAtIDIpO1xuICBjb25zdCBwcmV2Tm9kZSA9ICRwcmV2Lm5vZGUobGlzdEl0ZW1Qb3MuZGVwdGgpO1xuICBjb25zdCBwcmV2aW91c0xpc3RJdGVtSGFzU3ViTGlzdCA9IGxpc3RJdGVtSGFzU3ViTGlzdChuYW1lLCBlZGl0b3Iuc3RhdGUsIHByZXZOb2RlKTtcbiAgaWYgKGhhc0xpc3RJdGVtQmVmb3JlKG5hbWUsIGVkaXRvci5zdGF0ZSkgJiYgIXByZXZpb3VzTGlzdEl0ZW1IYXNTdWJMaXN0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5jb21tYW5kcy5qb2luSXRlbUJhY2t3YXJkKCk7XG4gIH1cbiAgcmV0dXJuIGVkaXRvci5jaGFpbigpLmxpZnRMaXN0SXRlbShuYW1lKS5ydW4oKTtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvaGFuZGxlRGVsZXRlLnRzXG5pbXBvcnQgeyBpc0F0RW5kT2ZOb2RlLCBpc05vZGVBY3RpdmUgYXMgaXNOb2RlQWN0aXZlMiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9uZXh0TGlzdElzRGVlcGVyLnRzXG52YXIgbmV4dExpc3RJc0RlZXBlciA9ICh0eXBlT3JOYW1lLCBzdGF0ZSkgPT4ge1xuICBjb25zdCBsaXN0RGVwdGggPSBnZXROZXh0TGlzdERlcHRoKHR5cGVPck5hbWUsIHN0YXRlKTtcbiAgY29uc3QgbGlzdEl0ZW1Qb3MgPSBmaW5kTGlzdEl0ZW1Qb3ModHlwZU9yTmFtZSwgc3RhdGUpO1xuICBpZiAoIWxpc3RJdGVtUG9zIHx8ICFsaXN0RGVwdGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxpc3REZXB0aCA+IGxpc3RJdGVtUG9zLmRlcHRoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9uZXh0TGlzdElzSGlnaGVyLnRzXG52YXIgbmV4dExpc3RJc0hpZ2hlciA9ICh0eXBlT3JOYW1lLCBzdGF0ZSkgPT4ge1xuICBjb25zdCBsaXN0RGVwdGggPSBnZXROZXh0TGlzdERlcHRoKHR5cGVPck5hbWUsIHN0YXRlKTtcbiAgY29uc3QgbGlzdEl0ZW1Qb3MgPSBmaW5kTGlzdEl0ZW1Qb3ModHlwZU9yTmFtZSwgc3RhdGUpO1xuICBpZiAoIWxpc3RJdGVtUG9zIHx8ICFsaXN0RGVwdGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxpc3REZXB0aCA8IGxpc3RJdGVtUG9zLmRlcHRoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9oYW5kbGVEZWxldGUudHNcbnZhciBoYW5kbGVEZWxldGUgPSAoZWRpdG9yLCBuYW1lKSA9PiB7XG4gIGlmICghaXNOb2RlQWN0aXZlMihlZGl0b3Iuc3RhdGUsIG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghaXNBdEVuZE9mTm9kZShlZGl0b3Iuc3RhdGUsIG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBlZGl0b3Iuc3RhdGU7XG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uO1xuICBpZiAoIXNlbGVjdGlvbi5lbXB0eSAmJiAkZnJvbS5zYW1lUGFyZW50KCR0bykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5leHRMaXN0SXNEZWVwZXIobmFtZSwgZWRpdG9yLnN0YXRlKSkge1xuICAgIHJldHVybiBlZGl0b3IuY2hhaW4oKS5mb2N1cyhlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmZyb20gKyA0KS5saWZ0KG5hbWUpLmpvaW5CYWNrd2FyZCgpLnJ1bigpO1xuICB9XG4gIGlmIChuZXh0TGlzdElzSGlnaGVyKG5hbWUsIGVkaXRvci5zdGF0ZSkpIHtcbiAgICByZXR1cm4gZWRpdG9yLmNoYWluKCkuam9pbkZvcndhcmQoKS5qb2luQmFja3dhcmQoKS5ydW4oKTtcbiAgfVxuICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmpvaW5JdGVtRm9yd2FyZCgpO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9oYXNMaXN0SXRlbUFmdGVyLnRzXG52YXIgaGFzTGlzdEl0ZW1BZnRlciA9ICh0eXBlT3JOYW1lLCBzdGF0ZSkgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IHsgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCAkdGFyZ2V0UG9zID0gc3RhdGUuZG9jLnJlc29sdmUoJGFuY2hvci5wb3MgLSAkYW5jaG9yLnBhcmVudE9mZnNldCAtIDIpO1xuICBpZiAoJHRhcmdldFBvcy5pbmRleCgpID09PSAkdGFyZ2V0UG9zLnBhcmVudC5jaGlsZENvdW50IC0gMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKChfYSA9ICR0YXJnZXRQb3Mubm9kZUFmdGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EudHlwZS5uYW1lKSAhPT0gdHlwZU9yTmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdC1rZXltYXAudHNcbnZhciBMaXN0S2V5bWFwID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwibGlzdEtleW1hcFwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXN0VHlwZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGl0ZW1OYW1lOiBcImxpc3RJdGVtXCIsXG4gICAgICAgICAgd3JhcHBlck5hbWVzOiBbXCJidWxsZXRMaXN0XCIsIFwib3JkZXJlZExpc3RcIl1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGl0ZW1OYW1lOiBcInRhc2tJdGVtXCIsXG4gICAgICAgICAgd3JhcHBlck5hbWVzOiBbXCJ0YXNrTGlzdFwiXVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIERlbGV0ZTogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxpc3RUeXBlcy5mb3JFYWNoKCh7IGl0ZW1OYW1lIH0pID0+IHtcbiAgICAgICAgICBpZiAoZWRpdG9yLnN0YXRlLnNjaGVtYS5ub2Rlc1tpdGVtTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlRGVsZXRlKGVkaXRvciwgaXRlbU5hbWUpKSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICAgIH0sXG4gICAgICBcIk1vZC1EZWxldGVcIjogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxpc3RUeXBlcy5mb3JFYWNoKCh7IGl0ZW1OYW1lIH0pID0+IHtcbiAgICAgICAgICBpZiAoZWRpdG9yLnN0YXRlLnNjaGVtYS5ub2Rlc1tpdGVtTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlRGVsZXRlKGVkaXRvciwgaXRlbU5hbWUpKSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICAgIH0sXG4gICAgICBCYWNrc3BhY2U6ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0aW9ucy5saXN0VHlwZXMuZm9yRWFjaCgoeyBpdGVtTmFtZSwgd3JhcHBlck5hbWVzIH0pID0+IHtcbiAgICAgICAgICBpZiAoZWRpdG9yLnN0YXRlLnNjaGVtYS5ub2Rlc1tpdGVtTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlQmFja3NwYWNlKGVkaXRvciwgaXRlbU5hbWUsIHdyYXBwZXJOYW1lcykpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgICAgfSxcbiAgICAgIFwiTW9kLUJhY2tzcGFjZVwiOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGlzdFR5cGVzLmZvckVhY2goKHsgaXRlbU5hbWUsIHdyYXBwZXJOYW1lcyB9KSA9PiB7XG4gICAgICAgICAgaWYgKGVkaXRvci5zdGF0ZS5zY2hlbWEubm9kZXNbaXRlbU5hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZUJhY2tzcGFjZShlZGl0b3IsIGl0ZW1OYW1lLCB3cmFwcGVyTmFtZXMpKSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2tpdC9pbmRleC50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjIgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5cbi8vIHNyYy9vcmRlcmVkLWxpc3Qvb3JkZXJlZC1saXN0LnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMgYXMgbWVyZ2VBdHRyaWJ1dGVzMywgTm9kZSBhcyBOb2RlMywgd3JhcHBpbmdJbnB1dFJ1bGUgYXMgd3JhcHBpbmdJbnB1dFJ1bGUyIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuXG4vLyBzcmMvb3JkZXJlZC1saXN0L3V0aWxzLnRzXG52YXIgT1JERVJFRF9MSVNUX0lURU1fUkVHRVggPSAvXihcXHMqKShcXGQrKVxcLlxccysoLiopJC87XG52YXIgSU5ERU5URURfTElORV9SRUdFWCA9IC9eXFxzLztcbmZ1bmN0aW9uIGNvbGxlY3RPcmRlcmVkTGlzdEl0ZW1zKGxpbmVzKSB7XG4gIGNvbnN0IGxpc3RJdGVtcyA9IFtdO1xuICBsZXQgY3VycmVudExpbmVJbmRleCA9IDA7XG4gIGxldCBjb25zdW1lZCA9IDA7XG4gIHdoaWxlIChjdXJyZW50TGluZUluZGV4IDwgbGluZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2N1cnJlbnRMaW5lSW5kZXhdO1xuICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaChPUkRFUkVEX0xJU1RfSVRFTV9SRUdFWCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IFssIGluZGVudCwgbnVtYmVyLCBjb250ZW50XSA9IG1hdGNoO1xuICAgIGNvbnN0IGluZGVudExldmVsID0gaW5kZW50Lmxlbmd0aDtcbiAgICBsZXQgaXRlbUNvbnRlbnQgPSBjb250ZW50O1xuICAgIGxldCBuZXh0TGluZUluZGV4ID0gY3VycmVudExpbmVJbmRleCArIDE7XG4gICAgY29uc3QgaXRlbUxpbmVzID0gW2xpbmVdO1xuICAgIHdoaWxlIChuZXh0TGluZUluZGV4IDwgbGluZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXh0TGluZSA9IGxpbmVzW25leHRMaW5lSW5kZXhdO1xuICAgICAgY29uc3QgbmV4dE1hdGNoID0gbmV4dExpbmUubWF0Y2goT1JERVJFRF9MSVNUX0lURU1fUkVHRVgpO1xuICAgICAgaWYgKG5leHRNYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0TGluZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgaXRlbUxpbmVzLnB1c2gobmV4dExpbmUpO1xuICAgICAgICBpdGVtQ29udGVudCArPSBcIlxcblwiO1xuICAgICAgICBuZXh0TGluZUluZGV4ICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKG5leHRMaW5lLm1hdGNoKElOREVOVEVEX0xJTkVfUkVHRVgpKSB7XG4gICAgICAgIGl0ZW1MaW5lcy5wdXNoKG5leHRMaW5lKTtcbiAgICAgICAgaXRlbUNvbnRlbnQgKz0gYFxuJHtuZXh0TGluZS5zbGljZShpbmRlbnRMZXZlbCArIDIpfWA7XG4gICAgICAgIG5leHRMaW5lSW5kZXggKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBsaXN0SXRlbXMucHVzaCh7XG4gICAgICBpbmRlbnQ6IGluZGVudExldmVsLFxuICAgICAgbnVtYmVyOiBwYXJzZUludChudW1iZXIsIDEwKSxcbiAgICAgIGNvbnRlbnQ6IGl0ZW1Db250ZW50LnRyaW0oKSxcbiAgICAgIHJhdzogaXRlbUxpbmVzLmpvaW4oXCJcXG5cIilcbiAgICB9KTtcbiAgICBjb25zdW1lZCA9IG5leHRMaW5lSW5kZXg7XG4gICAgY3VycmVudExpbmVJbmRleCA9IG5leHRMaW5lSW5kZXg7XG4gIH1cbiAgcmV0dXJuIFtsaXN0SXRlbXMsIGNvbnN1bWVkXTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTmVzdGVkU3RydWN0dXJlKGl0ZW1zLCBiYXNlSW5kZW50LCBsZXhlcikge1xuICB2YXIgX2E7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IGl0ZW1zLmxlbmd0aCkge1xuICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tjdXJyZW50SW5kZXhdO1xuICAgIGlmIChpdGVtLmluZGVudCA9PT0gYmFzZUluZGVudCkge1xuICAgICAgY29uc3QgY29udGVudExpbmVzID0gaXRlbS5jb250ZW50LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgY29uc3QgbWFpblRleHQgPSAoKF9hID0gY29udGVudExpbmVzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EudHJpbSgpKSB8fCBcIlwiO1xuICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICBpZiAobWFpblRleHQpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgICAgcmF3OiBtYWluVGV4dCxcbiAgICAgICAgICB0b2tlbnM6IGxleGVyLmlubGluZVRva2VucyhtYWluVGV4dClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBhZGRpdGlvbmFsQ29udGVudCA9IGNvbnRlbnRMaW5lcy5zbGljZSgxKS5qb2luKFwiXFxuXCIpLnRyaW0oKTtcbiAgICAgIGlmIChhZGRpdGlvbmFsQ29udGVudCkge1xuICAgICAgICBjb25zdCBibG9ja1Rva2VucyA9IGxleGVyLmJsb2NrVG9rZW5zKGFkZGl0aW9uYWxDb250ZW50KTtcbiAgICAgICAgdG9rZW5zLnB1c2goLi4uYmxvY2tUb2tlbnMpO1xuICAgICAgfVxuICAgICAgbGV0IGxvb2tBaGVhZEluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgIGNvbnN0IG5lc3RlZEl0ZW1zID0gW107XG4gICAgICB3aGlsZSAobG9va0FoZWFkSW5kZXggPCBpdGVtcy5sZW5ndGggJiYgaXRlbXNbbG9va0FoZWFkSW5kZXhdLmluZGVudCA+IGJhc2VJbmRlbnQpIHtcbiAgICAgICAgbmVzdGVkSXRlbXMucHVzaChpdGVtc1tsb29rQWhlYWRJbmRleF0pO1xuICAgICAgICBsb29rQWhlYWRJbmRleCArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKG5lc3RlZEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dEluZGVudCA9IE1hdGgubWluKC4uLm5lc3RlZEl0ZW1zLm1hcCgobmVzdGVkSXRlbSkgPT4gbmVzdGVkSXRlbS5pbmRlbnQpKTtcbiAgICAgICAgY29uc3QgbmVzdGVkTGlzdEl0ZW1zID0gYnVpbGROZXN0ZWRTdHJ1Y3R1cmUobmVzdGVkSXRlbXMsIG5leHRJbmRlbnQsIGxleGVyKTtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwibGlzdFwiLFxuICAgICAgICAgIG9yZGVyZWQ6IHRydWUsXG4gICAgICAgICAgc3RhcnQ6IG5lc3RlZEl0ZW1zWzBdLm51bWJlcixcbiAgICAgICAgICBpdGVtczogbmVzdGVkTGlzdEl0ZW1zLFxuICAgICAgICAgIHJhdzogbmVzdGVkSXRlbXMubWFwKChuZXN0ZWRJdGVtKSA9PiBuZXN0ZWRJdGVtLnJhdykuam9pbihcIlxcblwiKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJsaXN0X2l0ZW1cIixcbiAgICAgICAgcmF3OiBpdGVtLnJhdyxcbiAgICAgICAgdG9rZW5zXG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnRJbmRleCA9IGxvb2tBaGVhZEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50SW5kZXggKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlTGlzdEl0ZW1zKGl0ZW1zLCBoZWxwZXJzKSB7XG4gIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbS50eXBlICE9PSBcImxpc3RfaXRlbVwiKSB7XG4gICAgICByZXR1cm4gaGVscGVycy5wYXJzZUNoaWxkcmVuKFtpdGVtXSlbMF07XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSBbXTtcbiAgICBpZiAoaXRlbS50b2tlbnMgJiYgaXRlbS50b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgaXRlbS50b2tlbnMuZm9yRWFjaCgoaXRlbVRva2VuKSA9PiB7XG4gICAgICAgIGlmIChpdGVtVG9rZW4udHlwZSA9PT0gXCJwYXJhZ3JhcGhcIiB8fCBpdGVtVG9rZW4udHlwZSA9PT0gXCJsaXN0XCIgfHwgaXRlbVRva2VuLnR5cGUgPT09IFwiYmxvY2txdW90ZVwiIHx8IGl0ZW1Ub2tlbi50eXBlID09PSBcImNvZGVcIikge1xuICAgICAgICAgIGNvbnRlbnQucHVzaCguLi5oZWxwZXJzLnBhcnNlQ2hpbGRyZW4oW2l0ZW1Ub2tlbl0pKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtVG9rZW4udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgaXRlbVRva2VuLnRva2Vucykge1xuICAgICAgICAgIGNvbnN0IGlubGluZUNvbnRlbnQgPSBoZWxwZXJzLnBhcnNlQ2hpbGRyZW4oW2l0ZW1Ub2tlbl0pO1xuICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInBhcmFncmFwaFwiLFxuICAgICAgICAgICAgY29udGVudDogaW5saW5lQ29udGVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IGhlbHBlcnMucGFyc2VDaGlsZHJlbihbaXRlbVRva2VuXSk7XG4gICAgICAgICAgaWYgKHBhcnNlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb250ZW50LnB1c2goLi4ucGFyc2VkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsaXN0SXRlbVwiLFxuICAgICAgY29udGVudFxuICAgIH07XG4gIH0pO1xufVxuXG4vLyBzcmMvb3JkZXJlZC1saXN0L29yZGVyZWQtbGlzdC50c1xudmFyIExpc3RJdGVtTmFtZTIgPSBcImxpc3RJdGVtXCI7XG52YXIgVGV4dFN0eWxlTmFtZTIgPSBcInRleHRTdHlsZVwiO1xudmFyIG9yZGVyZWRMaXN0SW5wdXRSZWdleCA9IC9eKFxcZCspXFwuXFxzJC87XG52YXIgT3JkZXJlZExpc3QgPSBOb2RlMy5jcmVhdGUoe1xuICBuYW1lOiBcIm9yZGVyZWRMaXN0XCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1UeXBlTmFtZTogXCJsaXN0SXRlbVwiLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAga2VlcE1hcmtzOiBmYWxzZSxcbiAgICAgIGtlZXBBdHRyaWJ1dGVzOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGdyb3VwOiBcImJsb2NrIGxpc3RcIixcbiAgY29udGVudCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZX0rYDtcbiAgfSxcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZShcInN0YXJ0XCIpID8gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdGFydFwiKSB8fCBcIlwiLCAxMCkgOiAxO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHlwZToge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIilcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcIm9sXCJcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIGNvbnN0IHsgc3RhcnQsIC4uLmF0dHJpYnV0ZXNXaXRob3V0U3RhcnQgfSA9IEhUTUxBdHRyaWJ1dGVzO1xuICAgIHJldHVybiBzdGFydCA9PT0gMSA/IFtcIm9sXCIsIG1lcmdlQXR0cmlidXRlczModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzV2l0aG91dFN0YXJ0KSwgMF0gOiBbXCJvbFwiLCBtZXJnZUF0dHJpYnV0ZXMzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgfSxcbiAgbWFya2Rvd25Ub2tlbk5hbWU6IFwibGlzdFwiLFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGhlbHBlcnMpID0+IHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gXCJsaXN0XCIgfHwgIXRva2VuLm9yZGVyZWQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRWYWx1ZSA9IHRva2VuLnN0YXJ0IHx8IDE7XG4gICAgY29uc3QgY29udGVudCA9IHRva2VuLml0ZW1zID8gcGFyc2VMaXN0SXRlbXModG9rZW4uaXRlbXMsIGhlbHBlcnMpIDogW107XG4gICAgaWYgKHN0YXJ0VmFsdWUgIT09IDEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwib3JkZXJlZExpc3RcIixcbiAgICAgICAgYXR0cnM6IHsgc3RhcnQ6IHN0YXJ0VmFsdWUgfSxcbiAgICAgICAgY29udGVudFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3JkZXJlZExpc3RcIixcbiAgICAgIGNvbnRlbnRcbiAgICB9O1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICBpZiAoIW5vZGUuY29udGVudCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBoLnJlbmRlckNoaWxkcmVuKG5vZGUuY29udGVudCwgXCJcXG5cIik7XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5pemVyOiB7XG4gICAgbmFtZTogXCJvcmRlcmVkTGlzdFwiLFxuICAgIGxldmVsOiBcImJsb2NrXCIsXG4gICAgc3RhcnQ6IChzcmMpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoID0gc3JjLm1hdGNoKC9eKFxccyopKFxcZCspXFwuXFxzKy8pO1xuICAgICAgY29uc3QgaW5kZXggPSBtYXRjaCA9PSBudWxsID8gdm9pZCAwIDogbWF0Y2guaW5kZXg7XG4gICAgICByZXR1cm4gaW5kZXggIT09IHZvaWQgMCA/IGluZGV4IDogLTE7XG4gICAgfSxcbiAgICB0b2tlbml6ZTogKHNyYywgX3Rva2VucywgbGV4ZXIpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGxpbmVzID0gc3JjLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgY29uc3QgW2xpc3RJdGVtcywgY29uc3VtZWRdID0gY29sbGVjdE9yZGVyZWRMaXN0SXRlbXMobGluZXMpO1xuICAgICAgaWYgKGxpc3RJdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1zID0gYnVpbGROZXN0ZWRTdHJ1Y3R1cmUobGlzdEl0ZW1zLCAwLCBsZXhlcik7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFZhbHVlID0gKChfYSA9IGxpc3RJdGVtc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm51bWJlcikgfHwgMTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibGlzdFwiLFxuICAgICAgICBvcmRlcmVkOiB0cnVlLFxuICAgICAgICBzdGFydDogc3RhcnRWYWx1ZSxcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIHJhdzogbGluZXMuc2xpY2UoMCwgY29uc3VtZWQpLmpvaW4oXCJcXG5cIilcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBtYXJrZG93bk9wdGlvbnM6IHtcbiAgICBpbmRlbnRzQ29udGVudDogdHJ1ZVxuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9nZ2xlT3JkZXJlZExpc3Q6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiB9KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oKS50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcykudXBkYXRlQXR0cmlidXRlcyhMaXN0SXRlbU5hbWUyLCB0aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZU5hbWUyKSkucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtU2hpZnQtN1wiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVPcmRlcmVkTGlzdCgpXG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICBsZXQgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUyKHtcbiAgICAgIGZpbmQ6IG9yZGVyZWRMaXN0SW5wdXRSZWdleCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIGdldEF0dHJpYnV0ZXM6IChtYXRjaCkgPT4gKHsgc3RhcnQ6ICttYXRjaFsxXSB9KSxcbiAgICAgIGpvaW5QcmVkaWNhdGU6IChtYXRjaCwgbm9kZSkgPT4gbm9kZS5jaGlsZENvdW50ICsgbm9kZS5hdHRycy5zdGFydCA9PT0gK21hdGNoWzFdXG4gICAgfSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwTWFya3MgfHwgdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZTIoe1xuICAgICAgICBmaW5kOiBvcmRlcmVkTGlzdElucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAga2VlcE1hcmtzOiB0aGlzLm9wdGlvbnMua2VlcE1hcmtzLFxuICAgICAgICBrZWVwQXR0cmlidXRlczogdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiAobWF0Y2gpID0+ICh7IHN0YXJ0OiArbWF0Y2hbMV0sIC4uLnRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZTIpIH0pLFxuICAgICAgICBqb2luUHJlZGljYXRlOiAobWF0Y2gsIG5vZGUpID0+IG5vZGUuY2hpbGRDb3VudCArIG5vZGUuYXR0cnMuc3RhcnQgPT09ICttYXRjaFsxXSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvclxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbaW5wdXRSdWxlXTtcbiAgfVxufSk7XG5cbi8vIHNyYy90YXNrLWl0ZW0vdGFzay1pdGVtLnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMgYXMgbWVyZ2VBdHRyaWJ1dGVzNCwgTm9kZSBhcyBOb2RlNCwgcmVuZGVyTmVzdGVkTWFya2Rvd25Db250ZW50IGFzIHJlbmRlck5lc3RlZE1hcmtkb3duQ29udGVudDIsIHdyYXBwaW5nSW5wdXRSdWxlIGFzIHdyYXBwaW5nSW5wdXRSdWxlMyB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBpbnB1dFJlZ2V4ID0gL15cXHMqKFxcWyhbKCB8eF0pP1xcXSlcXHMkLztcbnZhciBUYXNrSXRlbSA9IE5vZGU0LmNyZWF0ZSh7XG4gIG5hbWU6IFwidGFza0l0ZW1cIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmVzdGVkOiBmYWxzZSxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHRhc2tMaXN0VHlwZU5hbWU6IFwidGFza0xpc3RcIixcbiAgICAgIGExMXk6IHZvaWQgMFxuICAgIH07XG4gIH0sXG4gIGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5uZXN0ZWQgPyBcInBhcmFncmFwaCBibG9jaypcIiA6IFwicGFyYWdyYXBoK1wiO1xuICB9LFxuICBkZWZpbmluZzogdHJ1ZSxcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hlY2tlZDoge1xuICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAga2VlcE9uU3BsaXQ6IGZhbHNlLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0YUNoZWNrZWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY2hlY2tlZFwiKTtcbiAgICAgICAgICByZXR1cm4gZGF0YUNoZWNrZWQgPT09IFwiXCIgfHwgZGF0YUNoZWNrZWQgPT09IFwidHJ1ZVwiO1xuICAgICAgICB9LFxuICAgICAgICByZW5kZXJIVE1MOiAoYXR0cmlidXRlcykgPT4gKHtcbiAgICAgICAgICBcImRhdGEtY2hlY2tlZFwiOiBhdHRyaWJ1dGVzLmNoZWNrZWRcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBgbGlbZGF0YS10eXBlPVwiJHt0aGlzLm5hbWV9XCJdYCxcbiAgICAgICAgcHJpb3JpdHk6IDUxXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJsaVwiLFxuICAgICAgbWVyZ2VBdHRyaWJ1dGVzNCh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzLCB7XG4gICAgICAgIFwiZGF0YS10eXBlXCI6IHRoaXMubmFtZVxuICAgICAgfSksXG4gICAgICBbXG4gICAgICAgIFwibGFiZWxcIixcbiAgICAgICAgW1xuICAgICAgICAgIFwiaW5wdXRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBjaGVja2VkOiBub2RlLmF0dHJzLmNoZWNrZWQgPyBcImNoZWNrZWRcIiA6IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFtcInNwYW5cIl1cbiAgICAgIF0sXG4gICAgICBbXCJkaXZcIiwgMF1cbiAgICBdO1xuICB9LFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGgpID0+IHtcbiAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgaWYgKHRva2VuLnRva2VucyAmJiB0b2tlbi50b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgY29udGVudC5wdXNoKGguY3JlYXRlTm9kZShcInBhcmFncmFwaFwiLCB7fSwgaC5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpKSk7XG4gICAgfSBlbHNlIGlmICh0b2tlbi50ZXh0KSB7XG4gICAgICBjb250ZW50LnB1c2goaC5jcmVhdGVOb2RlKFwicGFyYWdyYXBoXCIsIHt9LCBbaC5jcmVhdGVOb2RlKFwidGV4dFwiLCB7IHRleHQ6IHRva2VuLnRleHQgfSldKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQucHVzaChoLmNyZWF0ZU5vZGUoXCJwYXJhZ3JhcGhcIiwge30sIFtdKSk7XG4gICAgfVxuICAgIGlmICh0b2tlbi5uZXN0ZWRUb2tlbnMgJiYgdG9rZW4ubmVzdGVkVG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5lc3RlZENvbnRlbnQgPSBoLnBhcnNlQ2hpbGRyZW4odG9rZW4ubmVzdGVkVG9rZW5zKTtcbiAgICAgIGNvbnRlbnQucHVzaCguLi5uZXN0ZWRDb250ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGguY3JlYXRlTm9kZShcInRhc2tJdGVtXCIsIHsgY2hlY2tlZDogdG9rZW4uY2hlY2tlZCB8fCBmYWxzZSB9LCBjb250ZW50KTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNoZWNrZWRDaGFyID0gKChfYSA9IG5vZGUuYXR0cnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jaGVja2VkKSA/IFwieFwiIDogXCIgXCI7XG4gICAgY29uc3QgcHJlZml4ID0gYC0gWyR7Y2hlY2tlZENoYXJ9XSBgO1xuICAgIHJldHVybiByZW5kZXJOZXN0ZWRNYXJrZG93bkNvbnRlbnQyKG5vZGUsIGgsIHByZWZpeCk7XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIGNvbnN0IHNob3J0Y3V0cyA9IHtcbiAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zcGxpdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICBcIlNoaWZ0LVRhYlwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0odGhpcy5uYW1lKVxuICAgIH07XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubmVzdGVkKSB7XG4gICAgICByZXR1cm4gc2hvcnRjdXRzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2hvcnRjdXRzLFxuICAgICAgVGFiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zaW5rTGlzdEl0ZW0odGhpcy5uYW1lKVxuICAgIH07XG4gIH0sXG4gIGFkZE5vZGVWaWV3KCkge1xuICAgIHJldHVybiAoeyBub2RlLCBIVE1MQXR0cmlidXRlcywgZ2V0UG9zLCBlZGl0b3IgfSkgPT4ge1xuICAgICAgY29uc3QgbGlzdEl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XG4gICAgICBjb25zdCBjaGVja2JveFdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICBjb25zdCBjaGVja2JveFN0eWxlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgY29uc3QgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnN0IHVwZGF0ZUExMVkgPSAoY3VycmVudE5vZGUpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY2hlY2tib3guYXJpYUxhYmVsID0gKChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5hMTF5KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2hlY2tib3hMYWJlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGN1cnJlbnROb2RlLCBjaGVja2JveC5jaGVja2VkKSkgfHwgYFRhc2sgaXRlbSBjaGVja2JveCBmb3IgJHtjdXJyZW50Tm9kZS50ZXh0Q29udGVudCB8fCBcImVtcHR5IHRhc2sgaXRlbVwifWA7XG4gICAgICB9O1xuICAgICAgdXBkYXRlQTExWShub2RlKTtcbiAgICAgIGNoZWNrYm94V3JhcHBlci5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICBjaGVja2JveC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZXZlbnQpID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCkpO1xuICAgICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3IuaXNFZGl0YWJsZSAmJiAhdGhpcy5vcHRpb25zLm9uUmVhZE9ubHlDaGVja2VkKSB7XG4gICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9ICFjaGVja2JveC5jaGVja2VkO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNoZWNrZWQgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKGVkaXRvci5pc0VkaXRhYmxlICYmIHR5cGVvZiBnZXRQb3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGVkaXRvci5jaGFpbigpLmZvY3VzKHZvaWQgMCwgeyBzY3JvbGxJbnRvVmlldzogZmFsc2UgfSkuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFBvcygpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3NpdGlvbiwgdm9pZCAwLCB7XG4gICAgICAgICAgICAgIC4uLmN1cnJlbnROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS5hdHRycyxcbiAgICAgICAgICAgICAgY2hlY2tlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9KS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVkaXRvci5pc0VkaXRhYmxlICYmIHRoaXMub3B0aW9ucy5vblJlYWRPbmx5Q2hlY2tlZCkge1xuICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLm9uUmVhZE9ubHlDaGVja2VkKG5vZGUsIGNoZWNrZWQpKSB7XG4gICAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gIWNoZWNrYm94LmNoZWNrZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGxpc3RJdGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgbGlzdEl0ZW0uZGF0YXNldC5jaGVja2VkID0gbm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IG5vZGUuYXR0cnMuY2hlY2tlZDtcbiAgICAgIGNoZWNrYm94V3JhcHBlci5hcHBlbmQoY2hlY2tib3gsIGNoZWNrYm94U3R5bGVyKTtcbiAgICAgIGxpc3RJdGVtLmFwcGVuZChjaGVja2JveFdyYXBwZXIsIGNvbnRlbnQpO1xuICAgICAgT2JqZWN0LmVudHJpZXMoSFRNTEF0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBsaXN0SXRlbS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbTogbGlzdEl0ZW0sXG4gICAgICAgIGNvbnRlbnRET006IGNvbnRlbnQsXG4gICAgICAgIHVwZGF0ZTogKHVwZGF0ZWROb2RlKSA9PiB7XG4gICAgICAgICAgaWYgKHVwZGF0ZWROb2RlLnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaXN0SXRlbS5kYXRhc2V0LmNoZWNrZWQgPSB1cGRhdGVkTm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB1cGRhdGVkTm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgICAgIHVwZGF0ZUExMVkodXBkYXRlZE5vZGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHdyYXBwaW5nSW5wdXRSdWxlMyh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogKG1hdGNoKSA9PiAoe1xuICAgICAgICAgIGNoZWNrZWQ6IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdID09PSBcInhcIlxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL3Rhc2stbGlzdC90YXNrLWxpc3QudHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcyBhcyBtZXJnZUF0dHJpYnV0ZXM1LCBOb2RlIGFzIE5vZGU1LCBwYXJzZUluZGVudGVkQmxvY2tzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIFRhc2tMaXN0ID0gTm9kZTUuY3JlYXRlKHtcbiAgbmFtZTogXCJ0YXNrTGlzdFwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtVHlwZU5hbWU6IFwidGFza0l0ZW1cIixcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIGdyb3VwOiBcImJsb2NrIGxpc3RcIixcbiAgY29udGVudCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZX0rYDtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogYHVsW2RhdGEtdHlwZT1cIiR7dGhpcy5uYW1lfVwiXWAsXG4gICAgICAgIHByaW9yaXR5OiA1MVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcInVsXCIsIG1lcmdlQXR0cmlidXRlczUodGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcywgeyBcImRhdGEtdHlwZVwiOiB0aGlzLm5hbWUgfSksIDBdO1xuICB9LFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGgpID0+IHtcbiAgICByZXR1cm4gaC5jcmVhdGVOb2RlKFwidGFza0xpc3RcIiwge30sIGgucGFyc2VDaGlsZHJlbih0b2tlbi5pdGVtcyB8fCBbXSkpO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICBpZiAoIW5vZGUuY29udGVudCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBoLnJlbmRlckNoaWxkcmVuKG5vZGUuY29udGVudCwgXCJcXG5cIik7XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5pemVyOiB7XG4gICAgbmFtZTogXCJ0YXNrTGlzdFwiLFxuICAgIGxldmVsOiBcImJsb2NrXCIsXG4gICAgc3RhcnQoc3JjKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBpbmRleCA9IChfYSA9IHNyYy5tYXRjaCgvXlxccypbLSsqXVxccytcXFsoWyB4WF0pXFxdXFxzKy8pKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaW5kZXg7XG4gICAgICByZXR1cm4gaW5kZXggIT09IHZvaWQgMCA/IGluZGV4IDogLTE7XG4gICAgfSxcbiAgICB0b2tlbml6ZShzcmMsIHRva2VucywgbGV4ZXIpIHtcbiAgICAgIGNvbnN0IHBhcnNlVGFza0xpc3RDb250ZW50ID0gKGNvbnRlbnQpID0+IHtcbiAgICAgICAgY29uc3QgbmVzdGVkUmVzdWx0ID0gcGFyc2VJbmRlbnRlZEJsb2NrcyhcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGl0ZW1QYXR0ZXJuOiAvXihcXHMqKShbLSsqXSlcXHMrXFxbKFsgeFhdKVxcXVxccysoLiopJC8sXG4gICAgICAgICAgICBleHRyYWN0SXRlbURhdGE6IChtYXRjaCkgPT4gKHtcbiAgICAgICAgICAgICAgaW5kZW50TGV2ZWw6IG1hdGNoWzFdLmxlbmd0aCxcbiAgICAgICAgICAgICAgbWFpbkNvbnRlbnQ6IG1hdGNoWzRdLFxuICAgICAgICAgICAgICBjaGVja2VkOiBtYXRjaFszXS50b0xvd2VyQ2FzZSgpID09PSBcInhcIlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjcmVhdGVUb2tlbjogKGRhdGEsIG5lc3RlZFRva2VucykgPT4gKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0YXNrSXRlbVwiLFxuICAgICAgICAgICAgICByYXc6IFwiXCIsXG4gICAgICAgICAgICAgIG1haW5Db250ZW50OiBkYXRhLm1haW5Db250ZW50LFxuICAgICAgICAgICAgICBpbmRlbnRMZXZlbDogZGF0YS5pbmRlbnRMZXZlbCxcbiAgICAgICAgICAgICAgY2hlY2tlZDogZGF0YS5jaGVja2VkLFxuICAgICAgICAgICAgICB0ZXh0OiBkYXRhLm1haW5Db250ZW50LFxuICAgICAgICAgICAgICB0b2tlbnM6IGxleGVyLmlubGluZVRva2VucyhkYXRhLm1haW5Db250ZW50KSxcbiAgICAgICAgICAgICAgbmVzdGVkVG9rZW5zXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8vIEFsbG93IHJlY3Vyc2l2ZSBuZXN0aW5nXG4gICAgICAgICAgICBjdXN0b21OZXN0ZWRQYXJzZXI6IHBhcnNlVGFza0xpc3RDb250ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgICBsZXhlclxuICAgICAgICApO1xuICAgICAgICBpZiAobmVzdGVkUmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0YXNrTGlzdFwiLFxuICAgICAgICAgICAgICByYXc6IG5lc3RlZFJlc3VsdC5yYXcsXG4gICAgICAgICAgICAgIGl0ZW1zOiBuZXN0ZWRSZXN1bHQuaXRlbXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZXhlci5ibG9ja1Rva2Vucyhjb250ZW50KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZUluZGVudGVkQmxvY2tzKFxuICAgICAgICBzcmMsXG4gICAgICAgIHtcbiAgICAgICAgICBpdGVtUGF0dGVybjogL14oXFxzKikoWy0rKl0pXFxzK1xcWyhbIHhYXSlcXF1cXHMrKC4qKSQvLFxuICAgICAgICAgIGV4dHJhY3RJdGVtRGF0YTogKG1hdGNoKSA9PiAoe1xuICAgICAgICAgICAgaW5kZW50TGV2ZWw6IG1hdGNoWzFdLmxlbmd0aCxcbiAgICAgICAgICAgIG1haW5Db250ZW50OiBtYXRjaFs0XSxcbiAgICAgICAgICAgIGNoZWNrZWQ6IG1hdGNoWzNdLnRvTG93ZXJDYXNlKCkgPT09IFwieFwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgY3JlYXRlVG9rZW46IChkYXRhLCBuZXN0ZWRUb2tlbnMpID0+ICh7XG4gICAgICAgICAgICB0eXBlOiBcInRhc2tJdGVtXCIsXG4gICAgICAgICAgICByYXc6IFwiXCIsXG4gICAgICAgICAgICBtYWluQ29udGVudDogZGF0YS5tYWluQ29udGVudCxcbiAgICAgICAgICAgIGluZGVudExldmVsOiBkYXRhLmluZGVudExldmVsLFxuICAgICAgICAgICAgY2hlY2tlZDogZGF0YS5jaGVja2VkLFxuICAgICAgICAgICAgdGV4dDogZGF0YS5tYWluQ29udGVudCxcbiAgICAgICAgICAgIHRva2VuczogbGV4ZXIuaW5saW5lVG9rZW5zKGRhdGEubWFpbkNvbnRlbnQpLFxuICAgICAgICAgICAgbmVzdGVkVG9rZW5zXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLy8gVXNlIHRoZSByZWN1cnNpdmUgcGFyc2VyIGZvciBuZXN0ZWQgY29udGVudFxuICAgICAgICAgIGN1c3RvbU5lc3RlZFBhcnNlcjogcGFyc2VUYXNrTGlzdENvbnRlbnRcbiAgICAgICAgfSxcbiAgICAgICAgbGV4ZXJcbiAgICAgICk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0YXNrTGlzdFwiLFxuICAgICAgICByYXc6IHJlc3VsdC5yYXcsXG4gICAgICAgIGl0ZW1zOiByZXN1bHQuaXRlbXNcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBtYXJrZG93bk9wdGlvbnM6IHtcbiAgICBpbmRlbnRzQ29udGVudDogdHJ1ZVxuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9nZ2xlVGFza0xpc3Q6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtU2hpZnQtOVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVUYXNrTGlzdCgpXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9raXQvaW5kZXgudHNcbnZhciBMaXN0S2l0ID0gRXh0ZW5zaW9uMi5jcmVhdGUoe1xuICBuYW1lOiBcImxpc3RLaXRcIixcbiAgYWRkRXh0ZW5zaW9ucygpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gW107XG4gICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJ1bGxldExpc3QuY29uZmlndXJlKHRoaXMub3B0aW9ucy5idWxsZXRMaXN0KSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubGlzdEl0ZW0gIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGlzdEl0ZW0uY29uZmlndXJlKHRoaXMub3B0aW9ucy5saXN0SXRlbSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpc3RLZXltYXAgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGlzdEtleW1hcC5jb25maWd1cmUodGhpcy5vcHRpb25zLmxpc3RLZXltYXApKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vcmRlcmVkTGlzdCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChPcmRlcmVkTGlzdC5jb25maWd1cmUodGhpcy5vcHRpb25zLm9yZGVyZWRMaXN0KSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFza0l0ZW0gIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVGFza0l0ZW0uY29uZmlndXJlKHRoaXMub3B0aW9ucy50YXNrSXRlbSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRhc2tMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFRhc2tMaXN0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMudGFza0xpc3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvbnM7XG4gIH1cbn0pO1xuZXhwb3J0IHtcbiAgQnVsbGV0TGlzdCxcbiAgTGlzdEl0ZW0sXG4gIExpc3RLZXltYXAsXG4gIExpc3RLaXQsXG4gIE9yZGVyZWRMaXN0LFxuICBUYXNrSXRlbSxcbiAgVGFza0xpc3QsXG4gIGJ1bGxldExpc3RJbnB1dFJlZ2V4LFxuICBpbnB1dFJlZ2V4LFxuICBsaXN0SGVscGVyc19leHBvcnRzIGFzIGxpc3RIZWxwZXJzLFxuICBvcmRlcmVkTGlzdElucHV0UmVnZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-mention/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-mention/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mention: () => (/* binding */ Mention),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/model */ \"(ssr)/./node_modules/@tiptap/pm/dist/model/index.js\");\n/* harmony import */ var _tiptap_suggestion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/suggestion */ \"(ssr)/./node_modules/@tiptap/suggestion/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n// src/mention.ts\n\n\n\n\n// src/utils/get-default-suggestion-attributes.ts\n\nfunction getSuggestionOptions({\n  editor: tiptapEditor,\n  overrideSuggestionOptions,\n  extensionName,\n  char = \"@\"\n}) {\n  const pluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey();\n  return {\n    editor: tiptapEditor,\n    char,\n    pluginKey,\n    command: ({ editor, range, props }) => {\n      var _a, _b, _c;\n      const nodeAfter = editor.view.state.selection.$to.nodeAfter;\n      const overrideSpace = (_a = nodeAfter == null ? void 0 : nodeAfter.text) == null ? void 0 : _a.startsWith(\" \");\n      if (overrideSpace) {\n        range.to += 1;\n      }\n      editor.chain().focus().insertContentAt(range, [\n        {\n          type: extensionName,\n          attrs: { ...props, mentionSuggestionChar: char }\n        },\n        {\n          type: \"text\",\n          text: \" \"\n        }\n      ]).run();\n      (_c = (_b = editor.view.dom.ownerDocument.defaultView) == null ? void 0 : _b.getSelection()) == null ? void 0 : _c.collapseToEnd();\n    },\n    allow: ({ state, range }) => {\n      const $from = state.doc.resolve(range.from);\n      const type = state.schema.nodes[extensionName];\n      const allow = !!$from.parent.type.contentMatch.matchType(type);\n      return allow;\n    },\n    ...overrideSuggestionOptions\n  };\n}\n\n// src/mention.ts\nfunction getSuggestions(options) {\n  return (options.options.suggestions.length ? options.options.suggestions : [options.options.suggestion]).map(\n    (suggestion) => getSuggestionOptions({\n      // @ts-ignore `editor` can be `undefined` when converting the document to HTML with the HTML utility\n      editor: options.editor,\n      overrideSuggestionOptions: suggestion,\n      extensionName: options.name,\n      char: suggestion.char\n    })\n  );\n}\nfunction getSuggestionFromChar(options, char) {\n  const suggestions = getSuggestions(options);\n  const suggestion = suggestions.find((s) => s.char === char);\n  if (suggestion) {\n    return suggestion;\n  }\n  if (suggestions.length) {\n    return suggestions[0];\n  }\n  return null;\n}\nvar Mention = _tiptap_core__WEBPACK_IMPORTED_MODULE_3__.Node.create({\n  name: \"mention\",\n  priority: 101,\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      renderText({ node, suggestion }) {\n        var _a, _b;\n        return `${(_a = suggestion == null ? void 0 : suggestion.char) != null ? _a : \"@\"}${(_b = node.attrs.label) != null ? _b : node.attrs.id}`;\n      },\n      deleteTriggerWithBackspace: false,\n      renderHTML({ options, node, suggestion }) {\n        var _a, _b;\n        return [\n          \"span\",\n          (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_3__.mergeAttributes)(this.HTMLAttributes, options.HTMLAttributes),\n          `${(_a = suggestion == null ? void 0 : suggestion.char) != null ? _a : \"@\"}${(_b = node.attrs.label) != null ? _b : node.attrs.id}`\n        ];\n      },\n      suggestions: [],\n      suggestion: {}\n    };\n  },\n  group: \"inline\",\n  inline: true,\n  selectable: false,\n  atom: true,\n  addAttributes() {\n    return {\n      id: {\n        default: null,\n        parseHTML: (element) => element.getAttribute(\"data-id\"),\n        renderHTML: (attributes) => {\n          if (!attributes.id) {\n            return {};\n          }\n          return {\n            \"data-id\": attributes.id\n          };\n        }\n      },\n      label: {\n        default: null,\n        parseHTML: (element) => element.getAttribute(\"data-label\"),\n        renderHTML: (attributes) => {\n          if (!attributes.label) {\n            return {};\n          }\n          return {\n            \"data-label\": attributes.label\n          };\n        }\n      },\n      // When there are multiple types of mentions, this attribute helps distinguish them\n      mentionSuggestionChar: {\n        default: \"@\",\n        parseHTML: (element) => element.getAttribute(\"data-mention-suggestion-char\"),\n        renderHTML: (attributes) => {\n          return {\n            \"data-mention-suggestion-char\": attributes.mentionSuggestionChar\n          };\n        }\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: `span[data-type=\"${this.name}\"]`\n      }\n    ];\n  },\n  renderHTML({ node, HTMLAttributes }) {\n    const suggestion = getSuggestionFromChar(this, node.attrs.mentionSuggestionChar);\n    if (this.options.renderLabel !== void 0) {\n      console.warn(\"renderLabel is deprecated use renderText and renderHTML instead\");\n      return [\n        \"span\",\n        (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_3__.mergeAttributes)({ \"data-type\": this.name }, this.options.HTMLAttributes, HTMLAttributes),\n        this.options.renderLabel({\n          options: this.options,\n          node,\n          suggestion\n        })\n      ];\n    }\n    const mergedOptions = { ...this.options };\n    mergedOptions.HTMLAttributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_3__.mergeAttributes)(\n      { \"data-type\": this.name },\n      this.options.HTMLAttributes,\n      HTMLAttributes\n    );\n    const html = this.options.renderHTML({\n      options: mergedOptions,\n      node,\n      suggestion\n    });\n    if (typeof html === \"string\") {\n      return [\"span\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_3__.mergeAttributes)({ \"data-type\": this.name }, this.options.HTMLAttributes, HTMLAttributes), html];\n    }\n    return html;\n  },\n  ...(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_3__.createInlineMarkdownSpec)({\n    nodeName: \"mention\",\n    name: \"@\",\n    selfClosing: true,\n    allowedAttributes: [\"id\", \"label\"]\n  }),\n  renderText({ node }) {\n    const args = {\n      options: this.options,\n      node,\n      suggestion: getSuggestionFromChar(this, node.attrs.mentionSuggestionChar)\n    };\n    if (this.options.renderLabel !== void 0) {\n      console.warn(\"renderLabel is deprecated use renderText and renderHTML instead\");\n      return this.options.renderLabel(args);\n    }\n    return this.options.renderText(args);\n  },\n  addKeyboardShortcuts() {\n    return {\n      Backspace: () => this.editor.commands.command(({ tr, state }) => {\n        let isMention = false;\n        const { selection } = state;\n        const { empty, anchor } = selection;\n        if (!empty) {\n          return false;\n        }\n        let mentionNode = new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_0__.Node();\n        let mentionPos = 0;\n        state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {\n          if (node.type.name === this.name) {\n            isMention = true;\n            mentionNode = node;\n            mentionPos = pos;\n            return false;\n          }\n        });\n        if (isMention) {\n          tr.insertText(\n            this.options.deleteTriggerWithBackspace ? \"\" : mentionNode.attrs.mentionSuggestionChar,\n            mentionPos,\n            mentionPos + mentionNode.nodeSize\n          );\n        }\n        return isMention;\n      })\n    };\n  },\n  addProseMirrorPlugins() {\n    return getSuggestions(this).map(_tiptap_suggestion__WEBPACK_IMPORTED_MODULE_1__.Suggestion);\n  }\n});\n\n// src/index.ts\nvar index_default = Mention;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbWVudGlvbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQytFO0FBQ3BCO0FBQ1g7O0FBRWhEO0FBQzZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCLHVEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOENBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBLGtCQUFrQix3RUFBd0UsRUFBRSxxREFBcUQ7QUFDakosT0FBTztBQUNQO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxVQUFVLDZEQUFlO0FBQ3pCLGFBQWEsd0VBQXdFLEVBQUUscURBQXFEO0FBQzVJO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZEQUFlLEdBQUcsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsbUNBQW1DLDZEQUFlO0FBQ2xELFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLDZEQUFlLEdBQUcsd0JBQXdCO0FBQ2hFO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsS0FBSyxzRUFBd0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1REFBdUQsV0FBVztBQUNsRTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtEQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBLG9DQUFvQywwREFBVTtBQUM5QztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYW5iYW5wcm8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbWVudGlvbi9kaXN0L2luZGV4LmpzPzY3MWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL21lbnRpb24udHNcbmltcG9ydCB7IGNyZWF0ZUlubGluZU1hcmtkb3duU3BlYywgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuaW1wb3J0IHsgU3VnZ2VzdGlvbiB9IGZyb20gXCJAdGlwdGFwL3N1Z2dlc3Rpb25cIjtcblxuLy8gc3JjL3V0aWxzL2dldC1kZWZhdWx0LXN1Z2dlc3Rpb24tYXR0cmlidXRlcy50c1xuaW1wb3J0IHsgUGx1Z2luS2V5IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmZ1bmN0aW9uIGdldFN1Z2dlc3Rpb25PcHRpb25zKHtcbiAgZWRpdG9yOiB0aXB0YXBFZGl0b3IsXG4gIG92ZXJyaWRlU3VnZ2VzdGlvbk9wdGlvbnMsXG4gIGV4dGVuc2lvbk5hbWUsXG4gIGNoYXIgPSBcIkBcIlxufSkge1xuICBjb25zdCBwbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KCk7XG4gIHJldHVybiB7XG4gICAgZWRpdG9yOiB0aXB0YXBFZGl0b3IsXG4gICAgY2hhcixcbiAgICBwbHVnaW5LZXksXG4gICAgY29tbWFuZDogKHsgZWRpdG9yLCByYW5nZSwgcHJvcHMgfSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICBjb25zdCBub2RlQWZ0ZXIgPSBlZGl0b3Iudmlldy5zdGF0ZS5zZWxlY3Rpb24uJHRvLm5vZGVBZnRlcjtcbiAgICAgIGNvbnN0IG92ZXJyaWRlU3BhY2UgPSAoX2EgPSBub2RlQWZ0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGVBZnRlci50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RhcnRzV2l0aChcIiBcIik7XG4gICAgICBpZiAob3ZlcnJpZGVTcGFjZSkge1xuICAgICAgICByYW5nZS50byArPSAxO1xuICAgICAgfVxuICAgICAgZWRpdG9yLmNoYWluKCkuZm9jdXMoKS5pbnNlcnRDb250ZW50QXQocmFuZ2UsIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IGV4dGVuc2lvbk5hbWUsXG4gICAgICAgICAgYXR0cnM6IHsgLi4ucHJvcHMsIG1lbnRpb25TdWdnZXN0aW9uQ2hhcjogY2hhciB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICB0ZXh0OiBcIiBcIlxuICAgICAgICB9XG4gICAgICBdKS5ydW4oKTtcbiAgICAgIChfYyA9IChfYiA9IGVkaXRvci52aWV3LmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogX2IuZ2V0U2VsZWN0aW9uKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jb2xsYXBzZVRvRW5kKCk7XG4gICAgfSxcbiAgICBhbGxvdzogKHsgc3RhdGUsIHJhbmdlIH0pID0+IHtcbiAgICAgIGNvbnN0ICRmcm9tID0gc3RhdGUuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSk7XG4gICAgICBjb25zdCB0eXBlID0gc3RhdGUuc2NoZW1hLm5vZGVzW2V4dGVuc2lvbk5hbWVdO1xuICAgICAgY29uc3QgYWxsb3cgPSAhISRmcm9tLnBhcmVudC50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUodHlwZSk7XG4gICAgICByZXR1cm4gYWxsb3c7XG4gICAgfSxcbiAgICAuLi5vdmVycmlkZVN1Z2dlc3Rpb25PcHRpb25zXG4gIH07XG59XG5cbi8vIHNyYy9tZW50aW9uLnRzXG5mdW5jdGlvbiBnZXRTdWdnZXN0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiAob3B0aW9ucy5vcHRpb25zLnN1Z2dlc3Rpb25zLmxlbmd0aCA/IG9wdGlvbnMub3B0aW9ucy5zdWdnZXN0aW9ucyA6IFtvcHRpb25zLm9wdGlvbnMuc3VnZ2VzdGlvbl0pLm1hcChcbiAgICAoc3VnZ2VzdGlvbikgPT4gZ2V0U3VnZ2VzdGlvbk9wdGlvbnMoe1xuICAgICAgLy8gQHRzLWlnbm9yZSBgZWRpdG9yYCBjYW4gYmUgYHVuZGVmaW5lZGAgd2hlbiBjb252ZXJ0aW5nIHRoZSBkb2N1bWVudCB0byBIVE1MIHdpdGggdGhlIEhUTUwgdXRpbGl0eVxuICAgICAgZWRpdG9yOiBvcHRpb25zLmVkaXRvcixcbiAgICAgIG92ZXJyaWRlU3VnZ2VzdGlvbk9wdGlvbnM6IHN1Z2dlc3Rpb24sXG4gICAgICBleHRlbnNpb25OYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgICBjaGFyOiBzdWdnZXN0aW9uLmNoYXJcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gZ2V0U3VnZ2VzdGlvbkZyb21DaGFyKG9wdGlvbnMsIGNoYXIpIHtcbiAgY29uc3Qgc3VnZ2VzdGlvbnMgPSBnZXRTdWdnZXN0aW9ucyhvcHRpb25zKTtcbiAgY29uc3Qgc3VnZ2VzdGlvbiA9IHN1Z2dlc3Rpb25zLmZpbmQoKHMpID0+IHMuY2hhciA9PT0gY2hhcik7XG4gIGlmIChzdWdnZXN0aW9uKSB7XG4gICAgcmV0dXJuIHN1Z2dlc3Rpb247XG4gIH1cbiAgaWYgKHN1Z2dlc3Rpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBzdWdnZXN0aW9uc1swXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbnZhciBNZW50aW9uID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcIm1lbnRpb25cIixcbiAgcHJpb3JpdHk6IDEwMSxcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgcmVuZGVyVGV4dCh7IG5vZGUsIHN1Z2dlc3Rpb24gfSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gYCR7KF9hID0gc3VnZ2VzdGlvbiA9PSBudWxsID8gdm9pZCAwIDogc3VnZ2VzdGlvbi5jaGFyKSAhPSBudWxsID8gX2EgOiBcIkBcIn0keyhfYiA9IG5vZGUuYXR0cnMubGFiZWwpICE9IG51bGwgPyBfYiA6IG5vZGUuYXR0cnMuaWR9YDtcbiAgICAgIH0sXG4gICAgICBkZWxldGVUcmlnZ2VyV2l0aEJhY2tzcGFjZTogZmFsc2UsXG4gICAgICByZW5kZXJIVE1MKHsgb3B0aW9ucywgbm9kZSwgc3VnZ2VzdGlvbiB9KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMuSFRNTEF0dHJpYnV0ZXMsIG9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMpLFxuICAgICAgICAgIGAkeyhfYSA9IHN1Z2dlc3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IHN1Z2dlc3Rpb24uY2hhcikgIT0gbnVsbCA/IF9hIDogXCJAXCJ9JHsoX2IgPSBub2RlLmF0dHJzLmxhYmVsKSAhPSBudWxsID8gX2IgOiBub2RlLmF0dHJzLmlkfWBcbiAgICAgICAgXTtcbiAgICAgIH0sXG4gICAgICBzdWdnZXN0aW9uczogW10sXG4gICAgICBzdWdnZXN0aW9uOiB7fVxuICAgIH07XG4gIH0sXG4gIGdyb3VwOiBcImlubGluZVwiLFxuICBpbmxpbmU6IHRydWUsXG4gIHNlbGVjdGFibGU6IGZhbHNlLFxuICBhdG9tOiB0cnVlLFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDoge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtaWRcIiksXG4gICAgICAgIHJlbmRlckhUTUw6IChhdHRyaWJ1dGVzKSA9PiB7XG4gICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmlkKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcImRhdGEtaWRcIjogYXR0cmlidXRlcy5pZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbGFiZWxcIiksXG4gICAgICAgIHJlbmRlckhUTUw6IChhdHRyaWJ1dGVzKSA9PiB7XG4gICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcImRhdGEtbGFiZWxcIjogYXR0cmlidXRlcy5sYWJlbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSB0eXBlcyBvZiBtZW50aW9ucywgdGhpcyBhdHRyaWJ1dGUgaGVscHMgZGlzdGluZ3Vpc2ggdGhlbVxuICAgICAgbWVudGlvblN1Z2dlc3Rpb25DaGFyOiB7XG4gICAgICAgIGRlZmF1bHQ6IFwiQFwiLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWVudGlvbi1zdWdnZXN0aW9uLWNoYXJcIiksXG4gICAgICAgIHJlbmRlckhUTUw6IChhdHRyaWJ1dGVzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwiZGF0YS1tZW50aW9uLXN1Z2dlc3Rpb24tY2hhclwiOiBhdHRyaWJ1dGVzLm1lbnRpb25TdWdnZXN0aW9uQ2hhclxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBgc3BhbltkYXRhLXR5cGU9XCIke3RoaXMubmFtZX1cIl1gXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICBjb25zdCBzdWdnZXN0aW9uID0gZ2V0U3VnZ2VzdGlvbkZyb21DaGFyKHRoaXMsIG5vZGUuYXR0cnMubWVudGlvblN1Z2dlc3Rpb25DaGFyKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlbmRlckxhYmVsICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcInJlbmRlckxhYmVsIGlzIGRlcHJlY2F0ZWQgdXNlIHJlbmRlclRleHQgYW5kIHJlbmRlckhUTUwgaW5zdGVhZFwiKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFwic3BhblwiLFxuICAgICAgICBtZXJnZUF0dHJpYnV0ZXMoeyBcImRhdGEtdHlwZVwiOiB0aGlzLm5hbWUgfSwgdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksXG4gICAgICAgIHRoaXMub3B0aW9ucy5yZW5kZXJMYWJlbCh7XG4gICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgc3VnZ2VzdGlvblxuICAgICAgICB9KVxuICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zIH07XG4gICAgbWVyZ2VkT3B0aW9ucy5IVE1MQXR0cmlidXRlcyA9IG1lcmdlQXR0cmlidXRlcyhcbiAgICAgIHsgXCJkYXRhLXR5cGVcIjogdGhpcy5uYW1lIH0sXG4gICAgICB0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsXG4gICAgICBIVE1MQXR0cmlidXRlc1xuICAgICk7XG4gICAgY29uc3QgaHRtbCA9IHRoaXMub3B0aW9ucy5yZW5kZXJIVE1MKHtcbiAgICAgIG9wdGlvbnM6IG1lcmdlZE9wdGlvbnMsXG4gICAgICBub2RlLFxuICAgICAgc3VnZ2VzdGlvblxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgaHRtbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgbWVyZ2VBdHRyaWJ1dGVzKHsgXCJkYXRhLXR5cGVcIjogdGhpcy5uYW1lIH0sIHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCBodG1sXTtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH0sXG4gIC4uLmNyZWF0ZUlubGluZU1hcmtkb3duU3BlYyh7XG4gICAgbm9kZU5hbWU6IFwibWVudGlvblwiLFxuICAgIG5hbWU6IFwiQFwiLFxuICAgIHNlbGZDbG9zaW5nOiB0cnVlLFxuICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbXCJpZFwiLCBcImxhYmVsXCJdXG4gIH0pLFxuICByZW5kZXJUZXh0KHsgbm9kZSB9KSB7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIG5vZGUsXG4gICAgICBzdWdnZXN0aW9uOiBnZXRTdWdnZXN0aW9uRnJvbUNoYXIodGhpcywgbm9kZS5hdHRycy5tZW50aW9uU3VnZ2VzdGlvbkNoYXIpXG4gICAgfTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlbmRlckxhYmVsICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcInJlbmRlckxhYmVsIGlzIGRlcHJlY2F0ZWQgdXNlIHJlbmRlclRleHQgYW5kIHJlbmRlckhUTUwgaW5zdGVhZFwiKTtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmVuZGVyTGFiZWwoYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmVuZGVyVGV4dChhcmdzKTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEJhY2tzcGFjZTogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuY29tbWFuZCgoeyB0ciwgc3RhdGUgfSkgPT4ge1xuICAgICAgICBsZXQgaXNNZW50aW9uID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyBlbXB0eSwgYW5jaG9yIH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGlmICghZW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lbnRpb25Ob2RlID0gbmV3IFByb3NlTWlycm9yTm9kZSgpO1xuICAgICAgICBsZXQgbWVudGlvblBvcyA9IDA7XG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oYW5jaG9yIC0gMSwgYW5jaG9yLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUudHlwZS5uYW1lID09PSB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgIGlzTWVudGlvbiA9IHRydWU7XG4gICAgICAgICAgICBtZW50aW9uTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICBtZW50aW9uUG9zID0gcG9zO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc01lbnRpb24pIHtcbiAgICAgICAgICB0ci5pbnNlcnRUZXh0KFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRlbGV0ZVRyaWdnZXJXaXRoQmFja3NwYWNlID8gXCJcIiA6IG1lbnRpb25Ob2RlLmF0dHJzLm1lbnRpb25TdWdnZXN0aW9uQ2hhcixcbiAgICAgICAgICAgIG1lbnRpb25Qb3MsXG4gICAgICAgICAgICBtZW50aW9uUG9zICsgbWVudGlvbk5vZGUubm9kZVNpemVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc01lbnRpb247XG4gICAgICB9KVxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gZ2V0U3VnZ2VzdGlvbnModGhpcykubWFwKFN1Z2dlc3Rpb24pO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IE1lbnRpb247XG5leHBvcnQge1xuICBNZW50aW9uLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-mention/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-ordered-list/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-ordered-list/dist/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrderedList: () => (/* reexport safe */ _tiptap_extension_list__WEBPACK_IMPORTED_MODULE_0__.OrderedList),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_extension_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-list */ \"(ssr)/./node_modules/@tiptap/extension-list/dist/index.js\");\n// src/index.ts\n\n\nvar index_default = _tiptap_extension_list__WEBPACK_IMPORTED_MODULE_0__.OrderedList;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tb3JkZXJlZC1saXN0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDcUQ7QUFDZ0I7QUFDckUsb0JBQW9CLCtEQUFXO0FBSTdCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYW5iYW5wcm8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tb3JkZXJlZC1saXN0L2Rpc3QvaW5kZXguanM/NzFlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IE9yZGVyZWRMaXN0IH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWxpc3RcIjtcbmltcG9ydCB7IE9yZGVyZWRMaXN0IGFzIE9yZGVyZWRMaXN0MiB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1saXN0XCI7XG52YXIgaW5kZXhfZGVmYXVsdCA9IE9yZGVyZWRMaXN0O1xuZXhwb3J0IHtcbiAgT3JkZXJlZExpc3QyIGFzIE9yZGVyZWRMaXN0LFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-ordered-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-paragraph/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Paragraph: () => (/* binding */ Paragraph),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/paragraph.ts\n\nvar Paragraph = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"paragraph\",\n  priority: 1e3,\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block\",\n  content: \"inline*\",\n  parseHTML() {\n    return [{ tag: \"p\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"p\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  parseMarkdown: (token, helpers) => {\n    const tokens = token.tokens || [];\n    if (tokens.length === 1 && tokens[0].type === \"image\") {\n      return helpers.parseChildren([tokens[0]]);\n    }\n    return helpers.createNode(\n      \"paragraph\",\n      void 0,\n      // no attributes for paragraph\n      helpers.parseInline(tokens)\n    );\n  },\n  renderMarkdown: (node, h) => {\n    if (!node || !Array.isArray(node.content)) {\n      return \"\";\n    }\n    return h.renderChildren(node.content);\n  },\n  addCommands() {\n    return {\n      setParagraph: () => ({ commands }) => {\n        return commands.setNode(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-0\": () => this.editor.commands.setParagraph()\n    };\n  }\n});\n\n// src/index.ts\nvar index_default = Paragraph;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDcUQ7QUFDckQsZ0JBQWdCLDhDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEIsR0FBRztBQUNILGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQiw2REFBZTtBQUNoQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYW5iYW5wcm8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoL2Rpc3QvaW5kZXguanM/NjRmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcGFyYWdyYXBoLnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgUGFyYWdyYXBoID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcInBhcmFncmFwaFwiLFxuICBwcmlvcml0eTogMWUzLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBncm91cDogXCJibG9ja1wiLFxuICBjb250ZW50OiBcImlubGluZSpcIixcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6IFwicFwiIH1dO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXCJwXCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gIH0sXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIGNvbnN0IHRva2VucyA9IHRva2VuLnRva2VucyB8fCBbXTtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSAmJiB0b2tlbnNbMF0udHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICByZXR1cm4gaGVscGVycy5wYXJzZUNoaWxkcmVuKFt0b2tlbnNbMF1dKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlbHBlcnMuY3JlYXRlTm9kZShcbiAgICAgIFwicGFyYWdyYXBoXCIsXG4gICAgICB2b2lkIDAsXG4gICAgICAvLyBubyBhdHRyaWJ1dGVzIGZvciBwYXJhZ3JhcGhcbiAgICAgIGhlbHBlcnMucGFyc2VJbmxpbmUodG9rZW5zKVxuICAgICk7XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaCkgPT4ge1xuICAgIGlmICghbm9kZSB8fCAhQXJyYXkuaXNBcnJheShub2RlLmNvbnRlbnQpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGgucmVuZGVyQ2hpbGRyZW4obm9kZS5jb250ZW50KTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFBhcmFncmFwaDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1BbHQtMFwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRQYXJhZ3JhcGgoKVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gUGFyYWdyYXBoO1xuZXhwb3J0IHtcbiAgUGFyYWdyYXBoLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-placeholder/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-placeholder/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Placeholder: () => (/* reexport safe */ _tiptap_extensions__WEBPACK_IMPORTED_MODULE_0__.Placeholder),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extensions */ \"(ssr)/./node_modules/@tiptap/extensions/dist/index.js\");\n// src/index.ts\n\n\nvar index_default = _tiptap_extensions__WEBPACK_IMPORTED_MODULE_0__.Placeholder;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGxhY2Vob2xkZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNpRDtBQUNnQjtBQUNqRSxvQkFBb0IsMkRBQVc7QUFJN0I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2thbmJhbnByby8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1wbGFjZWhvbGRlci9kaXN0L2luZGV4LmpzP2JiYjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBQbGFjZWhvbGRlciB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbnNcIjtcbmltcG9ydCB7IFBsYWNlaG9sZGVyIGFzIFBsYWNlaG9sZGVyMiB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbnNcIjtcbnZhciBpbmRleF9kZWZhdWx0ID0gUGxhY2Vob2xkZXI7XG5leHBvcnQge1xuICBQbGFjZWhvbGRlcjIgYXMgUGxhY2Vob2xkZXIsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-placeholder/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-strike/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Strike: () => (/* binding */ Strike),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/strike.ts\n\nvar inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/;\nvar pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g;\nvar Strike = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"strike\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"s\"\n      },\n      {\n        tag: \"del\"\n      },\n      {\n        tag: \"strike\"\n      },\n      {\n        style: \"text-decoration\",\n        consuming: false,\n        getAttrs: (style) => style.includes(\"line-through\") ? {} : false\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"s\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"del\",\n  parseMarkdown: (token, helpers) => {\n    return helpers.applyMark(\"strike\", helpers.parseInline(token.tokens || []));\n  },\n  renderMarkdown: (node, h) => {\n    return `~~${h.renderChildren(node)}~~`;\n  },\n  addCommands() {\n    return {\n      setStrike: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleStrike: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetStrike: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-s\": () => this.editor.commands.toggleStrike()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: inputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: pasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Strike;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNtRjtBQUNuRjtBQUNBO0FBQ0EsYUFBYSw4Q0FBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQixpQkFBaUIsNkRBQWU7QUFDaEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkMsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBLE9BQU87QUFDUCw2QkFBNkIsVUFBVTtBQUN2QztBQUNBLE9BQU87QUFDUCw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sMkRBQWE7QUFDbkI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FuYmFucHJvLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXN0cmlrZS9kaXN0L2luZGV4LmpzPzBmMDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3N0cmlrZS50c1xuaW1wb3J0IHsgTWFyaywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIGlucHV0UmVnZXggPSAvKD86XnxcXHMpKH5+KD8hXFxzK35+KSgoPzpbXn5dKykpfn4oPyFcXHMrfn4pKSQvO1xudmFyIHBhc3RlUmVnZXggPSAvKD86XnxcXHMpKH5+KD8hXFxzK35+KSgoPzpbXn5dKykpfn4oPyFcXHMrfn4pKS9nO1xudmFyIFN0cmlrZSA9IE1hcmsuY3JlYXRlKHtcbiAgbmFtZTogXCJzdHJpa2VcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJkZWxcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInN0cmlrZVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogXCJ0ZXh0LWRlY29yYXRpb25cIixcbiAgICAgICAgY29uc3VtaW5nOiBmYWxzZSxcbiAgICAgICAgZ2V0QXR0cnM6IChzdHlsZSkgPT4gc3R5bGUuaW5jbHVkZXMoXCJsaW5lLXRocm91Z2hcIikgPyB7fSA6IGZhbHNlXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1wic1wiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBtYXJrZG93blRva2VuTmFtZTogXCJkZWxcIixcbiAgcGFyc2VNYXJrZG93bjogKHRva2VuLCBoZWxwZXJzKSA9PiB7XG4gICAgcmV0dXJuIGhlbHBlcnMuYXBwbHlNYXJrKFwic3RyaWtlXCIsIGhlbHBlcnMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zIHx8IFtdKSk7XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaCkgPT4ge1xuICAgIHJldHVybiBgfn4ke2gucmVuZGVyQ2hpbGRyZW4obm9kZSl9fn5gO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0U3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlU3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdW5zZXRTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1TaGlmdC1zXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVN0cmlrZSgpXG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9LFxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogcGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gU3RyaWtlO1xuZXhwb3J0IHtcbiAgU3RyaWtlLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGlucHV0UmVnZXgsXG4gIHBhc3RlUmVnZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-text-align/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-text-align/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextAlign: () => (/* binding */ TextAlign),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/text-align.ts\n\nvar TextAlign = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n  name: \"textAlign\",\n  addOptions() {\n    return {\n      types: [],\n      alignments: [\"left\", \"center\", \"right\", \"justify\"],\n      defaultAlignment: null\n    };\n  },\n  addGlobalAttributes() {\n    return [\n      {\n        types: this.options.types,\n        attributes: {\n          textAlign: {\n            default: this.options.defaultAlignment,\n            parseHTML: (element) => {\n              const alignment = element.style.textAlign;\n              return this.options.alignments.includes(alignment) ? alignment : this.options.defaultAlignment;\n            },\n            renderHTML: (attributes) => {\n              if (!attributes.textAlign) {\n                return {};\n              }\n              return { style: `text-align: ${attributes.textAlign}` };\n            }\n          }\n        }\n      }\n    ];\n  },\n  addCommands() {\n    return {\n      setTextAlign: (alignment) => ({ commands }) => {\n        if (!this.options.alignments.includes(alignment)) {\n          return false;\n        }\n        return this.options.types.map((type) => commands.updateAttributes(type, { textAlign: alignment })).some((response) => response);\n      },\n      unsetTextAlign: () => ({ commands }) => {\n        return this.options.types.map((type) => commands.resetAttributes(type, \"textAlign\")).some((response) => response);\n      },\n      toggleTextAlign: (alignment) => ({ editor, commands }) => {\n        if (!this.options.alignments.includes(alignment)) {\n          return false;\n        }\n        if (editor.isActive({ textAlign: alignment })) {\n          return commands.unsetTextAlign();\n        }\n        return commands.setTextAlign(alignment);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-l\": () => this.editor.commands.setTextAlign(\"left\"),\n      \"Mod-Shift-e\": () => this.editor.commands.setTextAlign(\"center\"),\n      \"Mod-Shift-r\": () => this.editor.commands.setTextAlign(\"right\"),\n      \"Mod-Shift-j\": () => this.editor.commands.setTextAlign(\"justify\")\n    };\n  }\n});\n\n// src/index.ts\nvar index_default = TextAlign;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC1hbGlnbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ3lDO0FBQ3pDLGdCQUFnQixtREFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0IscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixzQkFBc0I7QUFDeEcsT0FBTztBQUNQLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0EsT0FBTztBQUNQLHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FuYmFucHJvLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXRleHQtYWxpZ24vZGlzdC9pbmRleC5qcz85ZWRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy90ZXh0LWFsaWduLnRzXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgVGV4dEFsaWduID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwidGV4dEFsaWduXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGVzOiBbXSxcbiAgICAgIGFsaWdubWVudHM6IFtcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiLCBcImp1c3RpZnlcIl0sXG4gICAgICBkZWZhdWx0QWxpZ25tZW50OiBudWxsXG4gICAgfTtcbiAgfSxcbiAgYWRkR2xvYmFsQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlczogdGhpcy5vcHRpb25zLnR5cGVzLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgdGV4dEFsaWduOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMuZGVmYXVsdEFsaWdubWVudCxcbiAgICAgICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gZWxlbWVudC5zdHlsZS50ZXh0QWxpZ247XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYWxpZ25tZW50cy5pbmNsdWRlcyhhbGlnbm1lbnQpID8gYWxpZ25tZW50IDogdGhpcy5vcHRpb25zLmRlZmF1bHRBbGlnbm1lbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVuZGVySFRNTDogKGF0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLnRleHRBbGlnbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4geyBzdHlsZTogYHRleHQtYWxpZ246ICR7YXR0cmlidXRlcy50ZXh0QWxpZ259YCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRUZXh0QWxpZ246IChhbGlnbm1lbnQpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxpZ25tZW50cy5pbmNsdWRlcyhhbGlnbm1lbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZXMubWFwKCh0eXBlKSA9PiBjb21tYW5kcy51cGRhdGVBdHRyaWJ1dGVzKHR5cGUsIHsgdGV4dEFsaWduOiBhbGlnbm1lbnQgfSkpLnNvbWUoKHJlc3BvbnNlKSA9PiByZXNwb25zZSk7XG4gICAgICB9LFxuICAgICAgdW5zZXRUZXh0QWxpZ246ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlcy5tYXAoKHR5cGUpID0+IGNvbW1hbmRzLnJlc2V0QXR0cmlidXRlcyh0eXBlLCBcInRleHRBbGlnblwiKSkuc29tZSgocmVzcG9uc2UpID0+IHJlc3BvbnNlKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVUZXh0QWxpZ246IChhbGlnbm1lbnQpID0+ICh7IGVkaXRvciwgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGlnbm1lbnRzLmluY2x1ZGVzKGFsaWdubWVudCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkaXRvci5pc0FjdGl2ZSh7IHRleHRBbGlnbjogYWxpZ25tZW50IH0pKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0VGV4dEFsaWduKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldFRleHRBbGlnbihhbGlnbm1lbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1TaGlmdC1sXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFRleHRBbGlnbihcImxlZnRcIiksXG4gICAgICBcIk1vZC1TaGlmdC1lXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFRleHRBbGlnbihcImNlbnRlclwiKSxcbiAgICAgIFwiTW9kLVNoaWZ0LXJcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0VGV4dEFsaWduKFwicmlnaHRcIiksXG4gICAgICBcIk1vZC1TaGlmdC1qXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFRleHRBbGlnbihcImp1c3RpZnlcIilcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IFRleHRBbGlnbjtcbmV4cG9ydCB7XG4gIFRleHRBbGlnbixcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-text-align/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-text/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-text/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/text.ts\n\nvar Text = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"text\",\n  group: \"inline\",\n  parseMarkdown: (token) => {\n    return {\n      type: \"text\",\n      text: token.text || \"\"\n    };\n  },\n  renderMarkdown: (node) => node.text || \"\"\n});\n\n// src/index.ts\nvar index_default = Text;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ29DO0FBQ3BDLFdBQVcsOENBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYW5iYW5wcm8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC9kaXN0L2luZGV4LmpzPzdmOGIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3RleHQudHNcbmltcG9ydCB7IE5vZGUgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgVGV4dCA9IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIGdyb3VwOiBcImlubGluZVwiLFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICB0ZXh0OiB0b2tlbi50ZXh0IHx8IFwiXCJcbiAgICB9O1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUpID0+IG5vZGUudGV4dCB8fCBcIlwiXG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IFRleHQ7XG5leHBvcnQge1xuICBUZXh0LFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-underline/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Underline: () => (/* binding */ Underline),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/underline.ts\n\nvar Underline = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"underline\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"u\"\n      },\n      {\n        style: \"text-decoration\",\n        consuming: false,\n        getAttrs: (style) => style.includes(\"underline\") ? {} : false\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"u\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  parseMarkdown(token, helpers) {\n    return helpers.applyMark(this.name || \"underline\", helpers.parseInline(token.tokens || []));\n  },\n  renderMarkdown(node, helpers) {\n    return `++${helpers.renderChildren(node)}++`;\n  },\n  markdownTokenizer: {\n    name: \"underline\",\n    level: \"inline\",\n    start(src) {\n      return src.indexOf(\"++\");\n    },\n    tokenize(src, _tokens, lexer) {\n      const rule = /^(\\+\\+)([\\s\\S]+?)(\\+\\+)/;\n      const match = rule.exec(src);\n      if (!match) {\n        return void 0;\n      }\n      const innerContent = match[2].trim();\n      return {\n        type: \"underline\",\n        raw: match[0],\n        text: innerContent,\n        tokens: lexer.inlineTokens(innerContent)\n      };\n    }\n  },\n  addCommands() {\n    return {\n      setUnderline: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleUnderline: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetUnderline: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-u\": () => this.editor.commands.toggleUnderline(),\n      \"Mod-U\": () => this.editor.commands.toggleUnderline()\n    };\n  }\n});\n\n// src/index.ts\nvar index_default = Underline;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDcUQ7QUFDckQsZ0JBQWdCLDhDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZSxnQkFBZ0I7QUFDL0IsaUJBQWlCLDZEQUFlO0FBQ2hDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBLE9BQU87QUFDUCxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBLE9BQU87QUFDUCwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2thbmJhbnByby8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi11bmRlcmxpbmUvZGlzdC9pbmRleC5qcz81ZmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91bmRlcmxpbmUudHNcbmltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBVbmRlcmxpbmUgPSBNYXJrLmNyZWF0ZSh7XG4gIG5hbWU6IFwidW5kZXJsaW5lXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwidVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogXCJ0ZXh0LWRlY29yYXRpb25cIixcbiAgICAgICAgY29uc3VtaW5nOiBmYWxzZSxcbiAgICAgICAgZ2V0QXR0cnM6IChzdHlsZSkgPT4gc3R5bGUuaW5jbHVkZXMoXCJ1bmRlcmxpbmVcIikgPyB7fSA6IGZhbHNlXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1widVwiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBwYXJzZU1hcmtkb3duKHRva2VuLCBoZWxwZXJzKSB7XG4gICAgcmV0dXJuIGhlbHBlcnMuYXBwbHlNYXJrKHRoaXMubmFtZSB8fCBcInVuZGVybGluZVwiLCBoZWxwZXJzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucyB8fCBbXSkpO1xuICB9LFxuICByZW5kZXJNYXJrZG93bihub2RlLCBoZWxwZXJzKSB7XG4gICAgcmV0dXJuIGArKyR7aGVscGVycy5yZW5kZXJDaGlsZHJlbihub2RlKX0rK2A7XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5pemVyOiB7XG4gICAgbmFtZTogXCJ1bmRlcmxpbmVcIixcbiAgICBsZXZlbDogXCJpbmxpbmVcIixcbiAgICBzdGFydChzcmMpIHtcbiAgICAgIHJldHVybiBzcmMuaW5kZXhPZihcIisrXCIpO1xuICAgIH0sXG4gICAgdG9rZW5pemUoc3JjLCBfdG9rZW5zLCBsZXhlcikge1xuICAgICAgY29uc3QgcnVsZSA9IC9eKFxcK1xcKykoW1xcc1xcU10rPykoXFwrXFwrKS87XG4gICAgICBjb25zdCBtYXRjaCA9IHJ1bGUuZXhlYyhzcmMpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5uZXJDb250ZW50ID0gbWF0Y2hbMl0udHJpbSgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1bmRlcmxpbmVcIixcbiAgICAgICAgcmF3OiBtYXRjaFswXSxcbiAgICAgICAgdGV4dDogaW5uZXJDb250ZW50LFxuICAgICAgICB0b2tlbnM6IGxleGVyLmlubGluZVRva2Vucyhpbm5lckNvbnRlbnQpXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFVuZGVybGluZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZVVuZGVybGluZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHVuc2V0VW5kZXJsaW5lOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtdVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVVbmRlcmxpbmUoKSxcbiAgICAgIFwiTW9kLVVcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlVW5kZXJsaW5lKClcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IFVuZGVybGluZTtcbmV4cG9ydCB7XG4gIFVuZGVybGluZSxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extensions/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/extensions/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterCount: () => (/* binding */ CharacterCount),\n/* harmony export */   Dropcursor: () => (/* binding */ Dropcursor),\n/* harmony export */   Focus: () => (/* binding */ Focus),\n/* harmony export */   Gapcursor: () => (/* binding */ Gapcursor),\n/* harmony export */   Placeholder: () => (/* binding */ Placeholder),\n/* harmony export */   Selection: () => (/* binding */ Selection),\n/* harmony export */   TrailingNode: () => (/* binding */ TrailingNode),\n/* harmony export */   UndoRedo: () => (/* binding */ UndoRedo)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n/* harmony import */ var _tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/dropcursor */ \"(ssr)/./node_modules/@tiptap/pm/dist/dropcursor/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/dist/view/index.js\");\n/* harmony import */ var _tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/gapcursor */ \"(ssr)/./node_modules/@tiptap/pm/dist/gapcursor/index.js\");\n/* harmony import */ var _tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/history */ \"(ssr)/./node_modules/@tiptap/pm/dist/history/index.js\");\n// src/character-count/character-count.ts\n\n\nvar CharacterCount = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"characterCount\",\n  addOptions() {\n    return {\n      limit: null,\n      mode: \"textSize\",\n      textCounter: (text) => text.length,\n      wordCounter: (text) => text.split(\" \").filter((word) => word !== \"\").length\n    };\n  },\n  addStorage() {\n    return {\n      characters: () => 0,\n      words: () => 0\n    };\n  },\n  onBeforeCreate() {\n    this.storage.characters = (options) => {\n      const node = (options == null ? void 0 : options.node) || this.editor.state.doc;\n      const mode = (options == null ? void 0 : options.mode) || this.options.mode;\n      if (mode === \"textSize\") {\n        const text = node.textBetween(0, node.content.size, void 0, \" \");\n        return this.options.textCounter(text);\n      }\n      return node.nodeSize;\n    };\n    this.storage.words = (options) => {\n      const node = (options == null ? void 0 : options.node) || this.editor.state.doc;\n      const text = node.textBetween(0, node.content.size, \" \", \" \");\n      return this.options.wordCounter(text);\n    };\n  },\n  addProseMirrorPlugins() {\n    let initialEvaluationDone = false;\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"characterCount\"),\n        appendTransaction: (transactions, oldState, newState) => {\n          if (initialEvaluationDone) {\n            return;\n          }\n          const limit = this.options.limit;\n          if (limit === null || limit === void 0 || limit === 0) {\n            initialEvaluationDone = true;\n            return;\n          }\n          const initialContentSize = this.storage.characters({ node: newState.doc });\n          if (initialContentSize > limit) {\n            const over = initialContentSize - limit;\n            const from = 0;\n            const to = over;\n            console.warn(\n              `[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`\n            );\n            const tr = newState.tr.deleteRange(from, to);\n            initialEvaluationDone = true;\n            return tr;\n          }\n          initialEvaluationDone = true;\n        },\n        filterTransaction: (transaction, state) => {\n          const limit = this.options.limit;\n          if (!transaction.docChanged || limit === 0 || limit === null || limit === void 0) {\n            return true;\n          }\n          const oldSize = this.storage.characters({ node: state.doc });\n          const newSize = this.storage.characters({ node: transaction.doc });\n          if (newSize <= limit) {\n            return true;\n          }\n          if (oldSize > limit && newSize > limit && newSize <= oldSize) {\n            return true;\n          }\n          if (oldSize > limit && newSize > limit && newSize > oldSize) {\n            return false;\n          }\n          const isPaste = transaction.getMeta(\"paste\");\n          if (!isPaste) {\n            return false;\n          }\n          const pos = transaction.selection.$head.pos;\n          const over = newSize - limit;\n          const from = pos - over;\n          const to = pos;\n          transaction.deleteRange(from, to);\n          const updatedSize = this.storage.characters({ node: transaction.doc });\n          if (updatedSize > limit) {\n            return false;\n          }\n          return true;\n        }\n      })\n    ];\n  }\n});\n\n// src/drop-cursor/drop-cursor.ts\n\n\nvar Dropcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"dropCursor\",\n  addOptions() {\n    return {\n      color: \"currentColor\",\n      width: 1,\n      class: void 0\n    };\n  },\n  addProseMirrorPlugins() {\n    return [(0,_tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_2__.dropCursor)(this.options)];\n  }\n});\n\n// src/focus/focus.ts\n\n\n\nvar Focus = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"focus\",\n  addOptions() {\n    return {\n      className: \"has-focus\",\n      mode: \"all\"\n    };\n  },\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"focus\"),\n        props: {\n          decorations: ({ doc, selection }) => {\n            const { isEditable, isFocused } = this.editor;\n            const { anchor } = selection;\n            const decorations = [];\n            if (!isEditable || !isFocused) {\n              return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(doc, []);\n            }\n            let maxLevels = 0;\n            if (this.options.mode === \"deepest\") {\n              doc.descendants((node, pos) => {\n                if (node.isText) {\n                  return;\n                }\n                const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;\n                if (!isCurrent) {\n                  return false;\n                }\n                maxLevels += 1;\n              });\n            }\n            let currentLevel = 0;\n            doc.descendants((node, pos) => {\n              if (node.isText) {\n                return false;\n              }\n              const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;\n              if (!isCurrent) {\n                return false;\n              }\n              currentLevel += 1;\n              const outOfScope = this.options.mode === \"deepest\" && maxLevels - currentLevel > 0 || this.options.mode === \"shallowest\" && currentLevel > 1;\n              if (outOfScope) {\n                return this.options.mode === \"deepest\";\n              }\n              decorations.push(\n                _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.node(pos, pos + node.nodeSize, {\n                  class: this.options.className\n                })\n              );\n            });\n            return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(doc, decorations);\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/gap-cursor/gap-cursor.ts\n\n\nvar Gapcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"gapCursor\",\n  addProseMirrorPlugins() {\n    return [(0,_tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_4__.gapCursor)()];\n  },\n  extendNodeSchema(extension) {\n    var _a;\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    return {\n      allowGapCursor: (_a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.callOrReturn)((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getExtensionField)(extension, \"allowGapCursor\", context))) != null ? _a : null\n    };\n  }\n});\n\n// src/placeholder/placeholder.ts\n\n\n\nvar Placeholder = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"placeholder\",\n  addOptions() {\n    return {\n      emptyEditorClass: \"is-editor-empty\",\n      emptyNodeClass: \"is-empty\",\n      placeholder: \"Write something \\u2026\",\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true,\n      includeChildren: false\n    };\n  },\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"placeholder\"),\n        props: {\n          decorations: ({ doc, selection }) => {\n            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;\n            const { anchor } = selection;\n            const decorations = [];\n            if (!active) {\n              return null;\n            }\n            const isEmptyDoc = this.editor.isEmpty;\n            doc.descendants((node, pos) => {\n              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n              const isEmpty = !node.isLeaf && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeEmpty)(node);\n              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n                const classes = [this.options.emptyNodeClass];\n                if (isEmptyDoc) {\n                  classes.push(this.options.emptyEditorClass);\n                }\n                const decoration = _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.node(pos, pos + node.nodeSize, {\n                  class: classes.join(\" \"),\n                  \"data-placeholder\": typeof this.options.placeholder === \"function\" ? this.options.placeholder({\n                    editor: this.editor,\n                    node,\n                    pos,\n                    hasAnchor\n                  }) : this.options.placeholder\n                });\n                decorations.push(decoration);\n              }\n              return this.options.includeChildren;\n            });\n            return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(doc, decorations);\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/selection/selection.ts\n\n\n\nvar Selection = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"selection\",\n  addOptions() {\n    return {\n      className: \"selection\"\n    };\n  },\n  addProseMirrorPlugins() {\n    const { editor, options } = this;\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"selection\"),\n        props: {\n          decorations(state) {\n            if (state.selection.empty || editor.isFocused || !editor.isEditable || (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(state.selection) || editor.view.dragging) {\n              return null;\n            }\n            return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(state.doc, [\n              _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.inline(state.selection.from, state.selection.to, {\n                class: options.className\n              })\n            ]);\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/trailing-node/trailing-node.ts\n\n\nfunction nodeEqualsType({ types, node }) {\n  return node && Array.isArray(types) && types.includes(node.type) || (node == null ? void 0 : node.type) === types;\n}\nvar TrailingNode = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"trailingNode\",\n  addOptions() {\n    return {\n      node: void 0,\n      notAfter: []\n    };\n  },\n  addProseMirrorPlugins() {\n    var _a;\n    const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(this.name);\n    const defaultNode = this.options.node || ((_a = this.editor.schema.topNodeType.contentMatch.defaultType) == null ? void 0 : _a.name) || \"paragraph\";\n    const disabledNodes = Object.entries(this.editor.schema.nodes).map(([, value]) => value).filter((node) => (this.options.notAfter || []).concat(defaultNode).includes(node.name));\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: plugin,\n        appendTransaction: (_, __, state) => {\n          const { doc, tr, schema } = state;\n          const shouldInsertNodeAtEnd = plugin.getState(state);\n          const endPosition = doc.content.size;\n          const type = schema.nodes[defaultNode];\n          if (!shouldInsertNodeAtEnd) {\n            return;\n          }\n          return tr.insert(endPosition, type.create());\n        },\n        state: {\n          init: (_, state) => {\n            const lastNode = state.tr.doc.lastChild;\n            return !nodeEqualsType({ node: lastNode, types: disabledNodes });\n          },\n          apply: (tr, value) => {\n            if (!tr.docChanged) {\n              return value;\n            }\n            if (tr.getMeta(\"__uniqueIDTransaction\")) {\n              return value;\n            }\n            const lastNode = tr.doc.lastChild;\n            return !nodeEqualsType({ node: lastNode, types: disabledNodes });\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/undo-redo/undo-redo.ts\n\n\nvar UndoRedo = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"undoRedo\",\n  addOptions() {\n    return {\n      depth: 100,\n      newGroupDelay: 500\n    };\n  },\n  addCommands() {\n    return {\n      undo: () => ({ state, dispatch }) => {\n        return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__.undo)(state, dispatch);\n      },\n      redo: () => ({ state, dispatch }) => {\n        return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__.redo)(state, dispatch);\n      }\n    };\n  },\n  addProseMirrorPlugins() {\n    return [(0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__.history)(this.options)];\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-z\": () => this.editor.commands.undo(),\n      \"Shift-Mod-z\": () => this.editor.commands.redo(),\n      \"Mod-y\": () => this.editor.commands.redo(),\n      // Russian keyboard layouts\n      \"Mod-\\u044F\": () => this.editor.commands.undo(),\n      \"Shift-Mod-\\u044F\": () => this.editor.commands.redo()\n    };\n  }\n});\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb25zL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN5QztBQUNZO0FBQ3JELHFCQUFxQixtREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQU07QUFDaEIsaUJBQWlCLHVEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxPQUFPO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRSxvREFBb0QsdUJBQXVCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1QkFBdUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUN1RDtBQUNKO0FBQ25ELGlCQUFpQixtREFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFlBQVksaUVBQVU7QUFDdEI7QUFDQSxDQUFDOztBQUVEO0FBQ3VEO0FBQ3VCO0FBQ2xCO0FBQzVELFlBQVksbURBQVU7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aUJBQWlCO0FBQ3RDLGVBQWUsd0RBQUk7QUFDbkIsT0FBTztBQUNQLHFCQUFxQixpQkFBaUI7QUFDdEMsZUFBZSx3REFBSTtBQUNuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsWUFBWSwyREFBTztBQUNuQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBVUM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2thbmJhbnByby8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbnMvZGlzdC9pbmRleC5qcz9lODAwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jaGFyYWN0ZXItY291bnQvY2hhcmFjdGVyLWNvdW50LnRzXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgQ2hhcmFjdGVyQ291bnQgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJjaGFyYWN0ZXJDb3VudFwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW1pdDogbnVsbCxcbiAgICAgIG1vZGU6IFwidGV4dFNpemVcIixcbiAgICAgIHRleHRDb3VudGVyOiAodGV4dCkgPT4gdGV4dC5sZW5ndGgsXG4gICAgICB3b3JkQ291bnRlcjogKHRleHQpID0+IHRleHQuc3BsaXQoXCIgXCIpLmZpbHRlcigod29yZCkgPT4gd29yZCAhPT0gXCJcIikubGVuZ3RoXG4gICAgfTtcbiAgfSxcbiAgYWRkU3RvcmFnZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhcmFjdGVyczogKCkgPT4gMCxcbiAgICAgIHdvcmRzOiAoKSA9PiAwXG4gICAgfTtcbiAgfSxcbiAgb25CZWZvcmVDcmVhdGUoKSB7XG4gICAgdGhpcy5zdG9yYWdlLmNoYXJhY3RlcnMgPSAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm5vZGUpIHx8IHRoaXMuZWRpdG9yLnN0YXRlLmRvYztcbiAgICAgIGNvbnN0IG1vZGUgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RlKSB8fCB0aGlzLm9wdGlvbnMubW9kZTtcbiAgICAgIGlmIChtb2RlID09PSBcInRleHRTaXplXCIpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IG5vZGUudGV4dEJldHdlZW4oMCwgbm9kZS5jb250ZW50LnNpemUsIHZvaWQgMCwgXCIgXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRleHRDb3VudGVyKHRleHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUubm9kZVNpemU7XG4gICAgfTtcbiAgICB0aGlzLnN0b3JhZ2Uud29yZHMgPSAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm5vZGUpIHx8IHRoaXMuZWRpdG9yLnN0YXRlLmRvYztcbiAgICAgIGNvbnN0IHRleHQgPSBub2RlLnRleHRCZXR3ZWVuKDAsIG5vZGUuY29udGVudC5zaXplLCBcIiBcIiwgXCIgXCIpO1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53b3JkQ291bnRlcih0ZXh0KTtcbiAgICB9O1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgbGV0IGluaXRpYWxFdmFsdWF0aW9uRG9uZSA9IGZhbHNlO1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KFwiY2hhcmFjdGVyQ291bnRcIiksXG4gICAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAoaW5pdGlhbEV2YWx1YXRpb25Eb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5vcHRpb25zLmxpbWl0O1xuICAgICAgICAgIGlmIChsaW1pdCA9PT0gbnVsbCB8fCBsaW1pdCA9PT0gdm9pZCAwIHx8IGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICBpbml0aWFsRXZhbHVhdGlvbkRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbml0aWFsQ29udGVudFNpemUgPSB0aGlzLnN0b3JhZ2UuY2hhcmFjdGVycyh7IG5vZGU6IG5ld1N0YXRlLmRvYyB9KTtcbiAgICAgICAgICBpZiAoaW5pdGlhbENvbnRlbnRTaXplID4gbGltaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXIgPSBpbml0aWFsQ29udGVudFNpemUgLSBsaW1pdDtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSAwO1xuICAgICAgICAgICAgY29uc3QgdG8gPSBvdmVyO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBgW0NoYXJhY3RlckNvdW50XSBJbml0aWFsIGNvbnRlbnQgZXhjZWVkZWQgbGltaXQgb2YgJHtsaW1pdH0gY2hhcmFjdGVycy4gQ29udGVudCB3YXMgYXV0b21hdGljYWxseSB0cmltbWVkLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCB0ciA9IG5ld1N0YXRlLnRyLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgICAgIGluaXRpYWxFdmFsdWF0aW9uRG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaXRpYWxFdmFsdWF0aW9uRG9uZSA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlclRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb24sIHN0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgbGltaXQgPSB0aGlzLm9wdGlvbnMubGltaXQ7XG4gICAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkIHx8IGxpbWl0ID09PSAwIHx8IGxpbWl0ID09PSBudWxsIHx8IGxpbWl0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBvbGRTaXplID0gdGhpcy5zdG9yYWdlLmNoYXJhY3RlcnMoeyBub2RlOiBzdGF0ZS5kb2MgfSk7XG4gICAgICAgICAgY29uc3QgbmV3U2l6ZSA9IHRoaXMuc3RvcmFnZS5jaGFyYWN0ZXJzKHsgbm9kZTogdHJhbnNhY3Rpb24uZG9jIH0pO1xuICAgICAgICAgIGlmIChuZXdTaXplIDw9IGxpbWl0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9sZFNpemUgPiBsaW1pdCAmJiBuZXdTaXplID4gbGltaXQgJiYgbmV3U2l6ZSA8PSBvbGRTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9sZFNpemUgPiBsaW1pdCAmJiBuZXdTaXplID4gbGltaXQgJiYgbmV3U2l6ZSA+IG9sZFNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNQYXN0ZSA9IHRyYW5zYWN0aW9uLmdldE1ldGEoXCJwYXN0ZVwiKTtcbiAgICAgICAgICBpZiAoIWlzUGFzdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcG9zID0gdHJhbnNhY3Rpb24uc2VsZWN0aW9uLiRoZWFkLnBvcztcbiAgICAgICAgICBjb25zdCBvdmVyID0gbmV3U2l6ZSAtIGxpbWl0O1xuICAgICAgICAgIGNvbnN0IGZyb20gPSBwb3MgLSBvdmVyO1xuICAgICAgICAgIGNvbnN0IHRvID0gcG9zO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkU2l6ZSA9IHRoaXMuc3RvcmFnZS5jaGFyYWN0ZXJzKHsgbm9kZTogdHJhbnNhY3Rpb24uZG9jIH0pO1xuICAgICAgICAgIGlmICh1cGRhdGVkU2l6ZSA+IGxpbWl0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvZHJvcC1jdXJzb3IvZHJvcC1jdXJzb3IudHNcbmltcG9ydCB7IEV4dGVuc2lvbiBhcyBFeHRlbnNpb24yIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgZHJvcEN1cnNvciB9IGZyb20gXCJAdGlwdGFwL3BtL2Ryb3BjdXJzb3JcIjtcbnZhciBEcm9wY3Vyc29yID0gRXh0ZW5zaW9uMi5jcmVhdGUoe1xuICBuYW1lOiBcImRyb3BDdXJzb3JcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6IFwiY3VycmVudENvbG9yXCIsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIGNsYXNzOiB2b2lkIDBcbiAgICB9O1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtkcm9wQ3Vyc29yKHRoaXMub3B0aW9ucyldO1xuICB9XG59KTtcblxuLy8gc3JjL2ZvY3VzL2ZvY3VzLnRzXG5pbXBvcnQgeyBFeHRlbnNpb24gYXMgRXh0ZW5zaW9uMyB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW4yLCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5MiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5pbXBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0IH0gZnJvbSBcIkB0aXB0YXAvcG0vdmlld1wiO1xudmFyIEZvY3VzID0gRXh0ZW5zaW9uMy5jcmVhdGUoe1xuICBuYW1lOiBcImZvY3VzXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzTmFtZTogXCJoYXMtZm9jdXNcIixcbiAgICAgIG1vZGU6IFwiYWxsXCJcbiAgICB9O1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4yKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5MihcImZvY3VzXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGRlY29yYXRpb25zOiAoeyBkb2MsIHNlbGVjdGlvbiB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGlzRWRpdGFibGUsIGlzRm9jdXNlZCB9ID0gdGhpcy5lZGl0b3I7XG4gICAgICAgICAgICBjb25zdCB7IGFuY2hvciB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGlmICghaXNFZGl0YWJsZSB8fCAhaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtYXhMZXZlbHMgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tb2RlID09PSBcImRlZXBlc3RcIikge1xuICAgICAgICAgICAgICBkb2MuZGVzY2VuZGFudHMoKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc0N1cnJlbnQgPSBhbmNob3IgPj0gcG9zICYmIGFuY2hvciA8PSBwb3MgKyBub2RlLm5vZGVTaXplIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXhMZXZlbHMgKz0gMTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudExldmVsID0gMDtcbiAgICAgICAgICAgIGRvYy5kZXNjZW5kYW50cygobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBpc0N1cnJlbnQgPSBhbmNob3IgPj0gcG9zICYmIGFuY2hvciA8PSBwb3MgKyBub2RlLm5vZGVTaXplIC0gMTtcbiAgICAgICAgICAgICAgaWYgKCFpc0N1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudExldmVsICs9IDE7XG4gICAgICAgICAgICAgIGNvbnN0IG91dE9mU2NvcGUgPSB0aGlzLm9wdGlvbnMubW9kZSA9PT0gXCJkZWVwZXN0XCIgJiYgbWF4TGV2ZWxzIC0gY3VycmVudExldmVsID4gMCB8fCB0aGlzLm9wdGlvbnMubW9kZSA9PT0gXCJzaGFsbG93ZXN0XCIgJiYgY3VycmVudExldmVsID4gMTtcbiAgICAgICAgICAgICAgaWYgKG91dE9mU2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1vZGUgPT09IFwiZGVlcGVzdFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlY29yYXRpb25zLnB1c2goXG4gICAgICAgICAgICAgICAgRGVjb3JhdGlvbi5ub2RlKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwge1xuICAgICAgICAgICAgICAgICAgY2xhc3M6IHRoaXMub3B0aW9ucy5jbGFzc05hbWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoZG9jLCBkZWNvcmF0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvZ2FwLWN1cnNvci9nYXAtY3Vyc29yLnRzXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4sIEV4dGVuc2lvbiBhcyBFeHRlbnNpb240LCBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IGdhcEN1cnNvciB9IGZyb20gXCJAdGlwdGFwL3BtL2dhcGN1cnNvclwiO1xudmFyIEdhcGN1cnNvciA9IEV4dGVuc2lvbjQuY3JlYXRlKHtcbiAgbmFtZTogXCJnYXBDdXJzb3JcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbZ2FwQ3Vyc29yKCldO1xuICB9LFxuICBleHRlbmROb2RlU2NoZW1hKGV4dGVuc2lvbikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgYWxsb3dHYXBDdXJzb3I6IChfYSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiYWxsb3dHYXBDdXJzb3JcIiwgY29udGV4dCkpKSAhPSBudWxsID8gX2EgOiBudWxsXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9wbGFjZWhvbGRlci9wbGFjZWhvbGRlci50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjUsIGlzTm9kZUVtcHR5IH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjMsIFBsdWdpbktleSBhcyBQbHVnaW5LZXkzIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmltcG9ydCB7IERlY29yYXRpb24gYXMgRGVjb3JhdGlvbjIsIERlY29yYXRpb25TZXQgYXMgRGVjb3JhdGlvblNldDIgfSBmcm9tIFwiQHRpcHRhcC9wbS92aWV3XCI7XG52YXIgUGxhY2Vob2xkZXIgPSBFeHRlbnNpb241LmNyZWF0ZSh7XG4gIG5hbWU6IFwicGxhY2Vob2xkZXJcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW1wdHlFZGl0b3JDbGFzczogXCJpcy1lZGl0b3ItZW1wdHlcIixcbiAgICAgIGVtcHR5Tm9kZUNsYXNzOiBcImlzLWVtcHR5XCIsXG4gICAgICBwbGFjZWhvbGRlcjogXCJXcml0ZSBzb21ldGhpbmcgXFx1MjAyNlwiLFxuICAgICAgc2hvd09ubHlXaGVuRWRpdGFibGU6IHRydWUsXG4gICAgICBzaG93T25seUN1cnJlbnQ6IHRydWUsXG4gICAgICBpbmNsdWRlQ2hpbGRyZW46IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luMyh7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleTMoXCJwbGFjZWhvbGRlclwiKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBkZWNvcmF0aW9uczogKHsgZG9jLCBzZWxlY3Rpb24gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSB8fCAhdGhpcy5vcHRpb25zLnNob3dPbmx5V2hlbkVkaXRhYmxlO1xuICAgICAgICAgICAgY29uc3QgeyBhbmNob3IgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGRlY29yYXRpb25zID0gW107XG4gICAgICAgICAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzRW1wdHlEb2MgPSB0aGlzLmVkaXRvci5pc0VtcHR5O1xuICAgICAgICAgICAgZG9jLmRlc2NlbmRhbnRzKChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaGFzQW5jaG9yID0gYW5jaG9yID49IHBvcyAmJiBhbmNob3IgPD0gcG9zICsgbm9kZS5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgY29uc3QgaXNFbXB0eSA9ICFub2RlLmlzTGVhZiAmJiBpc05vZGVFbXB0eShub2RlKTtcbiAgICAgICAgICAgICAgaWYgKChoYXNBbmNob3IgfHwgIXRoaXMub3B0aW9ucy5zaG93T25seUN1cnJlbnQpICYmIGlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gW3RoaXMub3B0aW9ucy5lbXB0eU5vZGVDbGFzc107XG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHlEb2MpIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCh0aGlzLm9wdGlvbnMuZW1wdHlFZGl0b3JDbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29yYXRpb24gPSBEZWNvcmF0aW9uMi5ub2RlKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwge1xuICAgICAgICAgICAgICAgICAgY2xhc3M6IGNsYXNzZXMuam9pbihcIiBcIiksXG4gICAgICAgICAgICAgICAgICBcImRhdGEtcGxhY2Vob2xkZXJcIjogdHlwZW9mIHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlciA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICBoYXNBbmNob3JcbiAgICAgICAgICAgICAgICAgIH0pIDogdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChkZWNvcmF0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmluY2x1ZGVDaGlsZHJlbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQyLmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9zZWxlY3Rpb24vc2VsZWN0aW9uLnRzXG5pbXBvcnQgeyBFeHRlbnNpb24gYXMgRXh0ZW5zaW9uNiwgaXNOb2RlU2VsZWN0aW9uIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjQsIFBsdWdpbktleSBhcyBQbHVnaW5LZXk0IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmltcG9ydCB7IERlY29yYXRpb24gYXMgRGVjb3JhdGlvbjMsIERlY29yYXRpb25TZXQgYXMgRGVjb3JhdGlvblNldDMgfSBmcm9tIFwiQHRpcHRhcC9wbS92aWV3XCI7XG52YXIgU2VsZWN0aW9uID0gRXh0ZW5zaW9uNi5jcmVhdGUoe1xuICBuYW1lOiBcInNlbGVjdGlvblwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc05hbWU6IFwic2VsZWN0aW9uXCJcbiAgICB9O1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW40KHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5NChcInNlbGVjdGlvblwiKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBkZWNvcmF0aW9ucyhzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5lbXB0eSB8fCBlZGl0b3IuaXNGb2N1c2VkIHx8ICFlZGl0b3IuaXNFZGl0YWJsZSB8fCBpc05vZGVTZWxlY3Rpb24oc3RhdGUuc2VsZWN0aW9uKSB8fCBlZGl0b3Iudmlldy5kcmFnZ2luZykge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0My5jcmVhdGUoc3RhdGUuZG9jLCBbXG4gICAgICAgICAgICAgIERlY29yYXRpb24zLmlubGluZShzdGF0ZS5zZWxlY3Rpb24uZnJvbSwgc3RhdGUuc2VsZWN0aW9uLnRvLCB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IG9wdGlvbnMuY2xhc3NOYW1lXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy90cmFpbGluZy1ub2RlL3RyYWlsaW5nLW5vZGUudHNcbmltcG9ydCB7IEV4dGVuc2lvbiBhcyBFeHRlbnNpb243IH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjUsIFBsdWdpbktleSBhcyBQbHVnaW5LZXk1IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmZ1bmN0aW9uIG5vZGVFcXVhbHNUeXBlKHsgdHlwZXMsIG5vZGUgfSkge1xuICByZXR1cm4gbm9kZSAmJiBBcnJheS5pc0FycmF5KHR5cGVzKSAmJiB0eXBlcy5pbmNsdWRlcyhub2RlLnR5cGUpIHx8IChub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLnR5cGUpID09PSB0eXBlcztcbn1cbnZhciBUcmFpbGluZ05vZGUgPSBFeHRlbnNpb243LmNyZWF0ZSh7XG4gIG5hbWU6IFwidHJhaWxpbmdOb2RlXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IHZvaWQgMCxcbiAgICAgIG5vdEFmdGVyOiBbXVxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbktleTUodGhpcy5uYW1lKTtcbiAgICBjb25zdCBkZWZhdWx0Tm9kZSA9IHRoaXMub3B0aW9ucy5ub2RlIHx8ICgoX2EgPSB0aGlzLmVkaXRvci5zY2hlbWEudG9wTm9kZVR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2EubmFtZSkgfHwgXCJwYXJhZ3JhcGhcIjtcbiAgICBjb25zdCBkaXNhYmxlZE5vZGVzID0gT2JqZWN0LmVudHJpZXModGhpcy5lZGl0b3Iuc2NoZW1hLm5vZGVzKS5tYXAoKFssIHZhbHVlXSkgPT4gdmFsdWUpLmZpbHRlcigobm9kZSkgPT4gKHRoaXMub3B0aW9ucy5ub3RBZnRlciB8fCBbXSkuY29uY2F0KGRlZmF1bHROb2RlKS5pbmNsdWRlcyhub2RlLm5hbWUpKTtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbjUoe1xuICAgICAgICBrZXk6IHBsdWdpbixcbiAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246IChfLCBfXywgc3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGRvYywgdHIsIHNjaGVtYSB9ID0gc3RhdGU7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkSW5zZXJ0Tm9kZUF0RW5kID0gcGx1Z2luLmdldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgICBjb25zdCBlbmRQb3NpdGlvbiA9IGRvYy5jb250ZW50LnNpemU7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IHNjaGVtYS5ub2Rlc1tkZWZhdWx0Tm9kZV07XG4gICAgICAgICAgaWYgKCFzaG91bGRJbnNlcnROb2RlQXRFbmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRyLmluc2VydChlbmRQb3NpdGlvbiwgdHlwZS5jcmVhdGUoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgaW5pdDogKF8sIHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYXN0Tm9kZSA9IHN0YXRlLnRyLmRvYy5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICByZXR1cm4gIW5vZGVFcXVhbHNUeXBlKHsgbm9kZTogbGFzdE5vZGUsIHR5cGVzOiBkaXNhYmxlZE5vZGVzIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXBwbHk6ICh0ciwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHIuZ2V0TWV0YShcIl9fdW5pcXVlSURUcmFuc2FjdGlvblwiKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsYXN0Tm9kZSA9IHRyLmRvYy5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICByZXR1cm4gIW5vZGVFcXVhbHNUeXBlKHsgbm9kZTogbGFzdE5vZGUsIHR5cGVzOiBkaXNhYmxlZE5vZGVzIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL3VuZG8tcmVkby91bmRvLXJlZG8udHNcbmltcG9ydCB7IEV4dGVuc2lvbiBhcyBFeHRlbnNpb244IH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgaGlzdG9yeSwgcmVkbywgdW5kbyB9IGZyb20gXCJAdGlwdGFwL3BtL2hpc3RvcnlcIjtcbnZhciBVbmRvUmVkbyA9IEV4dGVuc2lvbjguY3JlYXRlKHtcbiAgbmFtZTogXCJ1bmRvUmVkb1wiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZXB0aDogMTAwLFxuICAgICAgbmV3R3JvdXBEZWxheTogNTAwXG4gICAgfTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuZG86ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIHJldHVybiB1bmRvKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICB9LFxuICAgICAgcmVkbzogKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZG8oc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtoaXN0b3J5KHRoaXMub3B0aW9ucyldO1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtelwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy51bmRvKCksXG4gICAgICBcIlNoaWZ0LU1vZC16XCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlZG8oKSxcbiAgICAgIFwiTW9kLXlcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuICAgICAgLy8gUnVzc2lhbiBrZXlib2FyZCBsYXlvdXRzXG4gICAgICBcIk1vZC1cXHUwNDRGXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnVuZG8oKSxcbiAgICAgIFwiU2hpZnQtTW9kLVxcdTA0NEZcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpXG4gICAgfTtcbiAgfVxufSk7XG5leHBvcnQge1xuICBDaGFyYWN0ZXJDb3VudCxcbiAgRHJvcGN1cnNvcixcbiAgRm9jdXMsXG4gIEdhcGN1cnNvcixcbiAgUGxhY2Vob2xkZXIsXG4gIFNlbGVjdGlvbixcbiAgVHJhaWxpbmdOb2RlLFxuICBVbmRvUmVkb1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extensions/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/commands/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/commands/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.autoJoin),\n/* harmony export */   baseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.baseKeymap),\n/* harmony export */   chainCommands: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.chainCommands),\n/* harmony export */   createParagraphNear: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.deleteSelection),\n/* harmony export */   exitCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.exitCode),\n/* harmony export */   joinBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinBackward),\n/* harmony export */   joinDown: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinDown),\n/* harmony export */   joinForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockForward),\n/* harmony export */   joinUp: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinUp),\n/* harmony export */   lift: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.lift),\n/* harmony export */   liftEmptyBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectAll),\n/* harmony export */   selectNodeBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.setBlockType),\n/* harmony export */   splitBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlock),\n/* harmony export */   splitBlockAs: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.toggleMark),\n/* harmony export */   wrapIn: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-commands */ \"(ssr)/./node_modules/prosemirror-commands/dist/index.js\");\n// commands/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2NvbW1hbmRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3FDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FuYmFucHJvLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vZGlzdC9jb21tYW5kcy9pbmRleC5qcz82YjNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbW1hbmRzL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItY29tbWFuZHNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/commands/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/dropcursor/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/dropcursor/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dropCursor: () => (/* reexport safe */ prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-dropcursor */ \"(ssr)/./node_modules/prosemirror-dropcursor/dist/index.js\");\n// dropcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2Ryb3BjdXJzb3IvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUN1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2thbmJhbnByby8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Rpc3QvZHJvcGN1cnNvci9pbmRleC5qcz9lM2VkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGRyb3BjdXJzb3IvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1kcm9wY3Vyc29yXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/dropcursor/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/gapcursor/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/gapcursor/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.GapCursor),\n/* harmony export */   gapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-gapcursor */ \"(ssr)/./node_modules/prosemirror-gapcursor/dist/index.js\");\n// gapcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2dhcGN1cnNvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2thbmJhbnByby8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Rpc3QvZ2FwY3Vyc29yL2luZGV4LmpzPzgxNzAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2FwY3Vyc29yL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItZ2FwY3Vyc29yXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/gapcursor/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/history/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/history/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.closeHistory),\n/* harmony export */   history: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.history),\n/* harmony export */   isHistoryTransaction: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.isHistoryTransaction),\n/* harmony export */   redo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redo),\n/* harmony export */   redoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoDepth),\n/* harmony export */   redoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoNoScroll),\n/* harmony export */   undo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undo),\n/* harmony export */   undoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoDepth),\n/* harmony export */   undoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoNoScroll)\n/* harmony export */ });\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-history */ \"(ssr)/./node_modules/prosemirror-history/dist/index.js\");\n// history/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2hpc3RvcnkvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ29DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FuYmFucHJvLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vZGlzdC9oaXN0b3J5L2luZGV4LmpzP2ZiZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaGlzdG9yeS9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLWhpc3RvcnlcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/history/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/keymap/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/keymap/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keydownHandler: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keydownHandler),\n/* harmony export */   keymap: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.js\");\n// keymap/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2tleW1hcC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2thbmJhbnByby8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Rpc3Qva2V5bWFwL2luZGV4LmpzPzViNjciXSwic291cmNlc0NvbnRlbnQiOlsiLy8ga2V5bWFwL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Ita2V5bWFwXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/keymap/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/model/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/model/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ContentMatch),\n/* harmony export */   DOMParser: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser),\n/* harmony export */   DOMSerializer: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer),\n/* harmony export */   Fragment: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment),\n/* harmony export */   Mark: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark),\n/* harmony export */   MarkType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType),\n/* harmony export */   Node: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node),\n/* harmony export */   NodeRange: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange),\n/* harmony export */   NodeType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeType),\n/* harmony export */   ReplaceError: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError),\n/* harmony export */   ResolvedPos: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ResolvedPos),\n/* harmony export */   Schema: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Schema),\n/* harmony export */   Slice: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n// model/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L21vZGVsL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYW5iYW5wcm8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L21vZGVsL2luZGV4LmpzP2RmMzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbW9kZWwvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1tb2RlbFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/model/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/schema-list/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/schema-list/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.addListNodes),\n/* harmony export */   bulletList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.bulletList),\n/* harmony export */   liftListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.liftListItem),\n/* harmony export */   listItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.listItem),\n/* harmony export */   orderedList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.orderedList),\n/* harmony export */   sinkListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.sinkListItem),\n/* harmony export */   splitListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItem),\n/* harmony export */   splitListItemKeepMarks: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItemKeepMarks),\n/* harmony export */   wrapInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapInList),\n/* harmony export */   wrapRangeInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapRangeInList)\n/* harmony export */ });\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-schema-list */ \"(ssr)/./node_modules/prosemirror-schema-list/dist/index.js\");\n// schema-list/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3NjaGVtYS1saXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYW5iYW5wcm8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3NjaGVtYS1saXN0L2luZGV4LmpzP2E4MzkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2NoZW1hLWxpc3QvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1zY2hlbWEtbGlzdFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/schema-list/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/state/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/state/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection),\n/* harmony export */   EditorState: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState),\n/* harmony export */   NodeSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection),\n/* harmony export */   Plugin: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin),\n/* harmony export */   PluginKey: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey),\n/* harmony export */   Selection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection),\n/* harmony export */   SelectionRange: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange),\n/* harmony export */   TextSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection),\n/* harmony export */   Transaction: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n// state/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3N0YXRlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2thbmJhbnByby8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Rpc3Qvc3RhdGUvaW5kZXguanM/YzA2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdGF0ZS9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/transform/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/transform/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddMarkStep),\n/* harmony export */   AddNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddNodeMarkStep),\n/* harmony export */   AttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AttrStep),\n/* harmony export */   DocAttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.DocAttrStep),\n/* harmony export */   MapResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.MapResult),\n/* harmony export */   Mapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Mapping),\n/* harmony export */   RemoveMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveMarkStep),\n/* harmony export */   RemoveNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveNodeMarkStep),\n/* harmony export */   ReplaceAroundStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep),\n/* harmony export */   ReplaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep),\n/* harmony export */   Step: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Step),\n/* harmony export */   StepMap: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepMap),\n/* harmony export */   StepResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepResult),\n/* harmony export */   Transform: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Transform),\n/* harmony export */   TransformError: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.TransformError),\n/* harmony export */   canJoin: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin),\n/* harmony export */   canSplit: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit),\n/* harmony export */   dropPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.dropPoint),\n/* harmony export */   findWrapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping),\n/* harmony export */   insertPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.insertPoint),\n/* harmony export */   joinPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint),\n/* harmony export */   liftTarget: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget),\n/* harmony export */   replaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n// transform/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3RyYW5zZm9ybS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2thbmJhbnByby8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Rpc3QvdHJhbnNmb3JtL2luZGV4LmpzPzQ1NDEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHJhbnNmb3JtL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItdHJhbnNmb3JtXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/transform/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/view/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/view/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration),\n/* harmony export */   DecorationSet: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.DecorationSet),\n/* harmony export */   EditorView: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView),\n/* harmony export */   __endComposition: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__parseFromClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n// view/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3ZpZXcvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYW5iYW5wcm8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3ZpZXcvaW5kZXguanM/MDg0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2aWV3L2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Itdmlld1wiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/view/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/react/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@tiptap/react/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandManager: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.CommandManager),\n/* harmony export */   Editor: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Editor),\n/* harmony export */   EditorConsumer: () => (/* binding */ EditorConsumer),\n/* harmony export */   EditorContent: () => (/* binding */ EditorContent),\n/* harmony export */   EditorContext: () => (/* binding */ EditorContext),\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   Extendable: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Extendable),\n/* harmony export */   Extension: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Extension),\n/* harmony export */   Fragment: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Fragment),\n/* harmony export */   InputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.InputRule),\n/* harmony export */   MappablePosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.MappablePosition),\n/* harmony export */   Mark: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Mark),\n/* harmony export */   MarkView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.MarkView),\n/* harmony export */   MarkViewContent: () => (/* binding */ MarkViewContent),\n/* harmony export */   Node: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Node),\n/* harmony export */   NodePos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.NodePos),\n/* harmony export */   NodeView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.NodeView),\n/* harmony export */   NodeViewContent: () => (/* binding */ NodeViewContent),\n/* harmony export */   NodeViewWrapper: () => (/* binding */ NodeViewWrapper),\n/* harmony export */   PasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.PasteRule),\n/* harmony export */   PureEditorContent: () => (/* binding */ PureEditorContent),\n/* harmony export */   ReactMarkView: () => (/* binding */ ReactMarkView),\n/* harmony export */   ReactMarkViewContext: () => (/* binding */ ReactMarkViewContext),\n/* harmony export */   ReactMarkViewRenderer: () => (/* binding */ ReactMarkViewRenderer),\n/* harmony export */   ReactNodeView: () => (/* binding */ ReactNodeView),\n/* harmony export */   ReactNodeViewContentProvider: () => (/* binding */ ReactNodeViewContentProvider),\n/* harmony export */   ReactNodeViewContext: () => (/* binding */ ReactNodeViewContext),\n/* harmony export */   ReactNodeViewRenderer: () => (/* binding */ ReactNodeViewRenderer),\n/* harmony export */   ReactRenderer: () => (/* binding */ ReactRenderer),\n/* harmony export */   ResizableNodeView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.ResizableNodeView),\n/* harmony export */   ResizableNodeview: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.ResizableNodeview),\n/* harmony export */   Tracker: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Tracker),\n/* harmony export */   callOrReturn: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.callOrReturn),\n/* harmony export */   canInsertNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.canInsertNode),\n/* harmony export */   combineTransactionSteps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.combineTransactionSteps),\n/* harmony export */   commands: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.commands),\n/* harmony export */   createAtomBlockMarkdownSpec: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createAtomBlockMarkdownSpec),\n/* harmony export */   createBlockMarkdownSpec: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createBlockMarkdownSpec),\n/* harmony export */   createChainableState: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createChainableState),\n/* harmony export */   createDocument: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createDocument),\n/* harmony export */   createElement: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createElement),\n/* harmony export */   createInlineMarkdownSpec: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createInlineMarkdownSpec),\n/* harmony export */   createMappablePosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createMappablePosition),\n/* harmony export */   createNodeFromContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.deleteProps),\n/* harmony export */   elementFromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.escapeForRegEx),\n/* harmony export */   extensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.extensions),\n/* harmony export */   findChildren: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findChildren),\n/* harmony export */   findChildrenInRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findDuplicates),\n/* harmony export */   findParentNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findParentNodeClosestToPos),\n/* harmony export */   flattenExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.flattenExtensions),\n/* harmony export */   fromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.fromString),\n/* harmony export */   generateHTML: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.generateHTML),\n/* harmony export */   generateJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.generateJSON),\n/* harmony export */   generateText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.generateText),\n/* harmony export */   getAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarkRange),\n/* harmony export */   getMarkType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarkType),\n/* harmony export */   getMarksBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSplittedAttributes),\n/* harmony export */   getText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getText),\n/* harmony export */   getTextBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getTextSerializersFromSchema),\n/* harmony export */   getUpdatedPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getUpdatedPosition),\n/* harmony export */   h: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.h),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.inputRulesPlugin),\n/* harmony export */   isActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isActive),\n/* harmony export */   isAndroid: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isAndroid),\n/* harmony export */   isAtEndOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isFunction),\n/* harmony export */   isList: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isList),\n/* harmony export */   isMacOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isMacOS),\n/* harmony export */   isMarkActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isMarkActive),\n/* harmony export */   isNodeActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNodeSelection),\n/* harmony export */   isNumber: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNumber),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isPlainObject),\n/* harmony export */   isRegExp: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isRegExp),\n/* harmony export */   isString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isString),\n/* harmony export */   isTextSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isTextSelection),\n/* harmony export */   isiOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isiOS),\n/* harmony export */   markInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.markInputRule),\n/* harmony export */   markPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.markPasteRule),\n/* harmony export */   markdown: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.markdown),\n/* harmony export */   mergeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.mergeDeep),\n/* harmony export */   minMax: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.minMax),\n/* harmony export */   nodeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.objectIncludes),\n/* harmony export */   parseAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.parseAttributes),\n/* harmony export */   parseIndentedBlocks: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.parseIndentedBlocks),\n/* harmony export */   pasteRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.removeDuplicates),\n/* harmony export */   renderNestedMarkdownContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.renderNestedMarkdownContent),\n/* harmony export */   resolveExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.resolveExtensions),\n/* harmony export */   resolveFocusPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.resolveFocusPosition),\n/* harmony export */   rewriteUnknownContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.rewriteUnknownContent),\n/* harmony export */   selectionToInsertionEnd: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.selectionToInsertionEnd),\n/* harmony export */   serializeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.serializeAttributes),\n/* harmony export */   sortExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.sortExtensions),\n/* harmony export */   splitExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.splitExtensions),\n/* harmony export */   textInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.textInputRule),\n/* harmony export */   textPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.textblockTypeInputRule),\n/* harmony export */   updateMarkViewAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.updateMarkViewAttributes),\n/* harmony export */   useCurrentEditor: () => (/* binding */ useCurrentEditor),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useEditorState: () => (/* binding */ useEditorState),\n/* harmony export */   useReactNodeView: () => (/* binding */ useReactNodeView),\n/* harmony export */   wrappingInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var fast_equals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fast-equals */ \"(ssr)/./node_modules/fast-equals/dist/esm/index.mjs\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n// src/Context.tsx\n\n\n// src/EditorContent.tsx\n\n\n\n\nvar mergeRefs = (...refs) => {\n  return (node) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(node);\n      } else if (ref) {\n        ;\n        ref.current = node;\n      }\n    });\n  };\n};\nvar Portals = ({ contentComponent }) => {\n  const renderers = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(\n    contentComponent.subscribe,\n    contentComponent.getSnapshot,\n    contentComponent.getServerSnapshot\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: Object.values(renderers) });\n};\nfunction getInstance() {\n  const subscribers = /* @__PURE__ */ new Set();\n  let renderers = {};\n  return {\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(callback) {\n      subscribers.add(callback);\n      return () => {\n        subscribers.delete(callback);\n      };\n    },\n    getSnapshot() {\n      return renderers;\n    },\n    getServerSnapshot() {\n      return renderers;\n    },\n    /**\n     * Adds a new NodeView Renderer to the editor.\n     */\n    setRenderer(id, renderer) {\n      renderers = {\n        ...renderers,\n        [id]: react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(renderer.reactElement, renderer.element, id)\n      };\n      subscribers.forEach((subscriber) => subscriber());\n    },\n    /**\n     * Removes a NodeView Renderer from the editor.\n     */\n    removeRenderer(id) {\n      const nextRenderers = { ...renderers };\n      delete nextRenderers[id];\n      renderers = nextRenderers;\n      subscribers.forEach((subscriber) => subscriber());\n    }\n  };\n}\nvar PureEditorContent = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    var _a;\n    super(props);\n    this.editorContentRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n    this.initialized = false;\n    this.state = {\n      hasContentComponentInitialized: Boolean((_a = props.editor) == null ? void 0 : _a.contentComponent)\n    };\n  }\n  componentDidMount() {\n    this.init();\n  }\n  componentDidUpdate() {\n    this.init();\n  }\n  init() {\n    const editor = this.props.editor;\n    if (editor && !editor.isDestroyed && editor.options.element) {\n      if (editor.contentComponent) {\n        return;\n      }\n      const element = this.editorContentRef.current;\n      element.append(editor.view.dom);\n      editor.setOptions({\n        element\n      });\n      editor.contentComponent = getInstance();\n      if (!this.state.hasContentComponentInitialized) {\n        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {\n          this.setState((prevState) => {\n            if (!prevState.hasContentComponentInitialized) {\n              return {\n                hasContentComponentInitialized: true\n              };\n            }\n            return prevState;\n          });\n          if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent();\n          }\n        });\n      }\n      editor.createNodeViews();\n      this.initialized = true;\n    }\n  }\n  componentWillUnmount() {\n    var _a;\n    const editor = this.props.editor;\n    if (!editor) {\n      return;\n    }\n    this.initialized = false;\n    if (!editor.isDestroyed) {\n      editor.view.setProps({\n        nodeViews: {}\n      });\n    }\n    if (this.unsubscribeToContentComponent) {\n      this.unsubscribeToContentComponent();\n    }\n    editor.contentComponent = null;\n    try {\n      if (!((_a = editor.view.dom) == null ? void 0 : _a.firstChild)) {\n        return;\n      }\n      const newElement = document.createElement(\"div\");\n      newElement.append(editor.view.dom);\n      editor.setOptions({\n        element: newElement\n      });\n    } catch {\n    }\n  }\n  render() {\n    const { editor, innerRef, ...rest } = this.props;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", { ref: mergeRefs(innerRef, this.editorContentRef), ...rest }),\n      (editor == null ? void 0 : editor.contentComponent) && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Portals, { contentComponent: editor.contentComponent })\n    ] });\n  }\n};\nvar EditorContentWithKey = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  (props, ref) => {\n    const key = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n      return Math.floor(Math.random() * 4294967295).toString();\n    }, [props.editor]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(PureEditorContent, {\n      key,\n      innerRef: ref,\n      ...props\n    });\n  }\n);\nvar EditorContent = react__WEBPACK_IMPORTED_MODULE_0__.memo(EditorContentWithKey);\n\n// src/useEditor.ts\n\n\n\n\n// src/useEditorState.ts\n\n\n\nvar useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar EditorStateManager = class {\n  constructor(initialEditor) {\n    this.transactionNumber = 0;\n    this.lastTransactionNumber = 0;\n    this.subscribers = /* @__PURE__ */ new Set();\n    this.editor = initialEditor;\n    this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 };\n    this.getSnapshot = this.getSnapshot.bind(this);\n    this.getServerSnapshot = this.getServerSnapshot.bind(this);\n    this.watch = this.watch.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n  }\n  /**\n   * Get the current editor instance.\n   */\n  getSnapshot() {\n    if (this.transactionNumber === this.lastTransactionNumber) {\n      return this.lastSnapshot;\n    }\n    this.lastTransactionNumber = this.transactionNumber;\n    this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber };\n    return this.lastSnapshot;\n  }\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot() {\n    return { editor: null, transactionNumber: 0 };\n  }\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(callback) {\n    this.subscribers.add(callback);\n    return () => {\n      this.subscribers.delete(callback);\n    };\n  }\n  /**\n   * Watch the editor instance for changes.\n   */\n  watch(nextEditor) {\n    this.editor = nextEditor;\n    if (this.editor) {\n      const fn = () => {\n        this.transactionNumber += 1;\n        this.subscribers.forEach((callback) => callback());\n      };\n      const currentEditor = this.editor;\n      currentEditor.on(\"transaction\", fn);\n      return () => {\n        currentEditor.off(\"transaction\", fn);\n      };\n    }\n    return void 0;\n  }\n};\nfunction useEditorState(options) {\n  var _a;\n  const [editorStateManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new EditorStateManager(options.editor));\n  const selectedState = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_4__.useSyncExternalStoreWithSelector)(\n    editorStateManager.subscribe,\n    editorStateManager.getSnapshot,\n    editorStateManager.getServerSnapshot,\n    options.selector,\n    (_a = options.equalityFn) != null ? _a : fast_equals__WEBPACK_IMPORTED_MODULE_5__.deepEqual\n  );\n  useIsomorphicLayoutEffect(() => {\n    return editorStateManager.watch(options.editor);\n  }, [options.editor, editorStateManager]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(selectedState);\n  return selectedState;\n}\n\n// src/useEditor.ts\nvar isDev = \"development\" !== \"production\";\nvar isSSR = typeof window === \"undefined\";\nvar isNext = isSSR || Boolean(typeof window !== \"undefined\" && window.next);\nvar EditorInstanceManager = class _EditorInstanceManager {\n  constructor(options) {\n    /**\n     * The current editor instance.\n     */\n    this.editor = null;\n    /**\n     * The subscriptions to notify when the editor instance\n     * has been created or destroyed.\n     */\n    this.subscriptions = /* @__PURE__ */ new Set();\n    /**\n     * Whether the editor has been mounted.\n     */\n    this.isComponentMounted = false;\n    /**\n     * The most recent dependencies array.\n     */\n    this.previousDeps = null;\n    /**\n     * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n     */\n    this.instanceId = \"\";\n    this.options = options;\n    this.subscriptions = /* @__PURE__ */ new Set();\n    this.setEditor(this.getInitialEditor());\n    this.scheduleDestroy();\n    this.getEditor = this.getEditor.bind(this);\n    this.getServerSnapshot = this.getServerSnapshot.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.refreshEditorInstance = this.refreshEditorInstance.bind(this);\n    this.scheduleDestroy = this.scheduleDestroy.bind(this);\n    this.onRender = this.onRender.bind(this);\n    this.createEditor = this.createEditor.bind(this);\n  }\n  setEditor(editor) {\n    this.editor = editor;\n    this.instanceId = Math.random().toString(36).slice(2, 9);\n    this.subscriptions.forEach((cb) => cb());\n  }\n  getInitialEditor() {\n    if (this.options.current.immediatelyRender === void 0) {\n      if (isSSR || isNext) {\n        if (isDev) {\n          throw new Error(\n            \"Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.\"\n          );\n        }\n        return null;\n      }\n      return this.createEditor();\n    }\n    if (this.options.current.immediatelyRender && isSSR && isDev) {\n      throw new Error(\n        \"Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.\"\n      );\n    }\n    if (this.options.current.immediatelyRender) {\n      return this.createEditor();\n    }\n    return null;\n  }\n  /**\n   * Create a new editor instance. And attach event listeners.\n   */\n  createEditor() {\n    const optionsToApply = {\n      ...this.options.current,\n      // Always call the most recent version of the callback function by default\n      onBeforeCreate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onBeforeCreate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onBlur: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onBlur) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onCreate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onCreate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDestroy: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onDestroy) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onFocus: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onFocus) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onSelectionUpdate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onSelectionUpdate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onTransaction: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onTransaction) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onUpdate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onUpdate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onContentError: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onContentError) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDrop: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onDrop) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onPaste: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onPaste) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDelete: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onDelete) == null ? void 0 : _b.call(_a, ...args);\n      }\n    };\n    const editor = new _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Editor(optionsToApply);\n    return editor;\n  }\n  /**\n   * Get the current editor instance.\n   */\n  getEditor() {\n    return this.editor;\n  }\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot() {\n    return null;\n  }\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(onStoreChange) {\n    this.subscriptions.add(onStoreChange);\n    return () => {\n      this.subscriptions.delete(onStoreChange);\n    };\n  }\n  static compareOptions(a, b) {\n    return Object.keys(a).every((key) => {\n      if ([\n        \"onCreate\",\n        \"onBeforeCreate\",\n        \"onDestroy\",\n        \"onUpdate\",\n        \"onTransaction\",\n        \"onFocus\",\n        \"onBlur\",\n        \"onSelectionUpdate\",\n        \"onContentError\",\n        \"onDrop\",\n        \"onPaste\"\n      ].includes(key)) {\n        return true;\n      }\n      if (key === \"extensions\" && a.extensions && b.extensions) {\n        if (a.extensions.length !== b.extensions.length) {\n          return false;\n        }\n        return a.extensions.every((extension, index) => {\n          var _a;\n          if (extension !== ((_a = b.extensions) == null ? void 0 : _a[index])) {\n            return false;\n          }\n          return true;\n        });\n      }\n      if (a[key] !== b[key]) {\n        return false;\n      }\n      return true;\n    });\n  }\n  /**\n   * On each render, we will create, update, or destroy the editor instance.\n   * @param deps The dependencies to watch for changes\n   * @returns A cleanup function\n   */\n  onRender(deps) {\n    return () => {\n      this.isComponentMounted = true;\n      clearTimeout(this.scheduledDestructionTimeout);\n      if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n        if (!_EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n          this.editor.setOptions({\n            ...this.options.current,\n            editable: this.editor.isEditable\n          });\n        }\n      } else {\n        this.refreshEditorInstance(deps);\n      }\n      return () => {\n        this.isComponentMounted = false;\n        this.scheduleDestroy();\n      };\n    };\n  }\n  /**\n   * Recreate the editor instance if the dependencies have changed.\n   */\n  refreshEditorInstance(deps) {\n    if (this.editor && !this.editor.isDestroyed) {\n      if (this.previousDeps === null) {\n        this.previousDeps = deps;\n        return;\n      }\n      const depsAreEqual = this.previousDeps.length === deps.length && this.previousDeps.every((dep, index) => dep === deps[index]);\n      if (depsAreEqual) {\n        return;\n      }\n    }\n    if (this.editor && !this.editor.isDestroyed) {\n      this.editor.destroy();\n    }\n    this.setEditor(this.createEditor());\n    this.previousDeps = deps;\n  }\n  /**\n   * Schedule the destruction of the editor instance.\n   * This will only destroy the editor if it was not mounted on the next tick.\n   * This is to avoid destroying the editor instance when it's actually still mounted.\n   */\n  scheduleDestroy() {\n    const currentInstanceId = this.instanceId;\n    const currentEditor = this.editor;\n    this.scheduledDestructionTimeout = setTimeout(() => {\n      if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n        if (currentEditor) {\n          currentEditor.setOptions(this.options.current);\n        }\n        return;\n      }\n      if (currentEditor && !currentEditor.isDestroyed) {\n        currentEditor.destroy();\n        if (this.instanceId === currentInstanceId) {\n          this.setEditor(null);\n        }\n      }\n    }, 1);\n  }\n};\nfunction useEditor(options = {}, deps = []) {\n  const mostRecentOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(options);\n  mostRecentOptions.current = options;\n  const [instanceManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new EditorInstanceManager(mostRecentOptions));\n  const editor = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(\n    instanceManager.subscribe,\n    instanceManager.getEditor,\n    instanceManager.getServerSnapshot\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(editor);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(instanceManager.onRender(deps));\n  useEditorState({\n    editor,\n    selector: ({ transactionNumber }) => {\n      if (options.shouldRerenderOnTransaction === false || options.shouldRerenderOnTransaction === void 0) {\n        return null;\n      }\n      if (options.immediatelyRender && transactionNumber === 0) {\n        return 0;\n      }\n      return transactionNumber + 1;\n    }\n  });\n  return editor;\n}\n\n// src/Context.tsx\n\nvar EditorContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  editor: null\n});\nvar EditorConsumer = EditorContext.Consumer;\nvar useCurrentEditor = () => (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorContext);\nfunction EditorProvider({\n  children,\n  slotAfter,\n  slotBefore,\n  editorContainerProps = {},\n  ...editorOptions\n}) {\n  const editor = useEditor(editorOptions);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({ editor }), [editor]);\n  if (!editor) {\n    return null;\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(EditorContext.Provider, { value: contextValue, children: [\n    slotBefore,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(EditorConsumer, { children: ({ editor: currentEditor }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(EditorContent, { editor: currentEditor, ...editorContainerProps }) }),\n    children,\n    slotAfter\n  ] });\n}\n\n// src/useReactNodeView.ts\n\nvar ReactNodeViewContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  onDragStart: () => {\n  },\n  nodeViewContentChildren: void 0,\n  nodeViewContentRef: () => {\n  }\n});\nvar ReactNodeViewContentProvider = ({ children, content }) => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ReactNodeViewContext.Provider, { value: { nodeViewContentChildren: content } }, children);\n};\nvar useReactNodeView = () => (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ReactNodeViewContext);\n\n// src/NodeViewContent.tsx\n\nfunction NodeViewContent({\n  as: Tag = \"div\",\n  ...props\n}) {\n  const { nodeViewContentRef, nodeViewContentChildren } = useReactNodeView();\n  return (\n    // @ts-ignore\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\n      Tag,\n      {\n        ...props,\n        ref: nodeViewContentRef,\n        \"data-node-view-content\": \"\",\n        style: {\n          whiteSpace: \"pre-wrap\",\n          ...props.style\n        },\n        children: nodeViewContentChildren\n      }\n    )\n  );\n}\n\n// src/NodeViewWrapper.tsx\n\n\nvar NodeViewWrapper = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\n  const { onDragStart } = useReactNodeView();\n  const Tag = props.as || \"div\";\n  return (\n    // @ts-ignore\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\n      Tag,\n      {\n        ...props,\n        ref,\n        \"data-node-view-wrapper\": \"\",\n        onDragStart,\n        style: {\n          whiteSpace: \"normal\",\n          ...props.style\n        }\n      }\n    )\n  );\n});\n\n// src/ReactMarkViewRenderer.tsx\n\n\n\n// src/ReactRenderer.tsx\n\n\n\nfunction isClassComponent(Component) {\n  return !!(typeof Component === \"function\" && Component.prototype && Component.prototype.isReactComponent);\n}\nfunction isForwardRefComponent(Component) {\n  return !!(typeof Component === \"object\" && Component.$$typeof && (Component.$$typeof.toString() === \"Symbol(react.forward_ref)\" || Component.$$typeof.description === \"react.forward_ref\"));\n}\nfunction isMemoComponent(Component) {\n  return !!(typeof Component === \"object\" && Component.$$typeof && (Component.$$typeof.toString() === \"Symbol(react.memo)\" || Component.$$typeof.description === \"react.memo\"));\n}\nfunction canReceiveRef(Component) {\n  if (isClassComponent(Component)) {\n    return true;\n  }\n  if (isForwardRefComponent(Component)) {\n    return true;\n  }\n  if (isMemoComponent(Component)) {\n    const wrappedComponent = Component.type;\n    if (wrappedComponent) {\n      return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent);\n    }\n  }\n  return false;\n}\nfunction isReact19Plus() {\n  try {\n    if (react__WEBPACK_IMPORTED_MODULE_0__.version) {\n      const majorVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version.split(\".\")[0], 10);\n      return majorVersion >= 19;\n    }\n  } catch {\n  }\n  return false;\n}\nvar ReactRenderer = class {\n  /**\n   * Immediately creates element and renders the provided React component.\n   */\n  constructor(component, { editor, props = {}, as = \"div\", className = \"\" }) {\n    this.ref = null;\n    this.id = Math.floor(Math.random() * 4294967295).toString();\n    this.component = component;\n    this.editor = editor;\n    this.props = props;\n    this.element = document.createElement(as);\n    this.element.classList.add(\"react-renderer\");\n    if (className) {\n      this.element.classList.add(...className.split(\" \"));\n    }\n    if (this.editor.isInitialized) {\n      (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => {\n        this.render();\n      });\n    } else {\n      queueMicrotask(() => {\n        this.render();\n      });\n    }\n  }\n  /**\n   * Render the React component.\n   */\n  render() {\n    var _a;\n    const Component = this.component;\n    const props = this.props;\n    const editor = this.editor;\n    const isReact19 = isReact19Plus();\n    const componentCanReceiveRef = canReceiveRef(Component);\n    const elementProps = { ...props };\n    if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {\n      delete elementProps.ref;\n    }\n    if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {\n      elementProps.ref = (ref) => {\n        this.ref = ref;\n      };\n    }\n    this.reactElement = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Component, { ...elementProps });\n    (_a = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a.setRenderer(this.id, this);\n  }\n  /**\n   * Re-renders the React component with new props.\n   */\n  updateProps(props = {}) {\n    this.props = {\n      ...this.props,\n      ...props\n    };\n    this.render();\n  }\n  /**\n   * Destroy the React component.\n   */\n  destroy() {\n    var _a;\n    const editor = this.editor;\n    (_a = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a.removeRenderer(this.id);\n    try {\n      if (this.element && this.element.parentNode) {\n        this.element.parentNode.removeChild(this.element);\n      }\n    } catch {\n    }\n  }\n  /**\n   * Update the attributes of the element that holds the React component.\n   */\n  updateAttributes(attributes) {\n    Object.keys(attributes).forEach((key) => {\n      this.element.setAttribute(key, attributes[key]);\n    });\n  }\n};\n\n// src/ReactMarkViewRenderer.tsx\n\nvar ReactMarkViewContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  markViewContentRef: () => {\n  }\n});\nvar MarkViewContent = (props) => {\n  const { as: Tag = \"span\", ...rest } = props;\n  const { markViewContentRef } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ReactMarkViewContext);\n  return (\n    // @ts-ignore\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Tag, { ...rest, ref: markViewContentRef, \"data-mark-view-content\": \"\" })\n  );\n};\nvar ReactMarkView = class extends _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.MarkView {\n  constructor(component, props, options) {\n    super(component, props, options);\n    const { as = \"span\", attrs, className = \"\" } = options || {};\n    const componentProps = { ...props, updateAttributes: this.updateAttributes.bind(this) };\n    this.contentDOMElement = document.createElement(\"span\");\n    const markViewContentRef = (el) => {\n      if (el && !el.contains(this.contentDOMElement)) {\n        el.appendChild(this.contentDOMElement);\n      }\n    };\n    const context = {\n      markViewContentRef\n    };\n    const ReactMarkViewProvider = react__WEBPACK_IMPORTED_MODULE_0__.memo((componentProps2) => {\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(ReactMarkViewContext.Provider, { value: context, children: react__WEBPACK_IMPORTED_MODULE_0__.createElement(component, componentProps2) });\n    });\n    ReactMarkViewProvider.displayName = \"ReactMarkView\";\n    this.renderer = new ReactRenderer(ReactMarkViewProvider, {\n      editor: props.editor,\n      props: componentProps,\n      as,\n      className: `mark-${props.mark.type.name} ${className}`.trim()\n    });\n    if (attrs) {\n      this.renderer.updateAttributes(attrs);\n    }\n  }\n  get dom() {\n    return this.renderer.element;\n  }\n  get contentDOM() {\n    return this.contentDOMElement;\n  }\n};\nfunction ReactMarkViewRenderer(component, options = {}) {\n  return (props) => new ReactMarkView(component, props, options);\n}\n\n// src/ReactNodeViewRenderer.tsx\n\n\n\nvar ReactNodeView = class extends _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.NodeView {\n  constructor(component, props, options) {\n    super(component, props, options);\n    /**\n     * The requestAnimationFrame ID used for selection updates.\n     */\n    this.selectionRafId = null;\n    if (!this.node.isLeaf) {\n      if (this.options.contentDOMElementTag) {\n        this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);\n      } else {\n        this.contentDOMElement = document.createElement(this.node.isInline ? \"span\" : \"div\");\n      }\n      this.contentDOMElement.dataset.nodeViewContentReact = \"\";\n      this.contentDOMElement.dataset.nodeViewWrapper = \"\";\n      this.contentDOMElement.style.whiteSpace = \"inherit\";\n      const contentTarget = this.dom.querySelector(\"[data-node-view-content]\");\n      if (!contentTarget) {\n        return;\n      }\n      contentTarget.appendChild(this.contentDOMElement);\n    }\n  }\n  /**\n   * Setup the React component.\n   * Called on initialization.\n   */\n  mount() {\n    const props = {\n      editor: this.editor,\n      node: this.node,\n      decorations: this.decorations,\n      innerDecorations: this.innerDecorations,\n      view: this.view,\n      selected: false,\n      extension: this.extension,\n      HTMLAttributes: this.HTMLAttributes,\n      getPos: () => this.getPos(),\n      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n      deleteNode: () => this.deleteNode(),\n      ref: (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)()\n    };\n    if (!this.component.displayName) {\n      const capitalizeFirstChar = (string) => {\n        return string.charAt(0).toUpperCase() + string.substring(1);\n      };\n      this.component.displayName = capitalizeFirstChar(this.extension.name);\n    }\n    const onDragStart = this.onDragStart.bind(this);\n    const nodeViewContentRef = (element) => {\n      if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n        if (element.hasAttribute(\"data-node-view-wrapper\")) {\n          element.removeAttribute(\"data-node-view-wrapper\");\n        }\n        element.appendChild(this.contentDOMElement);\n      }\n    };\n    const context = { onDragStart, nodeViewContentRef };\n    const Component = this.component;\n    const ReactNodeViewProvider = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)((componentProps) => {\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(ReactNodeViewContext.Provider, { value: context, children: (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component, componentProps) });\n    });\n    ReactNodeViewProvider.displayName = \"ReactNodeView\";\n    let as = this.node.isInline ? \"span\" : \"div\";\n    if (this.options.as) {\n      as = this.options.as;\n    }\n    const { className = \"\" } = this.options;\n    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);\n    this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n      editor: this.editor,\n      props,\n      as,\n      className: `node-${this.node.type.name} ${className}`.trim()\n    });\n    this.editor.on(\"selectionUpdate\", this.handleSelectionUpdate);\n    this.updateElementAttributes();\n  }\n  /**\n   * Return the DOM element.\n   * This is the element that will be used to display the node view.\n   */\n  get dom() {\n    var _a;\n    if (this.renderer.element.firstElementChild && !((_a = this.renderer.element.firstElementChild) == null ? void 0 : _a.hasAttribute(\"data-node-view-wrapper\"))) {\n      throw Error(\"Please use the NodeViewWrapper component for your node view.\");\n    }\n    return this.renderer.element;\n  }\n  /**\n   * Return the content DOM element.\n   * This is the element that will be used to display the rich-text content of the node.\n   */\n  get contentDOM() {\n    if (this.node.isLeaf) {\n      return null;\n    }\n    return this.contentDOMElement;\n  }\n  /**\n   * On editor selection update, check if the node is selected.\n   * If it is, call `selectNode`, otherwise call `deselectNode`.\n   */\n  handleSelectionUpdate() {\n    if (this.selectionRafId) {\n      cancelAnimationFrame(this.selectionRafId);\n      this.selectionRafId = null;\n    }\n    this.selectionRafId = requestAnimationFrame(() => {\n      this.selectionRafId = null;\n      const { from, to } = this.editor.state.selection;\n      const pos = this.getPos();\n      if (typeof pos !== \"number\") {\n        return;\n      }\n      if (from <= pos && to >= pos + this.node.nodeSize) {\n        if (this.renderer.props.selected) {\n          return;\n        }\n        this.selectNode();\n      } else {\n        if (!this.renderer.props.selected) {\n          return;\n        }\n        this.deselectNode();\n      }\n    });\n  }\n  /**\n   * On update, update the React component.\n   * To prevent unnecessary updates, the `update` option can be used.\n   */\n  update(node, decorations, innerDecorations) {\n    const rerenderComponent = (props) => {\n      this.renderer.updateProps(props);\n      if (typeof this.options.attrs === \"function\") {\n        this.updateElementAttributes();\n      }\n    };\n    if (node.type !== this.node.type) {\n      return false;\n    }\n    if (typeof this.options.update === \"function\") {\n      const oldNode = this.node;\n      const oldDecorations = this.decorations;\n      const oldInnerDecorations = this.innerDecorations;\n      this.node = node;\n      this.decorations = decorations;\n      this.innerDecorations = innerDecorations;\n      return this.options.update({\n        oldNode,\n        oldDecorations,\n        newNode: node,\n        newDecorations: decorations,\n        oldInnerDecorations,\n        innerDecorations,\n        updateProps: () => rerenderComponent({ node, decorations, innerDecorations })\n      });\n    }\n    if (node === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {\n      return true;\n    }\n    this.node = node;\n    this.decorations = decorations;\n    this.innerDecorations = innerDecorations;\n    rerenderComponent({ node, decorations, innerDecorations });\n    return true;\n  }\n  /**\n   * Select the node.\n   * Add the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  selectNode() {\n    this.renderer.updateProps({\n      selected: true\n    });\n    this.renderer.element.classList.add(\"ProseMirror-selectednode\");\n  }\n  /**\n   * Deselect the node.\n   * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  deselectNode() {\n    this.renderer.updateProps({\n      selected: false\n    });\n    this.renderer.element.classList.remove(\"ProseMirror-selectednode\");\n  }\n  /**\n   * Destroy the React component instance.\n   */\n  destroy() {\n    this.renderer.destroy();\n    this.editor.off(\"selectionUpdate\", this.handleSelectionUpdate);\n    this.contentDOMElement = null;\n    if (this.selectionRafId) {\n      cancelAnimationFrame(this.selectionRafId);\n      this.selectionRafId = null;\n    }\n  }\n  /**\n   * Update the attributes of the top-level element that holds the React component.\n   * Applying the attributes defined in the `attrs` option.\n   */\n  updateElementAttributes() {\n    if (this.options.attrs) {\n      let attrsObj = {};\n      if (typeof this.options.attrs === \"function\") {\n        const extensionAttributes = this.editor.extensionManager.attributes;\n        const HTMLAttributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getRenderedAttributes)(this.node, extensionAttributes);\n        attrsObj = this.options.attrs({ node: this.node, HTMLAttributes });\n      } else {\n        attrsObj = this.options.attrs;\n      }\n      this.renderer.updateAttributes(attrsObj);\n    }\n  }\n};\nfunction ReactNodeViewRenderer(component, options) {\n  return (props) => {\n    if (!props.editor.contentComponent) {\n      return {};\n    }\n    return new ReactNodeView(component, props, options);\n  };\n}\n\n// src/index.ts\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQzJEOztBQUUzRDtBQUMwQztBQUNUO0FBQzRDO0FBQ3JCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DLG9CQUFvQiwyRkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQUcsQ0FBQyx1REFBUSxJQUFJLG9DQUFvQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtREFBcUI7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNENBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRDQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QywyQkFBMkIsdURBQUksQ0FBQyx1REFBUSxJQUFJO0FBQzVDLHNCQUFzQixzREFBRyxVQUFVLDBEQUEwRDtBQUM3Riw2RUFBNkUsc0RBQUcsWUFBWSwyQ0FBMkM7QUFDdkksT0FBTztBQUNQO0FBQ0E7QUFDQSwyQkFBMkIsaURBQVU7QUFDckM7QUFDQSxnQkFBZ0IsMENBQWE7QUFDN0I7QUFDQSxLQUFLO0FBQ0wsV0FBVyxnREFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQVU7O0FBRTlCO0FBQ3NDO0FBQzBFO0FBQ1Y7O0FBRXRHO0FBQ3dDO0FBQ29DO0FBQ3FCO0FBQ2pHLGdFQUFnRSxrREFBZSxHQUFHLDRDQUFTO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0NBQVE7QUFDdkMsd0JBQXdCLCtHQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrREFBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxvREFBYTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGFBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLDRCQUE0Qiw2Q0FBTTtBQUNsQztBQUNBLDRCQUE0QiwrQ0FBUztBQUNyQyxpQkFBaUIsMkZBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxvREFBYztBQUNoQixFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQytEO0FBQy9ELG9CQUFvQixvREFBYTtBQUNqQztBQUNBLENBQUM7QUFDRDtBQUNBLDZCQUE2QixpREFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLENBQUM7QUFDRDtBQUNBLHVCQUF1Qiw4Q0FBTyxVQUFVLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFLLDJCQUEyQjtBQUN6RDtBQUNBLG9CQUFvQixzREFBSSxtQkFBbUIsYUFBYSx1QkFBdUIscUJBQXFCLHNEQUFJLGtCQUFrQixnREFBZ0QsR0FBRztBQUM3SztBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ2tHO0FBQ2xHLDJCQUEyQixvREFBYztBQUN6QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0NBQXNDLG1CQUFtQjtBQUN6RCxTQUFTLG9EQUFhLGtDQUFrQyxTQUFTLG9DQUFvQztBQUNyRztBQUNBLDZCQUE2QixpREFBVzs7QUFFeEM7QUFDZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFVBQVUsOENBQThDO0FBQ3hEO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQUk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJCO0FBQ3FCO0FBQ2hELHNCQUFzQiw2Q0FBaUI7QUFDdkMsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDd0M7QUFDYjs7QUFFM0I7QUFDZ0Q7QUFDVjtBQUNVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBDQUFZO0FBQ3BCLG9DQUFvQywwQ0FBWTtBQUNoRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQiw4QkFBOEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVM7QUFDZjtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzREFBSSxjQUFjLGlCQUFpQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ2dEO0FBQ2hELDJCQUEyQixnREFBb0I7QUFDL0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFVBQVUsNEJBQTRCO0FBQ3RDLFVBQVUscUJBQXFCLEVBQUUsNkNBQWlCO0FBQ2xEO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQUksUUFBUSxnRUFBZ0U7QUFDaEc7QUFDQTtBQUNBLGtDQUFrQyxrREFBUTtBQUMxQztBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1Q0FBVztBQUM3Qyw2QkFBNkIsc0RBQUksa0NBQWtDLDBCQUEwQixnREFBb0IsOEJBQThCO0FBQy9JLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQixFQUFFLFVBQVU7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUMrRDtBQUNVO0FBQ3pCO0FBQ2hELGtDQUFrQyxrREFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsV0FBVyxnREFBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGtDQUFrQywyQ0FBSTtBQUN0Qyw2QkFBNkIsc0RBQUksa0NBQWtDLDBCQUEwQixvREFBYyw2QkFBNkI7QUFDeEksS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQixFQUFFLFVBQVU7QUFDMUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxQ0FBcUM7QUFDcEYsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFDQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUVBQXFCO0FBQ3BELHdDQUF3QyxpQ0FBaUM7QUFDekUsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNkI7QUFzQjNCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYW5iYW5wcm8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9yZWFjdC9kaXN0L2luZGV4LmpzP2RmNzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL0NvbnRleHQudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9FZGl0b3JDb250ZW50LnRzeFxuaW1wb3J0IFJlYWN0LCB7IGZvcndhcmRSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBSZWFjdERPTSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBGcmFnbWVudCwganN4LCBqc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgbWVyZ2VSZWZzID0gKC4uLnJlZnMpID0+IHtcbiAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgcmVmcy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVmKG5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChyZWYpIHtcbiAgICAgICAgO1xuICAgICAgICByZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59O1xudmFyIFBvcnRhbHMgPSAoeyBjb250ZW50Q29tcG9uZW50IH0pID0+IHtcbiAgY29uc3QgcmVuZGVyZXJzID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgY29udGVudENvbXBvbmVudC5zdWJzY3JpYmUsXG4gICAgY29udGVudENvbXBvbmVudC5nZXRTbmFwc2hvdCxcbiAgICBjb250ZW50Q29tcG9uZW50LmdldFNlcnZlclNuYXBzaG90XG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBPYmplY3QudmFsdWVzKHJlbmRlcmVycykgfSk7XG59O1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2UoKSB7XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IHJlbmRlcmVycyA9IHt9O1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byB0aGUgZWRpdG9yIGluc3RhbmNlJ3MgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgIHN1YnNjcmliZXJzLmFkZChjYWxsYmFjayk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBzdWJzY3JpYmVycy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFNuYXBzaG90KCkge1xuICAgICAgcmV0dXJuIHJlbmRlcmVycztcbiAgICB9LFxuICAgIGdldFNlcnZlclNuYXBzaG90KCkge1xuICAgICAgcmV0dXJuIHJlbmRlcmVycztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgTm9kZVZpZXcgUmVuZGVyZXIgdG8gdGhlIGVkaXRvci5cbiAgICAgKi9cbiAgICBzZXRSZW5kZXJlcihpZCwgcmVuZGVyZXIpIHtcbiAgICAgIHJlbmRlcmVycyA9IHtcbiAgICAgICAgLi4ucmVuZGVyZXJzLFxuICAgICAgICBbaWRdOiBSZWFjdERPTS5jcmVhdGVQb3J0YWwocmVuZGVyZXIucmVhY3RFbGVtZW50LCByZW5kZXJlci5lbGVtZW50LCBpZClcbiAgICAgIH07XG4gICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyKCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIE5vZGVWaWV3IFJlbmRlcmVyIGZyb20gdGhlIGVkaXRvci5cbiAgICAgKi9cbiAgICByZW1vdmVSZW5kZXJlcihpZCkge1xuICAgICAgY29uc3QgbmV4dFJlbmRlcmVycyA9IHsgLi4ucmVuZGVyZXJzIH07XG4gICAgICBkZWxldGUgbmV4dFJlbmRlcmVyc1tpZF07XG4gICAgICByZW5kZXJlcnMgPSBuZXh0UmVuZGVyZXJzO1xuICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlcigpKTtcbiAgICB9XG4gIH07XG59XG52YXIgUHVyZUVkaXRvckNvbnRlbnQgPSBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLmVkaXRvckNvbnRlbnRSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhhc0NvbnRlbnRDb21wb25lbnRJbml0aWFsaXplZDogQm9vbGVhbigoX2EgPSBwcm9wcy5lZGl0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jb250ZW50Q29tcG9uZW50KVxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3I7XG4gICAgaWYgKGVkaXRvciAmJiAhZWRpdG9yLmlzRGVzdHJveWVkICYmIGVkaXRvci5vcHRpb25zLmVsZW1lbnQpIHtcbiAgICAgIGlmIChlZGl0b3IuY29udGVudENvbXBvbmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lZGl0b3JDb250ZW50UmVmLmN1cnJlbnQ7XG4gICAgICBlbGVtZW50LmFwcGVuZChlZGl0b3Iudmlldy5kb20pO1xuICAgICAgZWRpdG9yLnNldE9wdGlvbnMoe1xuICAgICAgICBlbGVtZW50XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5jb250ZW50Q29tcG9uZW50ID0gZ2V0SW5zdGFuY2UoKTtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5oYXNDb250ZW50Q29tcG9uZW50SW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZVRvQ29udGVudENvbXBvbmVudCA9IGVkaXRvci5jb250ZW50Q29tcG9uZW50LnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSgocHJldlN0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXByZXZTdGF0ZS5oYXNDb250ZW50Q29tcG9uZW50SW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBoYXNDb250ZW50Q29tcG9uZW50SW5pdGlhbGl6ZWQ6IHRydWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWRpdG9yLmNyZWF0ZU5vZGVWaWV3cygpO1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvcjtcbiAgICBpZiAoIWVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgaWYgKCFlZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgIGVkaXRvci52aWV3LnNldFByb3BzKHtcbiAgICAgICAgbm9kZVZpZXdzOiB7fVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50KSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50KCk7XG4gICAgfVxuICAgIGVkaXRvci5jb250ZW50Q29tcG9uZW50ID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgaWYgKCEoKF9hID0gZWRpdG9yLnZpZXcuZG9tKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBuZXdFbGVtZW50LmFwcGVuZChlZGl0b3Iudmlldy5kb20pO1xuICAgICAgZWRpdG9yLnNldE9wdGlvbnMoe1xuICAgICAgICBlbGVtZW50OiBuZXdFbGVtZW50XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yLCBpbm5lclJlZiwgLi4ucmVzdCB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyByZWY6IG1lcmdlUmVmcyhpbm5lclJlZiwgdGhpcy5lZGl0b3JDb250ZW50UmVmKSwgLi4ucmVzdCB9KSxcbiAgICAgIChlZGl0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVkaXRvci5jb250ZW50Q29tcG9uZW50KSAmJiAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhbHMsIHsgY29udGVudENvbXBvbmVudDogZWRpdG9yLmNvbnRlbnRDb21wb25lbnQgfSlcbiAgICBdIH0pO1xuICB9XG59O1xudmFyIEVkaXRvckNvbnRlbnRXaXRoS2V5ID0gZm9yd2FyZFJlZihcbiAgKHByb3BzLCByZWYpID0+IHtcbiAgICBjb25zdCBrZXkgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0Mjk0OTY3Mjk1KS50b1N0cmluZygpO1xuICAgIH0sIFtwcm9wcy5lZGl0b3JdKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChQdXJlRWRpdG9yQ29udGVudCwge1xuICAgICAga2V5LFxuICAgICAgaW5uZXJSZWY6IHJlZixcbiAgICAgIC4uLnByb3BzXG4gICAgfSk7XG4gIH1cbik7XG52YXIgRWRpdG9yQ29udGVudCA9IFJlYWN0Lm1lbW8oRWRpdG9yQ29udGVudFdpdGhLZXkpO1xuXG4vLyBzcmMvdXNlRWRpdG9yLnRzXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyB1c2VEZWJ1Z1ZhbHVlIGFzIHVzZURlYnVnVmFsdWUyLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiwgdXNlUmVmLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlMiB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzXCI7XG5cbi8vIHNyYy91c2VFZGl0b3JTdGF0ZS50c1xuaW1wb3J0IHsgZGVlcEVxdWFsIH0gZnJvbSBcImZhc3QtZXF1YWxzXCI7XG5pbXBvcnQgeyB1c2VEZWJ1Z1ZhbHVlLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvci5qc1wiO1xudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xudmFyIEVkaXRvclN0YXRlTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5pdGlhbEVkaXRvcikge1xuICAgIHRoaXMudHJhbnNhY3Rpb25OdW1iZXIgPSAwO1xuICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uTnVtYmVyID0gMDtcbiAgICB0aGlzLnN1YnNjcmliZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmVkaXRvciA9IGluaXRpYWxFZGl0b3I7XG4gICAgdGhpcy5sYXN0U25hcHNob3QgPSB7IGVkaXRvcjogaW5pdGlhbEVkaXRvciwgdHJhbnNhY3Rpb25OdW1iZXI6IDAgfTtcbiAgICB0aGlzLmdldFNuYXBzaG90ID0gdGhpcy5nZXRTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0U2VydmVyU25hcHNob3QgPSB0aGlzLmdldFNlcnZlclNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgdGhpcy53YXRjaCA9IHRoaXMud2F0Y2guYmluZCh0aGlzKTtcbiAgICB0aGlzLnN1YnNjcmliZSA9IHRoaXMuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gICAqL1xuICBnZXRTbmFwc2hvdCgpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbk51bWJlciA9PT0gdGhpcy5sYXN0VHJhbnNhY3Rpb25OdW1iZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhc3RTbmFwc2hvdDtcbiAgICB9XG4gICAgdGhpcy5sYXN0VHJhbnNhY3Rpb25OdW1iZXIgPSB0aGlzLnRyYW5zYWN0aW9uTnVtYmVyO1xuICAgIHRoaXMubGFzdFNuYXBzaG90ID0geyBlZGl0b3I6IHRoaXMuZWRpdG9yLCB0cmFuc2FjdGlvbk51bWJlcjogdGhpcy50cmFuc2FjdGlvbk51bWJlciB9O1xuICAgIHJldHVybiB0aGlzLmxhc3RTbmFwc2hvdDtcbiAgfVxuICAvKipcbiAgICogQWx3YXlzIGRpc2FibGUgdGhlIGVkaXRvciBvbiB0aGUgc2VydmVyLXNpZGUuXG4gICAqL1xuICBnZXRTZXJ2ZXJTbmFwc2hvdCgpIHtcbiAgICByZXR1cm4geyBlZGl0b3I6IG51bGwsIHRyYW5zYWN0aW9uTnVtYmVyOiAwIH07XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUgZWRpdG9yIGluc3RhbmNlJ3MgY2hhbmdlcy5cbiAgICovXG4gIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5zdWJzY3JpYmVycy5kZWxldGUoY2FsbGJhY2spO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFdhdGNoIHRoZSBlZGl0b3IgaW5zdGFuY2UgZm9yIGNoYW5nZXMuXG4gICAqL1xuICB3YXRjaChuZXh0RWRpdG9yKSB7XG4gICAgdGhpcy5lZGl0b3IgPSBuZXh0RWRpdG9yO1xuICAgIGlmICh0aGlzLmVkaXRvcikge1xuICAgICAgY29uc3QgZm4gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25OdW1iZXIgKz0gMTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgY3VycmVudEVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgY3VycmVudEVkaXRvci5vbihcInRyYW5zYWN0aW9uXCIsIGZuKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGN1cnJlbnRFZGl0b3Iub2ZmKFwidHJhbnNhY3Rpb25cIiwgZm4pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcbmZ1bmN0aW9uIHVzZUVkaXRvclN0YXRlKG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBbZWRpdG9yU3RhdGVNYW5hZ2VyXSA9IHVzZVN0YXRlKCgpID0+IG5ldyBFZGl0b3JTdGF0ZU1hbmFnZXIob3B0aW9ucy5lZGl0b3IpKTtcbiAgY29uc3Qgc2VsZWN0ZWRTdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIGVkaXRvclN0YXRlTWFuYWdlci5zdWJzY3JpYmUsXG4gICAgZWRpdG9yU3RhdGVNYW5hZ2VyLmdldFNuYXBzaG90LFxuICAgIGVkaXRvclN0YXRlTWFuYWdlci5nZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICBvcHRpb25zLnNlbGVjdG9yLFxuICAgIChfYSA9IG9wdGlvbnMuZXF1YWxpdHlGbikgIT0gbnVsbCA/IF9hIDogZGVlcEVxdWFsXG4gICk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBlZGl0b3JTdGF0ZU1hbmFnZXIud2F0Y2gob3B0aW9ucy5lZGl0b3IpO1xuICB9LCBbb3B0aW9ucy5lZGl0b3IsIGVkaXRvclN0YXRlTWFuYWdlcl0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHNlbGVjdGVkU3RhdGUpO1xuICByZXR1cm4gc2VsZWN0ZWRTdGF0ZTtcbn1cblxuLy8gc3JjL3VzZUVkaXRvci50c1xudmFyIGlzRGV2ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiO1xudmFyIGlzU1NSID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIjtcbnZhciBpc05leHQgPSBpc1NTUiB8fCBCb29sZWFuKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5leHQpO1xudmFyIEVkaXRvckluc3RhbmNlTWFuYWdlciA9IGNsYXNzIF9FZGl0b3JJbnN0YW5jZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHRoaXMuZWRpdG9yID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgc3Vic2NyaXB0aW9ucyB0byBub3RpZnkgd2hlbiB0aGUgZWRpdG9yIGluc3RhbmNlXG4gICAgICogaGFzIGJlZW4gY3JlYXRlZCBvciBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBlZGl0b3IgaGFzIGJlZW4gbW91bnRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmlzQ29tcG9uZW50TW91bnRlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb3N0IHJlY2VudCBkZXBlbmRlbmNpZXMgYXJyYXkuXG4gICAgICovXG4gICAgdGhpcy5wcmV2aW91c0RlcHMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoZSB1bmlxdWUgaW5zdGFuY2UgSUQuIFRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgZWRpdG9yIGluc3RhbmNlLiBBbmQgd2lsbCBiZSByZS1nZW5lcmF0ZWQgZm9yIGVhY2ggbmV3IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IFwiXCI7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuc2V0RWRpdG9yKHRoaXMuZ2V0SW5pdGlhbEVkaXRvcigpKTtcbiAgICB0aGlzLnNjaGVkdWxlRGVzdHJveSgpO1xuICAgIHRoaXMuZ2V0RWRpdG9yID0gdGhpcy5nZXRFZGl0b3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldFNlcnZlclNuYXBzaG90ID0gdGhpcy5nZXRTZXJ2ZXJTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3Vic2NyaWJlID0gdGhpcy5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlZnJlc2hFZGl0b3JJbnN0YW5jZSA9IHRoaXMucmVmcmVzaEVkaXRvckluc3RhbmNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zY2hlZHVsZURlc3Ryb3kgPSB0aGlzLnNjaGVkdWxlRGVzdHJveS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25SZW5kZXIgPSB0aGlzLm9uUmVuZGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jcmVhdGVFZGl0b3IgPSB0aGlzLmNyZWF0ZUVkaXRvci5iaW5kKHRoaXMpO1xuICB9XG4gIHNldEVkaXRvcihlZGl0b3IpIHtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLmluc3RhbmNlSWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCA5KTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICB9XG4gIGdldEluaXRpYWxFZGl0b3IoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jdXJyZW50LmltbWVkaWF0ZWx5UmVuZGVyID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChpc1NTUiB8fCBpc05leHQpIHtcbiAgICAgICAgaWYgKGlzRGV2KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJUaXB0YXAgRXJyb3I6IFNTUiBoYXMgYmVlbiBkZXRlY3RlZCwgcGxlYXNlIHNldCBgaW1tZWRpYXRlbHlSZW5kZXJgIGV4cGxpY2l0bHkgdG8gYGZhbHNlYCB0byBhdm9pZCBoeWRyYXRpb24gbWlzbWF0Y2hlcy5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVFZGl0b3IoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jdXJyZW50LmltbWVkaWF0ZWx5UmVuZGVyICYmIGlzU1NSICYmIGlzRGV2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVGlwdGFwIEVycm9yOiBTU1IgaGFzIGJlZW4gZGV0ZWN0ZWQsIGFuZCBgaW1tZWRpYXRlbHlSZW5kZXJgIGhhcyBiZWVuIHNldCB0byBgdHJ1ZWAgdGhpcyBpcyBhbiB1bnN1cHBvcnRlZCBjb25maWd1cmF0aW9uIHRoYXQgbWF5IHJlc3VsdCBpbiBlcnJvcnMsIGV4cGxpY2l0bHkgc2V0IGBpbW1lZGlhdGVseVJlbmRlcmAgdG8gYGZhbHNlYCB0byBhdm9pZCBoeWRyYXRpb24gbWlzbWF0Y2hlcy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jdXJyZW50LmltbWVkaWF0ZWx5UmVuZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVFZGl0b3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBlZGl0b3IgaW5zdGFuY2UuIEFuZCBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzLlxuICAgKi9cbiAgY3JlYXRlRWRpdG9yKCkge1xuICAgIGNvbnN0IG9wdGlvbnNUb0FwcGx5ID0ge1xuICAgICAgLi4udGhpcy5vcHRpb25zLmN1cnJlbnQsXG4gICAgICAvLyBBbHdheXMgY2FsbCB0aGUgbW9zdCByZWNlbnQgdmVyc2lvbiBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gYnkgZGVmYXVsdFxuICAgICAgb25CZWZvcmVDcmVhdGU6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25CZWZvcmVDcmVhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvbkJsdXI6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25CbHVyKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgb25DcmVhdGU6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25DcmVhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvbkRlc3Ryb3k6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25EZXN0cm95KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgb25Gb2N1czogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkZvY3VzKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgb25TZWxlY3Rpb25VcGRhdGU6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25TZWxlY3Rpb25VcGRhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvblRyYW5zYWN0aW9uOiAoLi4uYXJncykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uVHJhbnNhY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvblVwZGF0ZTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblVwZGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uQ29udGVudEVycm9yOiAoLi4uYXJncykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uQ29udGVudEVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgb25Ecm9wOiAoLi4uYXJncykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uRHJvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uUGFzdGU6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25QYXN0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uRGVsZXRlOiAoLi4uYXJncykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uRGVsZXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBlZGl0b3IgPSBuZXcgRWRpdG9yKG9wdGlvbnNUb0FwcGx5KTtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlLlxuICAgKi9cbiAgZ2V0RWRpdG9yKCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRvcjtcbiAgfVxuICAvKipcbiAgICogQWx3YXlzIGRpc2FibGUgdGhlIGVkaXRvciBvbiB0aGUgc2VydmVyLXNpZGUuXG4gICAqL1xuICBnZXRTZXJ2ZXJTbmFwc2hvdCgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBlZGl0b3IgaW5zdGFuY2UncyBjaGFuZ2VzLlxuICAgKi9cbiAgc3Vic2NyaWJlKG9uU3RvcmVDaGFuZ2UpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKG9uU3RvcmVDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKG9uU3RvcmVDaGFuZ2UpO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGNvbXBhcmVPcHRpb25zKGEsIGIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYSkuZXZlcnkoKGtleSkgPT4ge1xuICAgICAgaWYgKFtcbiAgICAgICAgXCJvbkNyZWF0ZVwiLFxuICAgICAgICBcIm9uQmVmb3JlQ3JlYXRlXCIsXG4gICAgICAgIFwib25EZXN0cm95XCIsXG4gICAgICAgIFwib25VcGRhdGVcIixcbiAgICAgICAgXCJvblRyYW5zYWN0aW9uXCIsXG4gICAgICAgIFwib25Gb2N1c1wiLFxuICAgICAgICBcIm9uQmx1clwiLFxuICAgICAgICBcIm9uU2VsZWN0aW9uVXBkYXRlXCIsXG4gICAgICAgIFwib25Db250ZW50RXJyb3JcIixcbiAgICAgICAgXCJvbkRyb3BcIixcbiAgICAgICAgXCJvblBhc3RlXCJcbiAgICAgIF0uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09IFwiZXh0ZW5zaW9uc1wiICYmIGEuZXh0ZW5zaW9ucyAmJiBiLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgaWYgKGEuZXh0ZW5zaW9ucy5sZW5ndGggIT09IGIuZXh0ZW5zaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEuZXh0ZW5zaW9ucy5ldmVyeSgoZXh0ZW5zaW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uICE9PSAoKF9hID0gYi5leHRlbnNpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2FbaW5kZXhdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoYVtrZXldICE9PSBiW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE9uIGVhY2ggcmVuZGVyLCB3ZSB3aWxsIGNyZWF0ZSwgdXBkYXRlLCBvciBkZXN0cm95IHRoZSBlZGl0b3IgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBkZXBzIFRoZSBkZXBlbmRlbmNpZXMgdG8gd2F0Y2ggZm9yIGNoYW5nZXNcbiAgICogQHJldHVybnMgQSBjbGVhbnVwIGZ1bmN0aW9uXG4gICAqL1xuICBvblJlbmRlcihkZXBzKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuaXNDb21wb25lbnRNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNjaGVkdWxlZERlc3RydWN0aW9uVGltZW91dCk7XG4gICAgICBpZiAodGhpcy5lZGl0b3IgJiYgIXRoaXMuZWRpdG9yLmlzRGVzdHJveWVkICYmIGRlcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmICghX0VkaXRvckluc3RhbmNlTWFuYWdlci5jb21wYXJlT3B0aW9ucyh0aGlzLm9wdGlvbnMuY3VycmVudCwgdGhpcy5lZGl0b3Iub3B0aW9ucykpIHtcbiAgICAgICAgICB0aGlzLmVkaXRvci5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5jdXJyZW50LFxuICAgICAgICAgICAgZWRpdGFibGU6IHRoaXMuZWRpdG9yLmlzRWRpdGFibGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoRWRpdG9ySW5zdGFuY2UoZGVwcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0aGlzLmlzQ29tcG9uZW50TW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlRGVzdHJveSgpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZWNyZWF0ZSB0aGUgZWRpdG9yIGluc3RhbmNlIGlmIHRoZSBkZXBlbmRlbmNpZXMgaGF2ZSBjaGFuZ2VkLlxuICAgKi9cbiAgcmVmcmVzaEVkaXRvckluc3RhbmNlKGRlcHMpIHtcbiAgICBpZiAodGhpcy5lZGl0b3IgJiYgIXRoaXMuZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICBpZiAodGhpcy5wcmV2aW91c0RlcHMgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c0RlcHMgPSBkZXBzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkZXBzQXJlRXF1YWwgPSB0aGlzLnByZXZpb3VzRGVwcy5sZW5ndGggPT09IGRlcHMubGVuZ3RoICYmIHRoaXMucHJldmlvdXNEZXBzLmV2ZXJ5KChkZXAsIGluZGV4KSA9PiBkZXAgPT09IGRlcHNbaW5kZXhdKTtcbiAgICAgIGlmIChkZXBzQXJlRXF1YWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5lZGl0b3IgJiYgIXRoaXMuZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICB0aGlzLmVkaXRvci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuc2V0RWRpdG9yKHRoaXMuY3JlYXRlRWRpdG9yKCkpO1xuICAgIHRoaXMucHJldmlvdXNEZXBzID0gZGVwcztcbiAgfVxuICAvKipcbiAgICogU2NoZWR1bGUgdGhlIGRlc3RydWN0aW9uIG9mIHRoZSBlZGl0b3IgaW5zdGFuY2UuXG4gICAqIFRoaXMgd2lsbCBvbmx5IGRlc3Ryb3kgdGhlIGVkaXRvciBpZiBpdCB3YXMgbm90IG1vdW50ZWQgb24gdGhlIG5leHQgdGljay5cbiAgICogVGhpcyBpcyB0byBhdm9pZCBkZXN0cm95aW5nIHRoZSBlZGl0b3IgaW5zdGFuY2Ugd2hlbiBpdCdzIGFjdHVhbGx5IHN0aWxsIG1vdW50ZWQuXG4gICAqL1xuICBzY2hlZHVsZURlc3Ryb3koKSB7XG4gICAgY29uc3QgY3VycmVudEluc3RhbmNlSWQgPSB0aGlzLmluc3RhbmNlSWQ7XG4gICAgY29uc3QgY3VycmVudEVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIHRoaXMuc2NoZWR1bGVkRGVzdHJ1Y3Rpb25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0NvbXBvbmVudE1vdW50ZWQgJiYgdGhpcy5pbnN0YW5jZUlkID09PSBjdXJyZW50SW5zdGFuY2VJZCkge1xuICAgICAgICBpZiAoY3VycmVudEVkaXRvcikge1xuICAgICAgICAgIGN1cnJlbnRFZGl0b3Iuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRFZGl0b3IgJiYgIWN1cnJlbnRFZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgY3VycmVudEVkaXRvci5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlSWQgPT09IGN1cnJlbnRJbnN0YW5jZUlkKSB7XG4gICAgICAgICAgdGhpcy5zZXRFZGl0b3IobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAxKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHVzZUVkaXRvcihvcHRpb25zID0ge30sIGRlcHMgPSBbXSkge1xuICBjb25zdCBtb3N0UmVjZW50T3B0aW9ucyA9IHVzZVJlZihvcHRpb25zKTtcbiAgbW9zdFJlY2VudE9wdGlvbnMuY3VycmVudCA9IG9wdGlvbnM7XG4gIGNvbnN0IFtpbnN0YW5jZU1hbmFnZXJdID0gdXNlU3RhdGUyKCgpID0+IG5ldyBFZGl0b3JJbnN0YW5jZU1hbmFnZXIobW9zdFJlY2VudE9wdGlvbnMpKTtcbiAgY29uc3QgZWRpdG9yID0gdXNlU3luY0V4dGVybmFsU3RvcmUyKFxuICAgIGluc3RhbmNlTWFuYWdlci5zdWJzY3JpYmUsXG4gICAgaW5zdGFuY2VNYW5hZ2VyLmdldEVkaXRvcixcbiAgICBpbnN0YW5jZU1hbmFnZXIuZ2V0U2VydmVyU25hcHNob3RcbiAgKTtcbiAgdXNlRGVidWdWYWx1ZTIoZWRpdG9yKTtcbiAgdXNlRWZmZWN0MihpbnN0YW5jZU1hbmFnZXIub25SZW5kZXIoZGVwcykpO1xuICB1c2VFZGl0b3JTdGF0ZSh7XG4gICAgZWRpdG9yLFxuICAgIHNlbGVjdG9yOiAoeyB0cmFuc2FjdGlvbk51bWJlciB9KSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy5zaG91bGRSZXJlbmRlck9uVHJhbnNhY3Rpb24gPT09IGZhbHNlIHx8IG9wdGlvbnMuc2hvdWxkUmVyZW5kZXJPblRyYW5zYWN0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGVseVJlbmRlciAmJiB0cmFuc2FjdGlvbk51bWJlciA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbk51bWJlciArIDE7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVkaXRvcjtcbn1cblxuLy8gc3JjL0NvbnRleHQudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MiwganN4cyBhcyBqc3hzMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEVkaXRvckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtcbiAgZWRpdG9yOiBudWxsXG59KTtcbnZhciBFZGl0b3JDb25zdW1lciA9IEVkaXRvckNvbnRleHQuQ29uc3VtZXI7XG52YXIgdXNlQ3VycmVudEVkaXRvciA9ICgpID0+IHVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG5mdW5jdGlvbiBFZGl0b3JQcm92aWRlcih7XG4gIGNoaWxkcmVuLFxuICBzbG90QWZ0ZXIsXG4gIHNsb3RCZWZvcmUsXG4gIGVkaXRvckNvbnRhaW5lclByb3BzID0ge30sXG4gIC4uLmVkaXRvck9wdGlvbnNcbn0pIHtcbiAgY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKGVkaXRvck9wdGlvbnMpO1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7IGVkaXRvciB9KSwgW2VkaXRvcl0pO1xuICBpZiAoIWVkaXRvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4czIoRWRpdG9yQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlLCBjaGlsZHJlbjogW1xuICAgIHNsb3RCZWZvcmUsXG4gICAgLyogQF9fUFVSRV9fICovIGpzeDIoRWRpdG9yQ29uc3VtZXIsIHsgY2hpbGRyZW46ICh7IGVkaXRvcjogY3VycmVudEVkaXRvciB9KSA9PiAvKiBAX19QVVJFX18gKi8ganN4MihFZGl0b3JDb250ZW50LCB7IGVkaXRvcjogY3VycmVudEVkaXRvciwgLi4uZWRpdG9yQ29udGFpbmVyUHJvcHMgfSkgfSksXG4gICAgY2hpbGRyZW4sXG4gICAgc2xvdEFmdGVyXG4gIF0gfSk7XG59XG5cbi8vIHNyYy91c2VSZWFjdE5vZGVWaWV3LnRzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQyLCBjcmVhdGVFbGVtZW50LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgUmVhY3ROb2RlVmlld0NvbnRleHQgPSBjcmVhdGVDb250ZXh0Mih7XG4gIG9uRHJhZ1N0YXJ0OiAoKSA9PiB7XG4gIH0sXG4gIG5vZGVWaWV3Q29udGVudENoaWxkcmVuOiB2b2lkIDAsXG4gIG5vZGVWaWV3Q29udGVudFJlZjogKCkgPT4ge1xuICB9XG59KTtcbnZhciBSZWFjdE5vZGVWaWV3Q29udGVudFByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIGNvbnRlbnQgfSkgPT4ge1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChSZWFjdE5vZGVWaWV3Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyBub2RlVmlld0NvbnRlbnRDaGlsZHJlbjogY29udGVudCB9IH0sIGNoaWxkcmVuKTtcbn07XG52YXIgdXNlUmVhY3ROb2RlVmlldyA9ICgpID0+IHVzZUNvbnRleHQyKFJlYWN0Tm9kZVZpZXdDb250ZXh0KTtcblxuLy8gc3JjL05vZGVWaWV3Q29udGVudC50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiBOb2RlVmlld0NvbnRlbnQoe1xuICBhczogVGFnID0gXCJkaXZcIixcbiAgLi4ucHJvcHNcbn0pIHtcbiAgY29uc3QgeyBub2RlVmlld0NvbnRlbnRSZWYsIG5vZGVWaWV3Q29udGVudENoaWxkcmVuIH0gPSB1c2VSZWFjdE5vZGVWaWV3KCk7XG4gIHJldHVybiAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gzKFxuICAgICAgVGFnLFxuICAgICAge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgcmVmOiBub2RlVmlld0NvbnRlbnRSZWYsXG4gICAgICAgIFwiZGF0YS1ub2RlLXZpZXctY29udGVudFwiOiBcIlwiLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHdoaXRlU3BhY2U6IFwicHJlLXdyYXBcIixcbiAgICAgICAgICAuLi5wcm9wcy5zdHlsZVxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogbm9kZVZpZXdDb250ZW50Q2hpbGRyZW5cbiAgICAgIH1cbiAgICApXG4gICk7XG59XG5cbi8vIHNyYy9Ob2RlVmlld1dyYXBwZXIudHN4XG5pbXBvcnQgUmVhY3QzIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBOb2RlVmlld1dyYXBwZXIgPSBSZWFjdDMuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCB7IG9uRHJhZ1N0YXJ0IH0gPSB1c2VSZWFjdE5vZGVWaWV3KCk7XG4gIGNvbnN0IFRhZyA9IHByb3BzLmFzIHx8IFwiZGl2XCI7XG4gIHJldHVybiAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KFxuICAgICAgVGFnLFxuICAgICAge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgcmVmLFxuICAgICAgICBcImRhdGEtbm9kZS12aWV3LXdyYXBwZXJcIjogXCJcIixcbiAgICAgICAgb25EcmFnU3RhcnQsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgd2hpdGVTcGFjZTogXCJub3JtYWxcIixcbiAgICAgICAgICAuLi5wcm9wcy5zdHlsZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuICApO1xufSk7XG5cbi8vIHNyYy9SZWFjdE1hcmtWaWV3UmVuZGVyZXIudHN4XG5pbXBvcnQgeyBNYXJrVmlldyB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCBSZWFjdDQgZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9SZWFjdFJlbmRlcmVyLnRzeFxuaW1wb3J0IHsgdmVyc2lvbiBhcyByZWFjdFZlcnNpb24gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGZsdXNoU3luYyB9IGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7IGpzeCBhcyBqc3g1IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KENvbXBvbmVudCkge1xuICByZXR1cm4gISEodHlwZW9mIENvbXBvbmVudCA9PT0gXCJmdW5jdGlvblwiICYmIENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZkNvbXBvbmVudChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKHR5cGVvZiBDb21wb25lbnQgPT09IFwib2JqZWN0XCIgJiYgQ29tcG9uZW50LiQkdHlwZW9mICYmIChDb21wb25lbnQuJCR0eXBlb2YudG9TdHJpbmcoKSA9PT0gXCJTeW1ib2wocmVhY3QuZm9yd2FyZF9yZWYpXCIgfHwgQ29tcG9uZW50LiQkdHlwZW9mLmRlc2NyaXB0aW9uID09PSBcInJlYWN0LmZvcndhcmRfcmVmXCIpKTtcbn1cbmZ1bmN0aW9uIGlzTWVtb0NvbXBvbmVudChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKHR5cGVvZiBDb21wb25lbnQgPT09IFwib2JqZWN0XCIgJiYgQ29tcG9uZW50LiQkdHlwZW9mICYmIChDb21wb25lbnQuJCR0eXBlb2YudG9TdHJpbmcoKSA9PT0gXCJTeW1ib2wocmVhY3QubWVtbylcIiB8fCBDb21wb25lbnQuJCR0eXBlb2YuZGVzY3JpcHRpb24gPT09IFwicmVhY3QubWVtb1wiKSk7XG59XG5mdW5jdGlvbiBjYW5SZWNlaXZlUmVmKENvbXBvbmVudCkge1xuICBpZiAoaXNDbGFzc0NvbXBvbmVudChDb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzRm9yd2FyZFJlZkNvbXBvbmVudChDb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzTWVtb0NvbXBvbmVudChDb21wb25lbnQpKSB7XG4gICAgY29uc3Qgd3JhcHBlZENvbXBvbmVudCA9IENvbXBvbmVudC50eXBlO1xuICAgIGlmICh3cmFwcGVkQ29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gaXNDbGFzc0NvbXBvbmVudCh3cmFwcGVkQ29tcG9uZW50KSB8fCBpc0ZvcndhcmRSZWZDb21wb25lbnQod3JhcHBlZENvbXBvbmVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzUmVhY3QxOVBsdXMoKSB7XG4gIHRyeSB7XG4gICAgaWYgKHJlYWN0VmVyc2lvbikge1xuICAgICAgY29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQocmVhY3RWZXJzaW9uLnNwbGl0KFwiLlwiKVswXSwgMTApO1xuICAgICAgcmV0dXJuIG1ham9yVmVyc2lvbiA+PSAxOTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBSZWFjdFJlbmRlcmVyID0gY2xhc3Mge1xuICAvKipcbiAgICogSW1tZWRpYXRlbHkgY3JlYXRlcyBlbGVtZW50IGFuZCByZW5kZXJzIHRoZSBwcm92aWRlZCBSZWFjdCBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQsIHsgZWRpdG9yLCBwcm9wcyA9IHt9LCBhcyA9IFwiZGl2XCIsIGNsYXNzTmFtZSA9IFwiXCIgfSkge1xuICAgIHRoaXMucmVmID0gbnVsbDtcbiAgICB0aGlzLmlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NSkudG9TdHJpbmcoKTtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChhcyk7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJyZWFjdC1yZW5kZXJlclwiKTtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWUuc3BsaXQoXCIgXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWRpdG9yLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIGNvbnN0IGlzUmVhY3QxOSA9IGlzUmVhY3QxOVBsdXMoKTtcbiAgICBjb25zdCBjb21wb25lbnRDYW5SZWNlaXZlUmVmID0gY2FuUmVjZWl2ZVJlZihDb21wb25lbnQpO1xuICAgIGNvbnN0IGVsZW1lbnRQcm9wcyA9IHsgLi4ucHJvcHMgfTtcbiAgICBpZiAoZWxlbWVudFByb3BzLnJlZiAmJiAhKGlzUmVhY3QxOSB8fCBjb21wb25lbnRDYW5SZWNlaXZlUmVmKSkge1xuICAgICAgZGVsZXRlIGVsZW1lbnRQcm9wcy5yZWY7XG4gICAgfVxuICAgIGlmICghZWxlbWVudFByb3BzLnJlZiAmJiAoaXNSZWFjdDE5IHx8IGNvbXBvbmVudENhblJlY2VpdmVSZWYpKSB7XG4gICAgICBlbGVtZW50UHJvcHMucmVmID0gKHJlZikgPT4ge1xuICAgICAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMucmVhY3RFbGVtZW50ID0gLyogQF9fUFVSRV9fICovIGpzeDUoQ29tcG9uZW50LCB7IC4uLmVsZW1lbnRQcm9wcyB9KTtcbiAgICAoX2EgPSBlZGl0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVkaXRvci5jb250ZW50Q29tcG9uZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2V0UmVuZGVyZXIodGhpcy5pZCwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlLXJlbmRlcnMgdGhlIFJlYWN0IGNvbXBvbmVudCB3aXRoIG5ldyBwcm9wcy5cbiAgICovXG4gIHVwZGF0ZVByb3BzKHByb3BzID0ge30pIHtcbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgLi4udGhpcy5wcm9wcyxcbiAgICAgIC4uLnByb3BzXG4gICAgfTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAoX2EgPSBlZGl0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVkaXRvci5jb250ZW50Q29tcG9uZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVtb3ZlUmVuZGVyZXIodGhpcy5pZCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQgJiYgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudCB0aGF0IGhvbGRzIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqL1xuICB1cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvUmVhY3RNYXJrVmlld1JlbmRlcmVyLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDYgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSZWFjdE1hcmtWaWV3Q29udGV4dCA9IFJlYWN0NC5jcmVhdGVDb250ZXh0KHtcbiAgbWFya1ZpZXdDb250ZW50UmVmOiAoKSA9PiB7XG4gIH1cbn0pO1xudmFyIE1hcmtWaWV3Q29udGVudCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGFzOiBUYWcgPSBcInNwYW5cIiwgLi4ucmVzdCB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgbWFya1ZpZXdDb250ZW50UmVmIH0gPSBSZWFjdDQudXNlQ29udGV4dChSZWFjdE1hcmtWaWV3Q29udGV4dCk7XG4gIHJldHVybiAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g2KFRhZywgeyAuLi5yZXN0LCByZWY6IG1hcmtWaWV3Q29udGVudFJlZiwgXCJkYXRhLW1hcmstdmlldy1jb250ZW50XCI6IFwiXCIgfSlcbiAgKTtcbn07XG52YXIgUmVhY3RNYXJrVmlldyA9IGNsYXNzIGV4dGVuZHMgTWFya1ZpZXcge1xuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucyk7XG4gICAgY29uc3QgeyBhcyA9IFwic3BhblwiLCBhdHRycywgY2xhc3NOYW1lID0gXCJcIiB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBjb21wb25lbnRQcm9wcyA9IHsgLi4ucHJvcHMsIHVwZGF0ZUF0dHJpYnV0ZXM6IHRoaXMudXBkYXRlQXR0cmlidXRlcy5iaW5kKHRoaXMpIH07XG4gICAgdGhpcy5jb250ZW50RE9NRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGNvbnN0IG1hcmtWaWV3Q29udGVudFJlZiA9IChlbCkgPT4ge1xuICAgICAgaWYgKGVsICYmICFlbC5jb250YWlucyh0aGlzLmNvbnRlbnRET01FbGVtZW50KSkge1xuICAgICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET01FbGVtZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBtYXJrVmlld0NvbnRlbnRSZWZcbiAgICB9O1xuICAgIGNvbnN0IFJlYWN0TWFya1ZpZXdQcm92aWRlciA9IFJlYWN0NC5tZW1vKChjb21wb25lbnRQcm9wczIpID0+IHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NihSZWFjdE1hcmtWaWV3Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCwgY2hpbGRyZW46IFJlYWN0NC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMyKSB9KTtcbiAgICB9KTtcbiAgICBSZWFjdE1hcmtWaWV3UHJvdmlkZXIuZGlzcGxheU5hbWUgPSBcIlJlYWN0TWFya1ZpZXdcIjtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlYWN0UmVuZGVyZXIoUmVhY3RNYXJrVmlld1Byb3ZpZGVyLCB7XG4gICAgICBlZGl0b3I6IHByb3BzLmVkaXRvcixcbiAgICAgIHByb3BzOiBjb21wb25lbnRQcm9wcyxcbiAgICAgIGFzLFxuICAgICAgY2xhc3NOYW1lOiBgbWFyay0ke3Byb3BzLm1hcmsudHlwZS5uYW1lfSAke2NsYXNzTmFtZX1gLnRyaW0oKVxuICAgIH0pO1xuICAgIGlmIChhdHRycykge1xuICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVBdHRyaWJ1dGVzKGF0dHJzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGRvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5lbGVtZW50O1xuICB9XG4gIGdldCBjb250ZW50RE9NKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRET01FbGVtZW50O1xuICB9XG59O1xuZnVuY3Rpb24gUmVhY3RNYXJrVmlld1JlbmRlcmVyKGNvbXBvbmVudCwgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiAocHJvcHMpID0+IG5ldyBSZWFjdE1hcmtWaWV3KGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvUmVhY3ROb2RlVmlld1JlbmRlcmVyLnRzeFxuaW1wb3J0IHsgZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzLCBOb2RlVmlldyB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDIsIGNyZWF0ZVJlZiwgbWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDcgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSZWFjdE5vZGVWaWV3ID0gY2xhc3MgZXh0ZW5kcyBOb2RlVmlldyB7XG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihjb21wb25lbnQsIHByb3BzLCBvcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIElEIHVzZWQgZm9yIHNlbGVjdGlvbiB1cGRhdGVzLlxuICAgICAqL1xuICAgIHRoaXMuc2VsZWN0aW9uUmFmSWQgPSBudWxsO1xuICAgIGlmICghdGhpcy5ub2RlLmlzTGVhZikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50RE9NRWxlbWVudFRhZykge1xuICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm9wdGlvbnMuY29udGVudERPTUVsZW1lbnRUYWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlLmlzSW5saW5lID8gXCJzcGFuXCIgOiBcImRpdlwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQuZGF0YXNldC5ub2RlVmlld0NvbnRlbnRSZWFjdCA9IFwiXCI7XG4gICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50LmRhdGFzZXQubm9kZVZpZXdXcmFwcGVyID0gXCJcIjtcbiAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQuc3R5bGUud2hpdGVTcGFjZSA9IFwiaW5oZXJpdFwiO1xuICAgICAgY29uc3QgY29udGVudFRhcmdldCA9IHRoaXMuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1ub2RlLXZpZXctY29udGVudF1cIik7XG4gICAgICBpZiAoIWNvbnRlbnRUYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udGVudFRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET01FbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHVwIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqIENhbGxlZCBvbiBpbml0aWFsaXphdGlvbi5cbiAgICovXG4gIG1vdW50KCkge1xuICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgIG5vZGU6IHRoaXMubm9kZSxcbiAgICAgIGRlY29yYXRpb25zOiB0aGlzLmRlY29yYXRpb25zLFxuICAgICAgaW5uZXJEZWNvcmF0aW9uczogdGhpcy5pbm5lckRlY29yYXRpb25zLFxuICAgICAgdmlldzogdGhpcy52aWV3LFxuICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgZXh0ZW5zaW9uOiB0aGlzLmV4dGVuc2lvbixcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB0aGlzLkhUTUxBdHRyaWJ1dGVzLFxuICAgICAgZ2V0UG9zOiAoKSA9PiB0aGlzLmdldFBvcygpLFxuICAgICAgdXBkYXRlQXR0cmlidXRlczogKGF0dHJpYnV0ZXMgPSB7fSkgPT4gdGhpcy51cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpLFxuICAgICAgZGVsZXRlTm9kZTogKCkgPT4gdGhpcy5kZWxldGVOb2RlKCksXG4gICAgICByZWY6IGNyZWF0ZVJlZigpXG4gICAgfTtcbiAgICBpZiAoIXRoaXMuY29tcG9uZW50LmRpc3BsYXlOYW1lKSB7XG4gICAgICBjb25zdCBjYXBpdGFsaXplRmlyc3RDaGFyID0gKHN0cmluZykgPT4ge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnN1YnN0cmluZygxKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmNvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGNhcGl0YWxpemVGaXJzdENoYXIodGhpcy5leHRlbnNpb24ubmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IG9uRHJhZ1N0YXJ0ID0gdGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IG5vZGVWaWV3Q29udGVudFJlZiA9IChlbGVtZW50KSA9PiB7XG4gICAgICBpZiAoZWxlbWVudCAmJiB0aGlzLmNvbnRlbnRET01FbGVtZW50ICYmIGVsZW1lbnQuZmlyc3RDaGlsZCAhPT0gdGhpcy5jb250ZW50RE9NRWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkYXRhLW5vZGUtdmlldy13cmFwcGVyXCIpKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLW5vZGUtdmlldy13cmFwcGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RE9NRWxlbWVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjb250ZXh0ID0geyBvbkRyYWdTdGFydCwgbm9kZVZpZXdDb250ZW50UmVmIH07XG4gICAgY29uc3QgQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgY29uc3QgUmVhY3ROb2RlVmlld1Byb3ZpZGVyID0gbWVtbygoY29tcG9uZW50UHJvcHMpID0+IHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NyhSZWFjdE5vZGVWaWV3Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCwgY2hpbGRyZW46IGNyZWF0ZUVsZW1lbnQyKENvbXBvbmVudCwgY29tcG9uZW50UHJvcHMpIH0pO1xuICAgIH0pO1xuICAgIFJlYWN0Tm9kZVZpZXdQcm92aWRlci5kaXNwbGF5TmFtZSA9IFwiUmVhY3ROb2RlVmlld1wiO1xuICAgIGxldCBhcyA9IHRoaXMubm9kZS5pc0lubGluZSA/IFwic3BhblwiIDogXCJkaXZcIjtcbiAgICBpZiAodGhpcy5vcHRpb25zLmFzKSB7XG4gICAgICBhcyA9IHRoaXMub3B0aW9ucy5hcztcbiAgICB9XG4gICAgY29uc3QgeyBjbGFzc05hbWUgPSBcIlwiIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUgPSB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVhY3RSZW5kZXJlcihSZWFjdE5vZGVWaWV3UHJvdmlkZXIsIHtcbiAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICBwcm9wcyxcbiAgICAgIGFzLFxuICAgICAgY2xhc3NOYW1lOiBgbm9kZS0ke3RoaXMubm9kZS50eXBlLm5hbWV9ICR7Y2xhc3NOYW1lfWAudHJpbSgpXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3Iub24oXCJzZWxlY3Rpb25VcGRhdGVcIiwgdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudEF0dHJpYnV0ZXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBET00gZWxlbWVudC5cbiAgICogVGhpcyBpcyB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkaXNwbGF5IHRoZSBub2RlIHZpZXcuXG4gICAqL1xuICBnZXQgZG9tKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGhpcy5yZW5kZXJlci5lbGVtZW50LmZpcnN0RWxlbWVudENoaWxkICYmICEoKF9hID0gdGhpcy5yZW5kZXJlci5lbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGFzQXR0cmlidXRlKFwiZGF0YS1ub2RlLXZpZXctd3JhcHBlclwiKSkpIHtcbiAgICAgIHRocm93IEVycm9yKFwiUGxlYXNlIHVzZSB0aGUgTm9kZVZpZXdXcmFwcGVyIGNvbXBvbmVudCBmb3IgeW91ciBub2RlIHZpZXcuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5lbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvbnRlbnQgRE9NIGVsZW1lbnQuXG4gICAqIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGlzcGxheSB0aGUgcmljaC10ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGUuXG4gICAqL1xuICBnZXQgY29udGVudERPTSgpIHtcbiAgICBpZiAodGhpcy5ub2RlLmlzTGVhZikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRET01FbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBPbiBlZGl0b3Igc2VsZWN0aW9uIHVwZGF0ZSwgY2hlY2sgaWYgdGhlIG5vZGUgaXMgc2VsZWN0ZWQuXG4gICAqIElmIGl0IGlzLCBjYWxsIGBzZWxlY3ROb2RlYCwgb3RoZXJ3aXNlIGNhbGwgYGRlc2VsZWN0Tm9kZWAuXG4gICAqL1xuICBoYW5kbGVTZWxlY3Rpb25VcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uUmFmSWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2VsZWN0aW9uUmFmSWQpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25SYWZJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0aW9uUmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5zZWxlY3Rpb25SYWZJZCA9IG51bGw7XG4gICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICBjb25zdCBwb3MgPSB0aGlzLmdldFBvcygpO1xuICAgICAgaWYgKHR5cGVvZiBwb3MgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZyb20gPD0gcG9zICYmIHRvID49IHBvcyArIHRoaXMubm9kZS5ub2RlU2l6ZSkge1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5wcm9wcy5zZWxlY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdE5vZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJlci5wcm9wcy5zZWxlY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc2VsZWN0Tm9kZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBPbiB1cGRhdGUsIHVwZGF0ZSB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgKiBUbyBwcmV2ZW50IHVubmVjZXNzYXJ5IHVwZGF0ZXMsIHRoZSBgdXBkYXRlYCBvcHRpb24gY2FuIGJlIHVzZWQuXG4gICAqL1xuICB1cGRhdGUobm9kZSwgZGVjb3JhdGlvbnMsIGlubmVyRGVjb3JhdGlvbnMpIHtcbiAgICBjb25zdCByZXJlbmRlckNvbXBvbmVudCA9IChwcm9wcykgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyhwcm9wcyk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hdHRycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudEF0dHJpYnV0ZXMoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChub2RlLnR5cGUgIT09IHRoaXMubm9kZS50eXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBvbGROb2RlID0gdGhpcy5ub2RlO1xuICAgICAgY29uc3Qgb2xkRGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRpb25zO1xuICAgICAgY29uc3Qgb2xkSW5uZXJEZWNvcmF0aW9ucyA9IHRoaXMuaW5uZXJEZWNvcmF0aW9ucztcbiAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICB0aGlzLmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4gICAgICB0aGlzLmlubmVyRGVjb3JhdGlvbnMgPSBpbm5lckRlY29yYXRpb25zO1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy51cGRhdGUoe1xuICAgICAgICBvbGROb2RlLFxuICAgICAgICBvbGREZWNvcmF0aW9ucyxcbiAgICAgICAgbmV3Tm9kZTogbm9kZSxcbiAgICAgICAgbmV3RGVjb3JhdGlvbnM6IGRlY29yYXRpb25zLFxuICAgICAgICBvbGRJbm5lckRlY29yYXRpb25zLFxuICAgICAgICBpbm5lckRlY29yYXRpb25zLFxuICAgICAgICB1cGRhdGVQcm9wczogKCkgPT4gcmVyZW5kZXJDb21wb25lbnQoeyBub2RlLCBkZWNvcmF0aW9ucywgaW5uZXJEZWNvcmF0aW9ucyB9KVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChub2RlID09PSB0aGlzLm5vZGUgJiYgdGhpcy5kZWNvcmF0aW9ucyA9PT0gZGVjb3JhdGlvbnMgJiYgdGhpcy5pbm5lckRlY29yYXRpb25zID09PSBpbm5lckRlY29yYXRpb25zKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4gICAgdGhpcy5pbm5lckRlY29yYXRpb25zID0gaW5uZXJEZWNvcmF0aW9ucztcbiAgICByZXJlbmRlckNvbXBvbmVudCh7IG5vZGUsIGRlY29yYXRpb25zLCBpbm5lckRlY29yYXRpb25zIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3QgdGhlIG5vZGUuXG4gICAqIEFkZCB0aGUgYHNlbGVjdGVkYCBwcm9wIGFuZCB0aGUgYFByb3NlTWlycm9yLXNlbGVjdGVkbm9kZWAgY2xhc3MuXG4gICAqL1xuICBzZWxlY3ROb2RlKCkge1xuICAgIHRoaXMucmVuZGVyZXIudXBkYXRlUHJvcHMoe1xuICAgICAgc2VsZWN0ZWQ6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlcmVyLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgfVxuICAvKipcbiAgICogRGVzZWxlY3QgdGhlIG5vZGUuXG4gICAqIFJlbW92ZSB0aGUgYHNlbGVjdGVkYCBwcm9wIGFuZCB0aGUgYFByb3NlTWlycm9yLXNlbGVjdGVkbm9kZWAgY2xhc3MuXG4gICAqL1xuICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyh7XG4gICAgICBzZWxlY3RlZDogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlcmVyLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveSB0aGUgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmVkaXRvci5vZmYoXCJzZWxlY3Rpb25VcGRhdGVcIiwgdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUpO1xuICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblJhZklkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNlbGVjdGlvblJhZklkKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uUmFmSWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSB0b3AtbGV2ZWwgZWxlbWVudCB0aGF0IGhvbGRzIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEFwcGx5aW5nIHRoZSBhdHRyaWJ1dGVzIGRlZmluZWQgaW4gdGhlIGBhdHRyc2Agb3B0aW9uLlxuICAgKi9cbiAgdXBkYXRlRWxlbWVudEF0dHJpYnV0ZXMoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdHRycykge1xuICAgICAgbGV0IGF0dHJzT2JqID0ge307XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hdHRycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXM7XG4gICAgICAgIGNvbnN0IEhUTUxBdHRyaWJ1dGVzID0gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKHRoaXMubm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyk7XG4gICAgICAgIGF0dHJzT2JqID0gdGhpcy5vcHRpb25zLmF0dHJzKHsgbm9kZTogdGhpcy5ub2RlLCBIVE1MQXR0cmlidXRlcyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzT2JqID0gdGhpcy5vcHRpb25zLmF0dHJzO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVBdHRyaWJ1dGVzKGF0dHJzT2JqKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBSZWFjdE5vZGVWaWV3UmVuZGVyZXIoY29tcG9uZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiAocHJvcHMpID0+IHtcbiAgICBpZiAoIXByb3BzLmVkaXRvci5jb250ZW50Q29tcG9uZW50KSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVhY3ROb2RlVmlldyhjb21wb25lbnQsIHByb3BzLCBvcHRpb25zKTtcbiAgfTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5leHBvcnQge1xuICBFZGl0b3JDb25zdW1lcixcbiAgRWRpdG9yQ29udGVudCxcbiAgRWRpdG9yQ29udGV4dCxcbiAgRWRpdG9yUHJvdmlkZXIsXG4gIE1hcmtWaWV3Q29udGVudCxcbiAgTm9kZVZpZXdDb250ZW50LFxuICBOb2RlVmlld1dyYXBwZXIsXG4gIFB1cmVFZGl0b3JDb250ZW50LFxuICBSZWFjdE1hcmtWaWV3LFxuICBSZWFjdE1hcmtWaWV3Q29udGV4dCxcbiAgUmVhY3RNYXJrVmlld1JlbmRlcmVyLFxuICBSZWFjdE5vZGVWaWV3LFxuICBSZWFjdE5vZGVWaWV3Q29udGVudFByb3ZpZGVyLFxuICBSZWFjdE5vZGVWaWV3Q29udGV4dCxcbiAgUmVhY3ROb2RlVmlld1JlbmRlcmVyLFxuICBSZWFjdFJlbmRlcmVyLFxuICB1c2VDdXJyZW50RWRpdG9yLFxuICB1c2VFZGl0b3IsXG4gIHVzZUVkaXRvclN0YXRlLFxuICB1c2VSZWFjdE5vZGVWaWV3XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/starter-kit/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/starter-kit/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StarterKit: () => (/* binding */ StarterKit),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-blockquote */ \"(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-bold */ \"(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-code */ \"(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-code-block */ \"(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js\");\n/* harmony import */ var _tiptap_extension_document__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-document */ \"(ssr)/./node_modules/@tiptap/extension-document/dist/index.js\");\n/* harmony import */ var _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-hard-break */ \"(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\");\n/* harmony import */ var _tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-heading */ \"(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js\");\n/* harmony import */ var _tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-horizontal-rule */ \"(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\");\n/* harmony import */ var _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-italic */ \"(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\");\n/* harmony import */ var _tiptap_extension_link__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-link */ \"(ssr)/./node_modules/@tiptap/extension-link/dist/index.js\");\n/* harmony import */ var _tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-list */ \"(ssr)/./node_modules/@tiptap/extension-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tiptap/extension-paragraph */ \"(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js\");\n/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-strike */ \"(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\");\n/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/extension-text */ \"(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\");\n/* harmony import */ var _tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tiptap/extension-underline */ \"(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js\");\n/* harmony import */ var _tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/extensions */ \"(ssr)/./node_modules/@tiptap/extensions/dist/index.js\");\n// src/starter-kit.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar StarterKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_16__.Extension.create({\n  name: \"starterKit\",\n  addExtensions() {\n    var _a, _b, _c, _d;\n    const extensions = [];\n    if (this.options.bold !== false) {\n      extensions.push(_tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__.Bold.configure(this.options.bold));\n    }\n    if (this.options.blockquote !== false) {\n      extensions.push(_tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__.Blockquote.configure(this.options.blockquote));\n    }\n    if (this.options.bulletList !== false) {\n      extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.BulletList.configure(this.options.bulletList));\n    }\n    if (this.options.code !== false) {\n      extensions.push(_tiptap_extension_code__WEBPACK_IMPORTED_MODULE_2__.Code.configure(this.options.code));\n    }\n    if (this.options.codeBlock !== false) {\n      extensions.push(_tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_3__.CodeBlock.configure(this.options.codeBlock));\n    }\n    if (this.options.document !== false) {\n      extensions.push(_tiptap_extension_document__WEBPACK_IMPORTED_MODULE_4__.Document.configure(this.options.document));\n    }\n    if (this.options.dropcursor !== false) {\n      extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.Dropcursor.configure(this.options.dropcursor));\n    }\n    if (this.options.gapcursor !== false) {\n      extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.Gapcursor.configure(this.options.gapcursor));\n    }\n    if (this.options.hardBreak !== false) {\n      extensions.push(_tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_5__.HardBreak.configure(this.options.hardBreak));\n    }\n    if (this.options.heading !== false) {\n      extensions.push(_tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_6__.Heading.configure(this.options.heading));\n    }\n    if (this.options.undoRedo !== false) {\n      extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.UndoRedo.configure(this.options.undoRedo));\n    }\n    if (this.options.horizontalRule !== false) {\n      extensions.push(_tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_7__.HorizontalRule.configure(this.options.horizontalRule));\n    }\n    if (this.options.italic !== false) {\n      extensions.push(_tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_8__.Italic.configure(this.options.italic));\n    }\n    if (this.options.listItem !== false) {\n      extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.ListItem.configure(this.options.listItem));\n    }\n    if (this.options.listKeymap !== false) {\n      extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.ListKeymap.configure((_a = this.options) == null ? void 0 : _a.listKeymap));\n    }\n    if (this.options.link !== false) {\n      extensions.push(_tiptap_extension_link__WEBPACK_IMPORTED_MODULE_9__.Link.configure((_b = this.options) == null ? void 0 : _b.link));\n    }\n    if (this.options.orderedList !== false) {\n      extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.OrderedList.configure(this.options.orderedList));\n    }\n    if (this.options.paragraph !== false) {\n      extensions.push(_tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_11__.Paragraph.configure(this.options.paragraph));\n    }\n    if (this.options.strike !== false) {\n      extensions.push(_tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_12__.Strike.configure(this.options.strike));\n    }\n    if (this.options.text !== false) {\n      extensions.push(_tiptap_extension_text__WEBPACK_IMPORTED_MODULE_13__.Text.configure(this.options.text));\n    }\n    if (this.options.underline !== false) {\n      extensions.push(_tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_14__.Underline.configure((_c = this.options) == null ? void 0 : _c.underline));\n    }\n    if (this.options.trailingNode !== false) {\n      extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.TrailingNode.configure((_d = this.options) == null ? void 0 : _d.trailingNode));\n    }\n    return extensions;\n  }\n});\n\n// src/index.ts\nvar index_default = StarterKit;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdGFydGVyLWtpdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN5QztBQUNpQjtBQUNaO0FBQ0E7QUFDVztBQUNIO0FBQ0c7QUFDTDtBQUNlO0FBQ2pCO0FBQ0o7QUFDeUM7QUFDL0I7QUFDTjtBQUNKO0FBQ1U7QUFDMkI7QUFDbkYsaUJBQWlCLG9EQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQUk7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQixvRUFBVTtBQUNoQztBQUNBO0FBQ0Esc0JBQXNCLCtEQUFVO0FBQ2hDO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQUk7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQixtRUFBUztBQUMvQjtBQUNBO0FBQ0Esc0JBQXNCLGdFQUFRO0FBQzlCO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQVU7QUFDaEM7QUFDQTtBQUNBLHNCQUFzQiwwREFBUztBQUMvQjtBQUNBO0FBQ0Esc0JBQXNCLG1FQUFTO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsOERBQU87QUFDN0I7QUFDQTtBQUNBLHNCQUFzQix5REFBUTtBQUM5QjtBQUNBO0FBQ0Esc0JBQXNCLDZFQUFjO0FBQ3BDO0FBQ0E7QUFDQSxzQkFBc0IsNERBQU07QUFDNUI7QUFDQTtBQUNBLHNCQUFzQiw2REFBUTtBQUM5QjtBQUNBO0FBQ0Esc0JBQXNCLCtEQUFVO0FBQ2hDO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQUk7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQixnRUFBVztBQUNqQztBQUNBO0FBQ0Esc0JBQXNCLG1FQUFTO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQU07QUFDNUI7QUFDQTtBQUNBLHNCQUFzQix5REFBSTtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCLG1FQUFTO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2thbmJhbnByby8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3N0YXJ0ZXIta2l0L2Rpc3QvaW5kZXguanM/ZjEwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvc3RhcnRlci1raXQudHNcbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IEJsb2NrcXVvdGUgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZVwiO1xuaW1wb3J0IHsgQm9sZCB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1ib2xkXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWNvZGVcIjtcbmltcG9ydCB7IENvZGVCbG9jayB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1jb2RlLWJsb2NrXCI7XG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1kb2N1bWVudFwiO1xuaW1wb3J0IHsgSGFyZEJyZWFrIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWhhcmQtYnJlYWtcIjtcbmltcG9ydCB7IEhlYWRpbmcgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24taGVhZGluZ1wiO1xuaW1wb3J0IHsgSG9yaXpvbnRhbFJ1bGUgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlXCI7XG5pbXBvcnQgeyBJdGFsaWMgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24taXRhbGljXCI7XG5pbXBvcnQgeyBMaW5rIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWxpbmtcIjtcbmltcG9ydCB7IEJ1bGxldExpc3QsIExpc3RJdGVtLCBMaXN0S2V5bWFwLCBPcmRlcmVkTGlzdCB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1saXN0XCI7XG5pbXBvcnQgeyBQYXJhZ3JhcGggfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoXCI7XG5pbXBvcnQgeyBTdHJpa2UgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlXCI7XG5pbXBvcnQgeyBUZXh0IH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLXRleHRcIjtcbmltcG9ydCB7IFVuZGVybGluZSB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi11bmRlcmxpbmVcIjtcbmltcG9ydCB7IERyb3BjdXJzb3IsIEdhcGN1cnNvciwgVHJhaWxpbmdOb2RlLCBVbmRvUmVkbyB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbnNcIjtcbnZhciBTdGFydGVyS2l0ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwic3RhcnRlcktpdFwiLFxuICBhZGRFeHRlbnNpb25zKCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCBleHRlbnNpb25zID0gW107XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ib2xkICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJvbGQuY29uZmlndXJlKHRoaXMub3B0aW9ucy5ib2xkKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmxvY2txdW90ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChCbG9ja3F1b3RlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuYmxvY2txdW90ZSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldExpc3QgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goQnVsbGV0TGlzdC5jb25maWd1cmUodGhpcy5vcHRpb25zLmJ1bGxldExpc3QpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb2RlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKENvZGUuY29uZmlndXJlKHRoaXMub3B0aW9ucy5jb2RlKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29kZUJsb2NrICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKENvZGVCbG9jay5jb25maWd1cmUodGhpcy5vcHRpb25zLmNvZGVCbG9jaykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmRvY3VtZW50ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKERvY3VtZW50LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuZG9jdW1lbnQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kcm9wY3Vyc29yICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKERyb3BjdXJzb3IuY29uZmlndXJlKHRoaXMub3B0aW9ucy5kcm9wY3Vyc29yKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2FwY3Vyc29yICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEdhcGN1cnNvci5jb25maWd1cmUodGhpcy5vcHRpb25zLmdhcGN1cnNvcikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmhhcmRCcmVhayAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChIYXJkQnJlYWsuY29uZmlndXJlKHRoaXMub3B0aW9ucy5oYXJkQnJlYWspKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkaW5nICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhlYWRpbmcuY29uZmlndXJlKHRoaXMub3B0aW9ucy5oZWFkaW5nKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudW5kb1JlZG8gIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVW5kb1JlZG8uY29uZmlndXJlKHRoaXMub3B0aW9ucy51bmRvUmVkbykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmhvcml6b250YWxSdWxlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhvcml6b250YWxSdWxlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbFJ1bGUpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pdGFsaWMgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goSXRhbGljLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuaXRhbGljKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubGlzdEl0ZW0gIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGlzdEl0ZW0uY29uZmlndXJlKHRoaXMub3B0aW9ucy5saXN0SXRlbSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpc3RLZXltYXAgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGlzdEtleW1hcC5jb25maWd1cmUoKF9hID0gdGhpcy5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGlzdEtleW1hcCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpbmsgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGluay5jb25maWd1cmUoKF9iID0gdGhpcy5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2IubGluaykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9yZGVyZWRMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKE9yZGVyZWRMaXN0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMub3JkZXJlZExpc3QpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhZ3JhcGggIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goUGFyYWdyYXBoLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMucGFyYWdyYXBoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaWtlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFN0cmlrZS5jb25maWd1cmUodGhpcy5vcHRpb25zLnN0cmlrZSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRleHQgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVGV4dC5jb25maWd1cmUodGhpcy5vcHRpb25zLnRleHQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy51bmRlcmxpbmUgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVW5kZXJsaW5lLmNvbmZpZ3VyZSgoX2MgPSB0aGlzLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYy51bmRlcmxpbmUpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50cmFpbGluZ05vZGUgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVHJhaWxpbmdOb2RlLmNvbmZpZ3VyZSgoX2QgPSB0aGlzLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZC50cmFpbGluZ05vZGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvbnM7XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gU3RhcnRlcktpdDtcbmV4cG9ydCB7XG4gIFN0YXJ0ZXJLaXQsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/starter-kit/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/suggestion/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/suggestion/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Suggestion: () => (/* binding */ Suggestion),\n/* harmony export */   SuggestionPluginKey: () => (/* binding */ SuggestionPluginKey),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   exitSuggestion: () => (/* binding */ exitSuggestion),\n/* harmony export */   findSuggestionMatch: () => (/* binding */ findSuggestionMatch)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/dist/view/index.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/suggestion.ts\n\n\n\n// src/findSuggestionMatch.ts\n\nfunction findSuggestionMatch(config) {\n  var _a;\n  const { char, allowSpaces: allowSpacesOption, allowToIncludeChar, allowedPrefixes, startOfLine, $position } = config;\n  const allowSpaces = allowSpacesOption && !allowToIncludeChar;\n  const escapedChar = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.escapeForRegEx)(char);\n  const suffix = new RegExp(`\\\\s${escapedChar}$`);\n  const prefix = startOfLine ? \"^\" : \"\";\n  const finalEscapedChar = allowToIncludeChar ? \"\" : escapedChar;\n  const regexp = allowSpaces ? new RegExp(`${prefix}${escapedChar}.*?(?=\\\\s${finalEscapedChar}|$)`, \"gm\") : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\\\s${finalEscapedChar}]*`, \"gm\");\n  const text = ((_a = $position.nodeBefore) == null ? void 0 : _a.isText) && $position.nodeBefore.text;\n  if (!text) {\n    return null;\n  }\n  const textFrom = $position.pos - text.length;\n  const match = Array.from(text.matchAll(regexp)).pop();\n  if (!match || match.input === void 0 || match.index === void 0) {\n    return null;\n  }\n  const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);\n  const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes == null ? void 0 : allowedPrefixes.join(\"\")}\\0]?$`).test(matchPrefix);\n  if (allowedPrefixes !== null && !matchPrefixIsAllowed) {\n    return null;\n  }\n  const from = textFrom + match.index;\n  let to = from + match[0].length;\n  if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\n    match[0] += \" \";\n    to += 1;\n  }\n  if (from < $position.pos && to >= $position.pos) {\n    return {\n      range: {\n        from,\n        to\n      },\n      query: match[0].slice(char.length),\n      text: match[0]\n    };\n  }\n  return null;\n}\n\n// src/suggestion.ts\nvar SuggestionPluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"suggestion\");\nfunction Suggestion({\n  pluginKey = SuggestionPluginKey,\n  editor,\n  char = \"@\",\n  allowSpaces = false,\n  allowToIncludeChar = false,\n  allowedPrefixes = [\" \"],\n  startOfLine = false,\n  decorationTag = \"span\",\n  decorationClass = \"suggestion\",\n  decorationContent = \"\",\n  decorationEmptyClass = \"is-empty\",\n  command = () => null,\n  items = () => [],\n  render = () => ({}),\n  allow = () => true,\n  findSuggestionMatch: findSuggestionMatch2 = findSuggestionMatch\n}) {\n  let props;\n  const renderer = render == null ? void 0 : render();\n  const getAnchorClientRect = () => {\n    const pos = editor.state.selection.$anchor.pos;\n    const coords = editor.view.coordsAtPos(pos);\n    const { top, right, bottom, left } = coords;\n    try {\n      return new DOMRect(left, top, right - left, bottom - top);\n    } catch {\n      return null;\n    }\n  };\n  const clientRectFor = (view, decorationNode) => {\n    if (!decorationNode) {\n      return getAnchorClientRect;\n    }\n    return () => {\n      const state = pluginKey.getState(editor.state);\n      const decorationId = state == null ? void 0 : state.decorationId;\n      const currentDecorationNode = view.dom.querySelector(`[data-decoration-id=\"${decorationId}\"]`);\n      return (currentDecorationNode == null ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;\n    };\n  };\n  function dispatchExit(view, pluginKeyRef) {\n    var _a;\n    try {\n      const state = pluginKey.getState(view.state);\n      const decorationNode = (state == null ? void 0 : state.decorationId) ? view.dom.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`) : null;\n      const exitProps = {\n        // @ts-ignore editor is available in closure\n        editor,\n        range: (state == null ? void 0 : state.range) || { from: 0, to: 0 },\n        query: (state == null ? void 0 : state.query) || null,\n        text: (state == null ? void 0 : state.text) || null,\n        items: [],\n        command: (commandProps) => {\n          return command({ editor, range: (state == null ? void 0 : state.range) || { from: 0, to: 0 }, props: commandProps });\n        },\n        decorationNode,\n        clientRect: clientRectFor(view, decorationNode)\n      };\n      (_a = renderer == null ? void 0 : renderer.onExit) == null ? void 0 : _a.call(renderer, exitProps);\n    } catch {\n    }\n    const tr = view.state.tr.setMeta(pluginKeyRef, { exit: true });\n    view.dispatch(tr);\n  }\n  const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n    key: pluginKey,\n    view() {\n      return {\n        update: async (view, prevState) => {\n          var _a, _b, _c, _d, _e, _f, _g;\n          const prev = (_a = this.key) == null ? void 0 : _a.getState(prevState);\n          const next = (_b = this.key) == null ? void 0 : _b.getState(view.state);\n          const moved = prev.active && next.active && prev.range.from !== next.range.from;\n          const started = !prev.active && next.active;\n          const stopped = prev.active && !next.active;\n          const changed = !started && !stopped && prev.query !== next.query;\n          const handleStart = started || moved && changed;\n          const handleChange = changed || moved;\n          const handleExit = stopped || moved && changed;\n          if (!handleStart && !handleChange && !handleExit) {\n            return;\n          }\n          const state = handleExit && !handleStart ? prev : next;\n          const decorationNode = view.dom.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`);\n          props = {\n            editor,\n            range: state.range,\n            query: state.query,\n            text: state.text,\n            items: [],\n            command: (commandProps) => {\n              return command({\n                editor,\n                range: state.range,\n                props: commandProps\n              });\n            },\n            decorationNode,\n            clientRect: clientRectFor(view, decorationNode)\n          };\n          if (handleStart) {\n            (_c = renderer == null ? void 0 : renderer.onBeforeStart) == null ? void 0 : _c.call(renderer, props);\n          }\n          if (handleChange) {\n            (_d = renderer == null ? void 0 : renderer.onBeforeUpdate) == null ? void 0 : _d.call(renderer, props);\n          }\n          if (handleChange || handleStart) {\n            props.items = await items({\n              editor,\n              query: state.query\n            });\n          }\n          if (handleExit) {\n            (_e = renderer == null ? void 0 : renderer.onExit) == null ? void 0 : _e.call(renderer, props);\n          }\n          if (handleChange) {\n            (_f = renderer == null ? void 0 : renderer.onUpdate) == null ? void 0 : _f.call(renderer, props);\n          }\n          if (handleStart) {\n            (_g = renderer == null ? void 0 : renderer.onStart) == null ? void 0 : _g.call(renderer, props);\n          }\n        },\n        destroy: () => {\n          var _a;\n          if (!props) {\n            return;\n          }\n          (_a = renderer == null ? void 0 : renderer.onExit) == null ? void 0 : _a.call(renderer, props);\n        }\n      };\n    },\n    state: {\n      // Initialize the plugin's internal state.\n      init() {\n        const state = {\n          active: false,\n          range: {\n            from: 0,\n            to: 0\n          },\n          query: null,\n          text: null,\n          composing: false\n        };\n        return state;\n      },\n      // Apply changes to the plugin state from a view transaction.\n      apply(transaction, prev, _oldState, state) {\n        const { isEditable } = editor;\n        const { composing } = editor.view;\n        const { selection } = transaction;\n        const { empty, from } = selection;\n        const next = { ...prev };\n        const meta = transaction.getMeta(pluginKey);\n        if (meta && meta.exit) {\n          next.active = false;\n          next.decorationId = null;\n          next.range = { from: 0, to: 0 };\n          next.query = null;\n          next.text = null;\n          return next;\n        }\n        next.composing = composing;\n        if (isEditable && (empty || editor.view.composing)) {\n          if ((from < prev.range.from || from > prev.range.to) && !composing && !prev.composing) {\n            next.active = false;\n          }\n          const match = findSuggestionMatch2({\n            char,\n            allowSpaces,\n            allowToIncludeChar,\n            allowedPrefixes,\n            startOfLine,\n            $position: selection.$from\n          });\n          const decorationId = `id_${Math.floor(Math.random() * 4294967295)}`;\n          if (match && allow({\n            editor,\n            state,\n            range: match.range,\n            isActive: prev.active\n          })) {\n            next.active = true;\n            next.decorationId = prev.decorationId ? prev.decorationId : decorationId;\n            next.range = match.range;\n            next.query = match.query;\n            next.text = match.text;\n          } else {\n            next.active = false;\n          }\n        } else {\n          next.active = false;\n        }\n        if (!next.active) {\n          next.decorationId = null;\n          next.range = { from: 0, to: 0 };\n          next.query = null;\n          next.text = null;\n        }\n        return next;\n      }\n    },\n    props: {\n      // Call the keydown hook if suggestion is active.\n      handleKeyDown(view, event) {\n        var _a, _b, _c, _d;\n        const { active, range } = plugin.getState(view.state);\n        if (!active) {\n          return false;\n        }\n        if (event.key === \"Escape\" || event.key === \"Esc\") {\n          const state = plugin.getState(view.state);\n          const cachedNode = (_a = props == null ? void 0 : props.decorationNode) != null ? _a : null;\n          const decorationNode = cachedNode != null ? cachedNode : (state == null ? void 0 : state.decorationId) ? view.dom.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`) : null;\n          const handledByKeyDown = ((_b = renderer == null ? void 0 : renderer.onKeyDown) == null ? void 0 : _b.call(renderer, { view, event, range: state.range })) || false;\n          if (handledByKeyDown) {\n            return true;\n          }\n          const exitProps = {\n            editor,\n            range: state.range,\n            query: state.query,\n            text: state.text,\n            items: [],\n            command: (commandProps) => {\n              return command({ editor, range: state.range, props: commandProps });\n            },\n            decorationNode,\n            // If we have a cached decoration node, use it for the clientRect\n            // to avoid another DOM lookup. If not, leave clientRect null and\n            // let consumer decide if they want to query.\n            clientRect: decorationNode ? () => {\n              return decorationNode.getBoundingClientRect() || null;\n            } : null\n          };\n          (_c = renderer == null ? void 0 : renderer.onExit) == null ? void 0 : _c.call(renderer, exitProps);\n          dispatchExit(view, pluginKey);\n          return true;\n        }\n        const handled = ((_d = renderer == null ? void 0 : renderer.onKeyDown) == null ? void 0 : _d.call(renderer, { view, event, range })) || false;\n        return handled;\n      },\n      // Setup decorator on the currently active suggestion.\n      decorations(state) {\n        const { active, range, decorationId, query } = plugin.getState(state);\n        if (!active) {\n          return null;\n        }\n        const isEmpty = !(query == null ? void 0 : query.length);\n        const classNames = [decorationClass];\n        if (isEmpty) {\n          classNames.push(decorationEmptyClass);\n        }\n        return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.DecorationSet.create(state.doc, [\n          _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.inline(range.from, range.to, {\n            nodeName: decorationTag,\n            class: classNames.join(\" \"),\n            \"data-decoration-id\": decorationId,\n            \"data-decoration-content\": decorationContent\n          })\n        ]);\n      }\n    }\n  });\n  return plugin;\n}\nfunction exitSuggestion(view, pluginKeyRef = SuggestionPluginKey) {\n  const tr = view.state.tr.setMeta(pluginKeyRef, { exit: true });\n  view.dispatch(tr);\n}\n\n// src/index.ts\nvar index_default = Suggestion;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdWdnZXN0aW9uL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNxRDtBQUNPOztBQUU1RDtBQUM4QztBQUM5QztBQUNBO0FBQ0EsVUFBVSxvR0FBb0c7QUFDOUc7QUFDQSxzQkFBc0IsNERBQWM7QUFDcEMsa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLEVBQUUsWUFBWSxXQUFXLGlCQUFpQiw0QkFBNEIsT0FBTyxRQUFRLFlBQVksT0FBTyxpQkFBaUI7QUFDN0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNERBQTREO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLHVEQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixhQUFhO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILG1CQUFtQjtBQUMvSTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0JBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJEQUEyRCxnQkFBZ0IsdUJBQXVCO0FBQzdILFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLG1CQUFtQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCLFlBQVk7QUFDNUIsZ0JBQWdCLFlBQVk7QUFDNUIsZ0JBQWdCLGNBQWM7QUFDOUIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLHFDQUFxQyx1Q0FBdUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0tBQWtLLG1CQUFtQjtBQUNyTCxpSUFBaUksaUNBQWlDO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUFpRDtBQUNoRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSEFBc0gsb0JBQW9CO0FBQzFJO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0IscUNBQXFDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFhO0FBQzVCLFVBQVUsdURBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQU9FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYW5iYW5wcm8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdWdnZXN0aW9uL2Rpc3QvaW5kZXguanM/YThkZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvc3VnZ2VzdGlvbi50c1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCB9IGZyb20gXCJAdGlwdGFwL3BtL3ZpZXdcIjtcblxuLy8gc3JjL2ZpbmRTdWdnZXN0aW9uTWF0Y2gudHNcbmltcG9ydCB7IGVzY2FwZUZvclJlZ0V4IH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuZnVuY3Rpb24gZmluZFN1Z2dlc3Rpb25NYXRjaChjb25maWcpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IGNoYXIsIGFsbG93U3BhY2VzOiBhbGxvd1NwYWNlc09wdGlvbiwgYWxsb3dUb0luY2x1ZGVDaGFyLCBhbGxvd2VkUHJlZml4ZXMsIHN0YXJ0T2ZMaW5lLCAkcG9zaXRpb24gfSA9IGNvbmZpZztcbiAgY29uc3QgYWxsb3dTcGFjZXMgPSBhbGxvd1NwYWNlc09wdGlvbiAmJiAhYWxsb3dUb0luY2x1ZGVDaGFyO1xuICBjb25zdCBlc2NhcGVkQ2hhciA9IGVzY2FwZUZvclJlZ0V4KGNoYXIpO1xuICBjb25zdCBzdWZmaXggPSBuZXcgUmVnRXhwKGBcXFxccyR7ZXNjYXBlZENoYXJ9JGApO1xuICBjb25zdCBwcmVmaXggPSBzdGFydE9mTGluZSA/IFwiXlwiIDogXCJcIjtcbiAgY29uc3QgZmluYWxFc2NhcGVkQ2hhciA9IGFsbG93VG9JbmNsdWRlQ2hhciA/IFwiXCIgOiBlc2NhcGVkQ2hhcjtcbiAgY29uc3QgcmVnZXhwID0gYWxsb3dTcGFjZXMgPyBuZXcgUmVnRXhwKGAke3ByZWZpeH0ke2VzY2FwZWRDaGFyfS4qPyg/PVxcXFxzJHtmaW5hbEVzY2FwZWRDaGFyfXwkKWAsIFwiZ21cIikgOiBuZXcgUmVnRXhwKGAke3ByZWZpeH0oPzpeKT8ke2VzY2FwZWRDaGFyfVteXFxcXHMke2ZpbmFsRXNjYXBlZENoYXJ9XSpgLCBcImdtXCIpO1xuICBjb25zdCB0ZXh0ID0gKChfYSA9ICRwb3NpdGlvbi5ub2RlQmVmb3JlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaXNUZXh0KSAmJiAkcG9zaXRpb24ubm9kZUJlZm9yZS50ZXh0O1xuICBpZiAoIXRleHQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB0ZXh0RnJvbSA9ICRwb3NpdGlvbi5wb3MgLSB0ZXh0Lmxlbmd0aDtcbiAgY29uc3QgbWF0Y2ggPSBBcnJheS5mcm9tKHRleHQubWF0Y2hBbGwocmVnZXhwKSkucG9wKCk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2guaW5wdXQgPT09IHZvaWQgMCB8fCBtYXRjaC5pbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbWF0Y2hQcmVmaXggPSBtYXRjaC5pbnB1dC5zbGljZShNYXRoLm1heCgwLCBtYXRjaC5pbmRleCAtIDEpLCBtYXRjaC5pbmRleCk7XG4gIGNvbnN0IG1hdGNoUHJlZml4SXNBbGxvd2VkID0gbmV3IFJlZ0V4cChgXlske2FsbG93ZWRQcmVmaXhlcyA9PSBudWxsID8gdm9pZCAwIDogYWxsb3dlZFByZWZpeGVzLmpvaW4oXCJcIil9XFwwXT8kYCkudGVzdChtYXRjaFByZWZpeCk7XG4gIGlmIChhbGxvd2VkUHJlZml4ZXMgIT09IG51bGwgJiYgIW1hdGNoUHJlZml4SXNBbGxvd2VkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZnJvbSA9IHRleHRGcm9tICsgbWF0Y2guaW5kZXg7XG4gIGxldCB0byA9IGZyb20gKyBtYXRjaFswXS5sZW5ndGg7XG4gIGlmIChhbGxvd1NwYWNlcyAmJiBzdWZmaXgudGVzdCh0ZXh0LnNsaWNlKHRvIC0gMSwgdG8gKyAxKSkpIHtcbiAgICBtYXRjaFswXSArPSBcIiBcIjtcbiAgICB0byArPSAxO1xuICB9XG4gIGlmIChmcm9tIDwgJHBvc2l0aW9uLnBvcyAmJiB0byA+PSAkcG9zaXRpb24ucG9zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvXG4gICAgICB9LFxuICAgICAgcXVlcnk6IG1hdGNoWzBdLnNsaWNlKGNoYXIubGVuZ3RoKSxcbiAgICAgIHRleHQ6IG1hdGNoWzBdXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gc3JjL3N1Z2dlc3Rpb24udHNcbnZhciBTdWdnZXN0aW9uUGx1Z2luS2V5ID0gbmV3IFBsdWdpbktleShcInN1Z2dlc3Rpb25cIik7XG5mdW5jdGlvbiBTdWdnZXN0aW9uKHtcbiAgcGx1Z2luS2V5ID0gU3VnZ2VzdGlvblBsdWdpbktleSxcbiAgZWRpdG9yLFxuICBjaGFyID0gXCJAXCIsXG4gIGFsbG93U3BhY2VzID0gZmFsc2UsXG4gIGFsbG93VG9JbmNsdWRlQ2hhciA9IGZhbHNlLFxuICBhbGxvd2VkUHJlZml4ZXMgPSBbXCIgXCJdLFxuICBzdGFydE9mTGluZSA9IGZhbHNlLFxuICBkZWNvcmF0aW9uVGFnID0gXCJzcGFuXCIsXG4gIGRlY29yYXRpb25DbGFzcyA9IFwic3VnZ2VzdGlvblwiLFxuICBkZWNvcmF0aW9uQ29udGVudCA9IFwiXCIsXG4gIGRlY29yYXRpb25FbXB0eUNsYXNzID0gXCJpcy1lbXB0eVwiLFxuICBjb21tYW5kID0gKCkgPT4gbnVsbCxcbiAgaXRlbXMgPSAoKSA9PiBbXSxcbiAgcmVuZGVyID0gKCkgPT4gKHt9KSxcbiAgYWxsb3cgPSAoKSA9PiB0cnVlLFxuICBmaW5kU3VnZ2VzdGlvbk1hdGNoOiBmaW5kU3VnZ2VzdGlvbk1hdGNoMiA9IGZpbmRTdWdnZXN0aW9uTWF0Y2hcbn0pIHtcbiAgbGV0IHByb3BzO1xuICBjb25zdCByZW5kZXJlciA9IHJlbmRlciA9PSBudWxsID8gdm9pZCAwIDogcmVuZGVyKCk7XG4gIGNvbnN0IGdldEFuY2hvckNsaWVudFJlY3QgPSAoKSA9PiB7XG4gICAgY29uc3QgcG9zID0gZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnBvcztcbiAgICBjb25zdCBjb29yZHMgPSBlZGl0b3Iudmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgIGNvbnN0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0IH0gPSBjb29yZHM7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgRE9NUmVjdChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2xpZW50UmVjdEZvciA9ICh2aWV3LCBkZWNvcmF0aW9uTm9kZSkgPT4ge1xuICAgIGlmICghZGVjb3JhdGlvbk5vZGUpIHtcbiAgICAgIHJldHVybiBnZXRBbmNob3JDbGllbnRSZWN0O1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSBwbHVnaW5LZXkuZ2V0U3RhdGUoZWRpdG9yLnN0YXRlKTtcbiAgICAgIGNvbnN0IGRlY29yYXRpb25JZCA9IHN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5kZWNvcmF0aW9uSWQ7XG4gICAgICBjb25zdCBjdXJyZW50RGVjb3JhdGlvbk5vZGUgPSB2aWV3LmRvbS5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kZWNvcmF0aW9uLWlkPVwiJHtkZWNvcmF0aW9uSWR9XCJdYCk7XG4gICAgICByZXR1cm4gKGN1cnJlbnREZWNvcmF0aW9uTm9kZSA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudERlY29yYXRpb25Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSB8fCBudWxsO1xuICAgIH07XG4gIH07XG4gIGZ1bmN0aW9uIGRpc3BhdGNoRXhpdCh2aWV3LCBwbHVnaW5LZXlSZWYpIHtcbiAgICB2YXIgX2E7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gcGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpO1xuICAgICAgY29uc3QgZGVjb3JhdGlvbk5vZGUgPSAoc3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmRlY29yYXRpb25JZCkgPyB2aWV3LmRvbS5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kZWNvcmF0aW9uLWlkPVwiJHtzdGF0ZS5kZWNvcmF0aW9uSWR9XCJdYCkgOiBudWxsO1xuICAgICAgY29uc3QgZXhpdFByb3BzID0ge1xuICAgICAgICAvLyBAdHMtaWdub3JlIGVkaXRvciBpcyBhdmFpbGFibGUgaW4gY2xvc3VyZVxuICAgICAgICBlZGl0b3IsXG4gICAgICAgIHJhbmdlOiAoc3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLnJhbmdlKSB8fCB7IGZyb206IDAsIHRvOiAwIH0sXG4gICAgICAgIHF1ZXJ5OiAoc3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLnF1ZXJ5KSB8fCBudWxsLFxuICAgICAgICB0ZXh0OiAoc3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLnRleHQpIHx8IG51bGwsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgY29tbWFuZDogKGNvbW1hbmRQcm9wcykgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kKHsgZWRpdG9yLCByYW5nZTogKHN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5yYW5nZSkgfHwgeyBmcm9tOiAwLCB0bzogMCB9LCBwcm9wczogY29tbWFuZFByb3BzIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvcmF0aW9uTm9kZSxcbiAgICAgICAgY2xpZW50UmVjdDogY2xpZW50UmVjdEZvcih2aWV3LCBkZWNvcmF0aW9uTm9kZSlcbiAgICAgIH07XG4gICAgICAoX2EgPSByZW5kZXJlciA9PSBudWxsID8gdm9pZCAwIDogcmVuZGVyZXIub25FeGl0KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChyZW5kZXJlciwgZXhpdFByb3BzKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyLnNldE1ldGEocGx1Z2luS2V5UmVmLCB7IGV4aXQ6IHRydWUgfSk7XG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG4gIH1cbiAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih7XG4gICAga2V5OiBwbHVnaW5LZXksXG4gICAgdmlldygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZTogYXN5bmMgKHZpZXcsIHByZXZTdGF0ZSkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICBjb25zdCBwcmV2ID0gKF9hID0gdGhpcy5rZXkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nZXRTdGF0ZShwcmV2U3RhdGUpO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSAoX2IgPSB0aGlzLmtleSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmdldFN0YXRlKHZpZXcuc3RhdGUpO1xuICAgICAgICAgIGNvbnN0IG1vdmVkID0gcHJldi5hY3RpdmUgJiYgbmV4dC5hY3RpdmUgJiYgcHJldi5yYW5nZS5mcm9tICE9PSBuZXh0LnJhbmdlLmZyb207XG4gICAgICAgICAgY29uc3Qgc3RhcnRlZCA9ICFwcmV2LmFjdGl2ZSAmJiBuZXh0LmFjdGl2ZTtcbiAgICAgICAgICBjb25zdCBzdG9wcGVkID0gcHJldi5hY3RpdmUgJiYgIW5leHQuYWN0aXZlO1xuICAgICAgICAgIGNvbnN0IGNoYW5nZWQgPSAhc3RhcnRlZCAmJiAhc3RvcHBlZCAmJiBwcmV2LnF1ZXJ5ICE9PSBuZXh0LnF1ZXJ5O1xuICAgICAgICAgIGNvbnN0IGhhbmRsZVN0YXJ0ID0gc3RhcnRlZCB8fCBtb3ZlZCAmJiBjaGFuZ2VkO1xuICAgICAgICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IGNoYW5nZWQgfHwgbW92ZWQ7XG4gICAgICAgICAgY29uc3QgaGFuZGxlRXhpdCA9IHN0b3BwZWQgfHwgbW92ZWQgJiYgY2hhbmdlZDtcbiAgICAgICAgICBpZiAoIWhhbmRsZVN0YXJ0ICYmICFoYW5kbGVDaGFuZ2UgJiYgIWhhbmRsZUV4aXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBoYW5kbGVFeGl0ICYmICFoYW5kbGVTdGFydCA/IHByZXYgOiBuZXh0O1xuICAgICAgICAgIGNvbnN0IGRlY29yYXRpb25Ob2RlID0gdmlldy5kb20ucXVlcnlTZWxlY3RvcihgW2RhdGEtZGVjb3JhdGlvbi1pZD1cIiR7c3RhdGUuZGVjb3JhdGlvbklkfVwiXWApO1xuICAgICAgICAgIHByb3BzID0ge1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLnJhbmdlLFxuICAgICAgICAgICAgcXVlcnk6IHN0YXRlLnF1ZXJ5LFxuICAgICAgICAgICAgdGV4dDogc3RhdGUudGV4dCxcbiAgICAgICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgICAgIGNvbW1hbmQ6IChjb21tYW5kUHJvcHMpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQoe1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICByYW5nZTogc3RhdGUucmFuZ2UsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGNvbW1hbmRQcm9wc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvcmF0aW9uTm9kZSxcbiAgICAgICAgICAgIGNsaWVudFJlY3Q6IGNsaWVudFJlY3RGb3IodmlldywgZGVjb3JhdGlvbk5vZGUpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaGFuZGxlU3RhcnQpIHtcbiAgICAgICAgICAgIChfYyA9IHJlbmRlcmVyID09IG51bGwgPyB2b2lkIDAgOiByZW5kZXJlci5vbkJlZm9yZVN0YXJ0KSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChyZW5kZXJlciwgcHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlQ2hhbmdlKSB7XG4gICAgICAgICAgICAoX2QgPSByZW5kZXJlciA9PSBudWxsID8gdm9pZCAwIDogcmVuZGVyZXIub25CZWZvcmVVcGRhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jYWxsKHJlbmRlcmVyLCBwcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVDaGFuZ2UgfHwgaGFuZGxlU3RhcnQpIHtcbiAgICAgICAgICAgIHByb3BzLml0ZW1zID0gYXdhaXQgaXRlbXMoe1xuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIHF1ZXJ5OiBzdGF0ZS5xdWVyeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVFeGl0KSB7XG4gICAgICAgICAgICAoX2UgPSByZW5kZXJlciA9PSBudWxsID8gdm9pZCAwIDogcmVuZGVyZXIub25FeGl0KSA9PSBudWxsID8gdm9pZCAwIDogX2UuY2FsbChyZW5kZXJlciwgcHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlQ2hhbmdlKSB7XG4gICAgICAgICAgICAoX2YgPSByZW5kZXJlciA9PSBudWxsID8gdm9pZCAwIDogcmVuZGVyZXIub25VcGRhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfZi5jYWxsKHJlbmRlcmVyLCBwcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVTdGFydCkge1xuICAgICAgICAgICAgKF9nID0gcmVuZGVyZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uU3RhcnQpID09IG51bGwgPyB2b2lkIDAgOiBfZy5jYWxsKHJlbmRlcmVyLCBwcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgKF9hID0gcmVuZGVyZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uRXhpdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwocmVuZGVyZXIsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHN0YXRlOiB7XG4gICAgICAvLyBJbml0aWFsaXplIHRoZSBwbHVnaW4ncyBpbnRlcm5hbCBzdGF0ZS5cbiAgICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgIGZyb206IDAsXG4gICAgICAgICAgICB0bzogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcXVlcnk6IG51bGwsXG4gICAgICAgICAgdGV4dDogbnVsbCxcbiAgICAgICAgICBjb21wb3Npbmc6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH0sXG4gICAgICAvLyBBcHBseSBjaGFuZ2VzIHRvIHRoZSBwbHVnaW4gc3RhdGUgZnJvbSBhIHZpZXcgdHJhbnNhY3Rpb24uXG4gICAgICBhcHBseSh0cmFuc2FjdGlvbiwgcHJldiwgX29sZFN0YXRlLCBzdGF0ZSkge1xuICAgICAgICBjb25zdCB7IGlzRWRpdGFibGUgfSA9IGVkaXRvcjtcbiAgICAgICAgY29uc3QgeyBjb21wb3NpbmcgfSA9IGVkaXRvci52aWV3O1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJhbnNhY3Rpb247XG4gICAgICAgIGNvbnN0IHsgZW1wdHksIGZyb20gfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgY29uc3QgbmV4dCA9IHsgLi4ucHJldiB9O1xuICAgICAgICBjb25zdCBtZXRhID0gdHJhbnNhY3Rpb24uZ2V0TWV0YShwbHVnaW5LZXkpO1xuICAgICAgICBpZiAobWV0YSAmJiBtZXRhLmV4aXQpIHtcbiAgICAgICAgICBuZXh0LmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIG5leHQuZGVjb3JhdGlvbklkID0gbnVsbDtcbiAgICAgICAgICBuZXh0LnJhbmdlID0geyBmcm9tOiAwLCB0bzogMCB9O1xuICAgICAgICAgIG5leHQucXVlcnkgPSBudWxsO1xuICAgICAgICAgIG5leHQudGV4dCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5jb21wb3NpbmcgPSBjb21wb3Npbmc7XG4gICAgICAgIGlmIChpc0VkaXRhYmxlICYmIChlbXB0eSB8fCBlZGl0b3Iudmlldy5jb21wb3NpbmcpKSB7XG4gICAgICAgICAgaWYgKChmcm9tIDwgcHJldi5yYW5nZS5mcm9tIHx8IGZyb20gPiBwcmV2LnJhbmdlLnRvKSAmJiAhY29tcG9zaW5nICYmICFwcmV2LmNvbXBvc2luZykge1xuICAgICAgICAgICAgbmV4dC5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBmaW5kU3VnZ2VzdGlvbk1hdGNoMih7XG4gICAgICAgICAgICBjaGFyLFxuICAgICAgICAgICAgYWxsb3dTcGFjZXMsXG4gICAgICAgICAgICBhbGxvd1RvSW5jbHVkZUNoYXIsXG4gICAgICAgICAgICBhbGxvd2VkUHJlZml4ZXMsXG4gICAgICAgICAgICBzdGFydE9mTGluZSxcbiAgICAgICAgICAgICRwb3NpdGlvbjogc2VsZWN0aW9uLiRmcm9tXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgZGVjb3JhdGlvbklkID0gYGlkXyR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NSl9YDtcbiAgICAgICAgICBpZiAobWF0Y2ggJiYgYWxsb3coe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICByYW5nZTogbWF0Y2gucmFuZ2UsXG4gICAgICAgICAgICBpc0FjdGl2ZTogcHJldi5hY3RpdmVcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgbmV4dC5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgbmV4dC5kZWNvcmF0aW9uSWQgPSBwcmV2LmRlY29yYXRpb25JZCA/IHByZXYuZGVjb3JhdGlvbklkIDogZGVjb3JhdGlvbklkO1xuICAgICAgICAgICAgbmV4dC5yYW5nZSA9IG1hdGNoLnJhbmdlO1xuICAgICAgICAgICAgbmV4dC5xdWVyeSA9IG1hdGNoLnF1ZXJ5O1xuICAgICAgICAgICAgbmV4dC50ZXh0ID0gbWF0Y2gudGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dC5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dC5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5leHQuYWN0aXZlKSB7XG4gICAgICAgICAgbmV4dC5kZWNvcmF0aW9uSWQgPSBudWxsO1xuICAgICAgICAgIG5leHQucmFuZ2UgPSB7IGZyb206IDAsIHRvOiAwIH07XG4gICAgICAgICAgbmV4dC5xdWVyeSA9IG51bGw7XG4gICAgICAgICAgbmV4dC50ZXh0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAvLyBDYWxsIHRoZSBrZXlkb3duIGhvb2sgaWYgc3VnZ2VzdGlvbiBpcyBhY3RpdmUuXG4gICAgICBoYW5kbGVLZXlEb3duKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgeyBhY3RpdmUsIHJhbmdlIH0gPSBwbHVnaW4uZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIgfHwgZXZlbnQua2V5ID09PSBcIkVzY1wiKSB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBwbHVnaW4uZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgY29uc3QgY2FjaGVkTm9kZSA9IChfYSA9IHByb3BzID09IG51bGwgPyB2b2lkIDAgOiBwcm9wcy5kZWNvcmF0aW9uTm9kZSkgIT0gbnVsbCA/IF9hIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uTm9kZSA9IGNhY2hlZE5vZGUgIT0gbnVsbCA/IGNhY2hlZE5vZGUgOiAoc3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmRlY29yYXRpb25JZCkgPyB2aWV3LmRvbS5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kZWNvcmF0aW9uLWlkPVwiJHtzdGF0ZS5kZWNvcmF0aW9uSWR9XCJdYCkgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGhhbmRsZWRCeUtleURvd24gPSAoKF9iID0gcmVuZGVyZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uS2V5RG93bikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwocmVuZGVyZXIsIHsgdmlldywgZXZlbnQsIHJhbmdlOiBzdGF0ZS5yYW5nZSB9KSkgfHwgZmFsc2U7XG4gICAgICAgICAgaWYgKGhhbmRsZWRCeUtleURvd24pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBleGl0UHJvcHMgPSB7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICByYW5nZTogc3RhdGUucmFuZ2UsXG4gICAgICAgICAgICBxdWVyeTogc3RhdGUucXVlcnksXG4gICAgICAgICAgICB0ZXh0OiBzdGF0ZS50ZXh0LFxuICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgY29tbWFuZDogKGNvbW1hbmRQcm9wcykgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZCh7IGVkaXRvciwgcmFuZ2U6IHN0YXRlLnJhbmdlLCBwcm9wczogY29tbWFuZFByb3BzIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29yYXRpb25Ob2RlLFxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGNhY2hlZCBkZWNvcmF0aW9uIG5vZGUsIHVzZSBpdCBmb3IgdGhlIGNsaWVudFJlY3RcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIGFub3RoZXIgRE9NIGxvb2t1cC4gSWYgbm90LCBsZWF2ZSBjbGllbnRSZWN0IG51bGwgYW5kXG4gICAgICAgICAgICAvLyBsZXQgY29uc3VtZXIgZGVjaWRlIGlmIHRoZXkgd2FudCB0byBxdWVyeS5cbiAgICAgICAgICAgIGNsaWVudFJlY3Q6IGRlY29yYXRpb25Ob2RlID8gKCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gZGVjb3JhdGlvbk5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfHwgbnVsbDtcbiAgICAgICAgICAgIH0gOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICAoX2MgPSByZW5kZXJlciA9PSBudWxsID8gdm9pZCAwIDogcmVuZGVyZXIub25FeGl0KSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChyZW5kZXJlciwgZXhpdFByb3BzKTtcbiAgICAgICAgICBkaXNwYXRjaEV4aXQodmlldywgcGx1Z2luS2V5KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYW5kbGVkID0gKChfZCA9IHJlbmRlcmVyID09IG51bGwgPyB2b2lkIDAgOiByZW5kZXJlci5vbktleURvd24pID09IG51bGwgPyB2b2lkIDAgOiBfZC5jYWxsKHJlbmRlcmVyLCB7IHZpZXcsIGV2ZW50LCByYW5nZSB9KSkgfHwgZmFsc2U7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgICAgfSxcbiAgICAgIC8vIFNldHVwIGRlY29yYXRvciBvbiB0aGUgY3VycmVudGx5IGFjdGl2ZSBzdWdnZXN0aW9uLlxuICAgICAgZGVjb3JhdGlvbnMoc3RhdGUpIHtcbiAgICAgICAgY29uc3QgeyBhY3RpdmUsIHJhbmdlLCBkZWNvcmF0aW9uSWQsIHF1ZXJ5IH0gPSBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRW1wdHkgPSAhKHF1ZXJ5ID09IG51bGwgPyB2b2lkIDAgOiBxdWVyeS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gW2RlY29yYXRpb25DbGFzc107XG4gICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKGRlY29yYXRpb25FbXB0eUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoc3RhdGUuZG9jLCBbXG4gICAgICAgICAgRGVjb3JhdGlvbi5pbmxpbmUocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHtcbiAgICAgICAgICAgIG5vZGVOYW1lOiBkZWNvcmF0aW9uVGFnLFxuICAgICAgICAgICAgY2xhc3M6IGNsYXNzTmFtZXMuam9pbihcIiBcIiksXG4gICAgICAgICAgICBcImRhdGEtZGVjb3JhdGlvbi1pZFwiOiBkZWNvcmF0aW9uSWQsXG4gICAgICAgICAgICBcImRhdGEtZGVjb3JhdGlvbi1jb250ZW50XCI6IGRlY29yYXRpb25Db250ZW50XG4gICAgICAgICAgfSlcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBsdWdpbjtcbn1cbmZ1bmN0aW9uIGV4aXRTdWdnZXN0aW9uKHZpZXcsIHBsdWdpbktleVJlZiA9IFN1Z2dlc3Rpb25QbHVnaW5LZXkpIHtcbiAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyLnNldE1ldGEocGx1Z2luS2V5UmVmLCB7IGV4aXQ6IHRydWUgfSk7XG4gIHZpZXcuZGlzcGF0Y2godHIpO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gU3VnZ2VzdGlvbjtcbmV4cG9ydCB7XG4gIFN1Z2dlc3Rpb24sXG4gIFN1Z2dlc3Rpb25QbHVnaW5LZXksXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgZXhpdFN1Z2dlc3Rpb24sXG4gIGZpbmRTdWdnZXN0aW9uTWF0Y2hcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/suggestion/dist/index.js\n");

/***/ })

};
;